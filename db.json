{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/card/source/css/style.less","path":"css/style.less","modified":1,"renderable":1},{"_id":"themes/card/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/card/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/card/source/img/brand.jpg","path":"img/brand.jpg","modified":1,"renderable":1},{"_id":"themes/card/source/img/cc.png","path":"img/cc.png","modified":1,"renderable":1},{"_id":"themes/card/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/card/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/card/source/img/wechat.jpg","path":"img/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/card/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/main.min.js","path":"js/main.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/search.min.js","path":"js/search.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/css/cloudTie/mobile.less","path":"css/cloudTie/mobile.less","modified":1,"renderable":1},{"_id":"themes/card/source/css/cloudTie/pc.less","path":"css/cloudTie/pc.less","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/loader.js","path":"js/cloudTie/loader.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/loader.min.js","path":"js/cloudTie/loader.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/mobile.min.js","path":"js/cloudTie/mobile.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/mobile.js","path":"js/cloudTie/mobile.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/pc.min.js","path":"js/cloudTie/pc.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/pc.js","path":"js/cloudTie/pc.js","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"5d81ce2dcb3d8aac68600c9c1ec8b028c6da0b2c","modified":1502534527143},{"_id":"themes/card/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1501290352000},{"_id":"themes/card/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1501290352000},{"_id":"themes/card/README.md","hash":"b188fb95a9c16eb188eeffa6caa0895a14676338","modified":1501290352000},{"_id":"themes/card/_config.yml","hash":"6d1df9f39f3e132f53da413a24c696dffaeebe3e","modified":1502535218317},{"_id":"themes/card/package.json","hash":"62482f4b9d8122d2d1577f8190dd27c84a702445","modified":1501290352000},{"_id":"source/share/index.md","hash":"57fdf5320690f273c61323fa7cda0196b25e183c","modified":1502534527147},{"_id":"source/about/index.md","hash":"cf174c69f666a4132065f3f327b06138950f5b3e","modified":1502534527147},{"_id":"source/_posts/DOM-BOM.md","hash":"f79d0e62d1da301f5c3a8a977c1a13d702985d39","modified":1502534527144},{"_id":"source/_posts/css3.md","hash":"e95658e780267e92a71d6c1e34988d550bcc1a29","modified":1502534527145},{"_id":"source/_posts/dajian.md","hash":"dfea99e5741580e8863175cc0ac24770b58df79f","modified":1502632146563},{"_id":"source/_posts/git.md","hash":"643e4ced32997cde9105f39dce02c66065b32804","modified":1502634218401},{"_id":"source/_posts/http.md","hash":"d9c183321348f6a3e347e860229222ab9cea8ca0","modified":1502627553207},{"_id":"source/_posts/js.md","hash":"99d9bdcdc9c01394f9b715f523738ccb17dfaf91","modified":1502534527145},{"_id":"source/_posts/post.md","hash":"7771cbd4f8ea6c5ceaeee1700f61648ca32b4f2b","modified":1502534527146},{"_id":"source/_posts/question.md","hash":"44a1f7939d655731db0ec658f34177160fda6e1e","modified":1502534527146},{"_id":"source/_posts/sort.md","hash":"f4567f33c9d665e485fd367bd853cb9898b88f3a","modified":1502531690855},{"_id":"source/_posts/yu.md","hash":"97de8abaea43252973e0617c25019469d92aeafc","modified":1502633844833},{"_id":"source/_posts/zhixiang.md","hash":"78baa93b4a4b195b2509609f53aabc9be2cd13f1","modified":1502534527146},{"_id":"themes/card/comments/youyuan.ejs","hash":"2e74fc22406dd63b6e6e72f82b1b15026cd6fd14","modified":1501749190000},{"_id":"themes/card/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1501290352000},{"_id":"themes/card/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1501290352000},{"_id":"themes/card/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1501290352000},{"_id":"themes/card/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1501290352000},{"_id":"themes/card/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1501290352000},{"_id":"themes/card/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1501290352000},{"_id":"themes/card/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1501290352000},{"_id":"themes/card/layout/page.ejs","hash":"afb98face24d39a21ebbbde6592a9afc98572aa4","modified":1501290352000},{"_id":"themes/card/layout/layout.ejs","hash":"d52f43fa9572d70cae834e4887c8897b43744805","modified":1501290352000},{"_id":"themes/card/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1501290352000},{"_id":"themes/card/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1501290352000},{"_id":"themes/card/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1501290352000},{"_id":"themes/card/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1501290352000},{"_id":"themes/card/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1501290352000},{"_id":"themes/card/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1501290352000},{"_id":"themes/card/layout/_partial/footer.ejs","hash":"e1a71a30a1c7a664ddf3ba3e7eb3a5b90bc4b33c","modified":1501290352000},{"_id":"themes/card/layout/_partial/head.ejs","hash":"e01d1987f1016c521a19355d38d35dc78d20f3da","modified":1501290352000},{"_id":"themes/card/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1501290352000},{"_id":"themes/card/layout/_partial/index-item.ejs","hash":"ec7b3ec79bbbead9c7e43e2e6c6b5c8bef509410","modified":1501290352000},{"_id":"themes/card/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1501290352000},{"_id":"themes/card/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1501290352000},{"_id":"themes/card/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1501290352000},{"_id":"themes/card/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1501290352000},{"_id":"themes/card/layout/_partial/script.ejs","hash":"439d6315a1b16e32b77a68c3f0cb2961d581086a","modified":1501290352000},{"_id":"themes/card/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1501290352000},{"_id":"themes/card/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1501290352000},{"_id":"themes/card/source/css/style.less","hash":"3e151cd162e8af87d7ca90e3067f7bd99a25f823","modified":1501290352000},{"_id":"themes/card/source/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1501290352000},{"_id":"themes/card/source/img/avatar.jpg","hash":"62a4893b1a32e997dcdb6e467b10559df75221e2","modified":1501290352000},{"_id":"themes/card/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1501290352000},{"_id":"themes/card/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1501290352000},{"_id":"themes/card/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1501290352000},{"_id":"themes/card/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1501290352000},{"_id":"themes/card/source/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1501290352000},{"_id":"themes/card/source/js/main.js","hash":"26688338ac55bed772e630099d2ce1ed69ef1431","modified":1501290352000},{"_id":"themes/card/source/js/main.min.js","hash":"dcec14830cf056fbbab82313ecd5886a03cdf580","modified":1501290352000},{"_id":"themes/card/source/js/search.js","hash":"c3f80dee3bab6bd4895b55b849085c8af7d1e647","modified":1501290352000},{"_id":"themes/card/source/js/search.min.js","hash":"c0c3d048af0d6b840f6f1dfda08911c7bfdb5dc1","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1501290352000},{"_id":"themes/card/layout/_partial/plugins/wangyi-ygt.ejs","hash":"0540808912afbbd8dddbdd15b8d1b54426d8b221","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/comment.ejs","hash":"298e3ad59b358620b49dc933d39e5f26388d43be","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/copyright.ejs","hash":"968b27ca952d01b066cfe49fb670faf177d6b67e","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/date.ejs","hash":"ea85b46e12d3b9c3612eef7aa76289a663fbc096","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/reward.ejs","hash":"801d786ed00ba615a3e3b9f19b238de81225a32e","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/toc.ejs","hash":"b6123e895c16ace651f1832281ff655776d4068c","modified":1501290352000},{"_id":"themes/card/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1501290352000},{"_id":"themes/card/source/css/cloudTie/_reset.less","hash":"9228ab9e7d92a3cd8cda340ae67f5b172863c835","modified":1501290352000},{"_id":"themes/card/source/css/cloudTie/_inputBox.less","hash":"3156898bbbbe0d897f475c03e1e6245e97399613","modified":1501290352000},{"_id":"themes/card/source/css/cloudTie/_share.less","hash":"9c95ca439e85fadbca00778463a9375fbeba9ad2","modified":1501290352000},{"_id":"themes/card/source/css/cloudTie/_joinCount.less","hash":"c1e5821189d17419869249cbd556d8da992fbfd3","modified":1501290352000},{"_id":"themes/card/source/css/cloudTie/mobile.less","hash":"0d68b7606a1b3c14a18a03ae3c80e4602f13c75b","modified":1501290352000},{"_id":"themes/card/source/css/cloudTie/pc.less","hash":"8038abcea49d6f74a6ff155cc565b4a675107ae6","modified":1501290352000},{"_id":"themes/card/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1501290352000},{"_id":"themes/card/source/css/_partial/article.less","hash":"4ea7ef6dc47a3df8d31bac4bdf83c17d4161f593","modified":1501290352000},{"_id":"themes/card/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1501290352000},{"_id":"themes/card/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1501290352000},{"_id":"themes/card/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1501290352000},{"_id":"themes/card/source/css/_partial/layout.less","hash":"d648da036a12470009f852902946b6c3521ad49b","modified":1501290352000},{"_id":"themes/card/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1501290352000},{"_id":"themes/card/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1501290352000},{"_id":"themes/card/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1501290352000},{"_id":"themes/card/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1501290352000},{"_id":"themes/card/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1501290352000},{"_id":"themes/card/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1501290352000},{"_id":"themes/card/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1501290352000},{"_id":"themes/card/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1501290352000},{"_id":"themes/card/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1501290352000},{"_id":"themes/card/source/css/_partial/variable.less","hash":"082896b966ed25b39c74e7b007b4f54c235685a4","modified":1501290352000},{"_id":"themes/card/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1501290352000},{"_id":"themes/card/source/js/cloudTie/loader.js","hash":"299d58e74946a2aeb8db74d3e4b6b5adfe694e15","modified":1501290352000},{"_id":"themes/card/source/js/cloudTie/loader.min.js","hash":"e73fcd885be2c4585f154861c9969e3c955d03e3","modified":1501290352000},{"_id":"themes/card/source/js/cloudTie/mobile.min.js","hash":"859e3efb15db88cedfd18f8523ecfd21f3a22324","modified":1501290352000},{"_id":"themes/card/source/css/_partial/fontawesome.less","hash":"c19f5e28365c7ba6fa938591a8021da7d603253d","modified":1501290352000},{"_id":"themes/card/source/js/cloudTie/mobile.js","hash":"67a0a31ee1e491635369b0401d629e97fccd4d94","modified":1501290352000},{"_id":"themes/card/source/js/cloudTie/pc.min.js","hash":"aea28510192fb36a36bf174716a39afd1ca20240","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1501290352000},{"_id":"themes/card/source/js/cloudTie/pc.js","hash":"25d4ae345f8122f8c7e8e48959d37523dd1e4abb","modified":1501290352000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1501290352000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1501290352000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1501290352000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1501290352000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1501290352000},{"_id":"themes/card/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1501290352000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1501290352000},{"_id":"public/atom.xml","hash":"cf3f7dd9eae6a6015fade376deb6e4521d086519","modified":1502634246648},{"_id":"public/sitemap.xml","hash":"70111b061b32f1064dfb3e15d1f53ceb00b7d4b7","modified":1502634246894},{"_id":"public/share/index.html","hash":"83d34f009171ca94f7bee302fb4c8c9afbf2c464","modified":1502634246917},{"_id":"public/about/index.html","hash":"b82de404dcaec7320ed35e212b7762b47a7b5b3c","modified":1502634246926},{"_id":"public/archives/index.html","hash":"ff7ea063aabf5d1ca6bca45e08358a4a41afe867","modified":1502634246926},{"_id":"public/archives/page/2/index.html","hash":"1e030dc64452a0bfd674dff04fac1079c4d2fa7b","modified":1502634246926},{"_id":"public/archives/2016/index.html","hash":"2bd4403d048a52e9082c1f738ae44cc88c00ae40","modified":1502634246926},{"_id":"public/archives/2016/06/index.html","hash":"2fe1c3b773d59c6741531a005cd14ab1cfbc44b6","modified":1502634246926},{"_id":"public/archives/2016/07/index.html","hash":"5bf17ae808e4e289207d868da3d88247f53ef82e","modified":1502634246926},{"_id":"public/archives/2016/08/index.html","hash":"bf34f02c910cb522bc94e84d961959d15c253459","modified":1502634246926},{"_id":"public/archives/2016/09/index.html","hash":"7e91b9a3e68e9240e3f0add4ebb45d63f7a0587c","modified":1502634246927},{"_id":"public/archives/2016/10/index.html","hash":"799bce404e94f4f046ca1737884953b9a00a86aa","modified":1502634246927},{"_id":"public/archives/2016/11/index.html","hash":"6ab99a3b92ea23a32b1b3dba092e460714b1f302","modified":1502634246927},{"_id":"public/archives/2017/index.html","hash":"0f7c02ecb80086445304836d70ea0c48a7398ee8","modified":1502634246927},{"_id":"public/archives/2017/03/index.html","hash":"a246c68c7fbf2547911508f7ee57c69e6d2da467","modified":1502634246927},{"_id":"public/archives/2017/05/index.html","hash":"694abc716c2cf1e13fb34a6f3766e04082a9ada7","modified":1502634246927},{"_id":"public/page/2/index.html","hash":"3bbbb43422eb67e9f5d8c598e371f61df310d55f","modified":1502634246927},{"_id":"public/2017/05/13/yu/index.html","hash":"3f359da3fa32ba0dfb1968177608fef3e3821105","modified":1502634246927},{"_id":"public/2017/05/13/http/index.html","hash":"8fca652e47000f8ba5cf9eb8907d054486a5443d","modified":1502634246927},{"_id":"public/2017/03/02/js/index.html","hash":"9094a83862479dbfa6c630438e5e5b0d4180eb2a","modified":1502634246927},{"_id":"public/2016/11/12/sort/index.html","hash":"42219ec92def77f4e9521128524bc87ddca8a675","modified":1502634246927},{"_id":"public/2016/10/01/post/index.html","hash":"4a8ca57f7d4390d6a2528476246607ac5a106fca","modified":1502634246927},{"_id":"public/2016/09/01/question/index.html","hash":"a8a348546ff2e390361c2d4b29a0c76e539cd5c5","modified":1502634246927},{"_id":"public/2016/08/02/zhixiang/index.html","hash":"f4d83c31d80af15adcbeec8b2fdbebd5e270bbb6","modified":1502634246927},{"_id":"public/2016/07/01/css3/index.html","hash":"18519e1b1c6517847846efdbc0f058b3f85adbd5","modified":1502634246927},{"_id":"public/2016/06/06/DOM-BOM/index.html","hash":"c5e6876678c3518730c74b89f575206594f72b97","modified":1502634246927},{"_id":"public/2016/06/05/dajian/index.html","hash":"f8b42ee9673650902a9a771c6a47db56810872a8","modified":1502634246927},{"_id":"public/index.html","hash":"5f46a7d6a29257eddd4e1b4117e1bd2fe317eaa0","modified":1502634246927},{"_id":"public/2016/06/15/git/index.html","hash":"9399c20d73a23e82861759b9ee2eabbd76d62382","modified":1502634246953},{"_id":"public/CNAME","hash":"5d81ce2dcb3d8aac68600c9c1ec8b028c6da0b2c","modified":1502634246965},{"_id":"public/css/style.less","hash":"3e151cd162e8af87d7ca90e3067f7bd99a25f823","modified":1502634246965},{"_id":"public/img/avatar.jpg","hash":"62a4893b1a32e997dcdb6e467b10559df75221e2","modified":1502634246966},{"_id":"public/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1502634246966},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1502634246966},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1502634246966},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1502634246966},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1502634246966},{"_id":"public/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1502634246966},{"_id":"public/css/cloudTie/mobile.less","hash":"0d68b7606a1b3c14a18a03ae3c80e4602f13c75b","modified":1502634246966},{"_id":"public/css/cloudTie/pc.less","hash":"8038abcea49d6f74a6ff155cc565b4a675107ae6","modified":1502634246966},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1502634246966},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1502634246966},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1502634246966},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1502634246966},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1502634246966},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1502634246967},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1502634246967},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1502634246967},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1502634246967},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1502634246967},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1502634246967},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1502634246967},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1502634246967},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1502634246967},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1502634246967},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1502634246978},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1502634246981},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1502634246986},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1502634246986},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1502634246987},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1502634246987},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1502634246987},{"_id":"public/js/search.js","hash":"c3f80dee3bab6bd4895b55b849085c8af7d1e647","modified":1502634247004},{"_id":"public/js/main.min.js","hash":"dcec14830cf056fbbab82313ecd5886a03cdf580","modified":1502634247004},{"_id":"public/js/search.min.js","hash":"c0c3d048af0d6b840f6f1dfda08911c7bfdb5dc1","modified":1502634247004},{"_id":"public/js/cloudTie/loader.js","hash":"299d58e74946a2aeb8db74d3e4b6b5adfe694e15","modified":1502634247005},{"_id":"public/js/cloudTie/loader.min.js","hash":"e73fcd885be2c4585f154861c9969e3c955d03e3","modified":1502634247005},{"_id":"public/js/main.js","hash":"26688338ac55bed772e630099d2ce1ed69ef1431","modified":1502634247005},{"_id":"public/js/cloudTie/mobile.min.js","hash":"859e3efb15db88cedfd18f8523ecfd21f3a22324","modified":1502634247005},{"_id":"public/js/cloudTie/pc.min.js","hash":"aea28510192fb36a36bf174716a39afd1ca20240","modified":1502634247005},{"_id":"public/js/cloudTie/mobile.js","hash":"67a0a31ee1e491635369b0401d629e97fccd4d94","modified":1502634247005},{"_id":"public/js/cloudTie/pc.js","hash":"25d4ae345f8122f8c7e8e48959d37523dd1e4abb","modified":1502634247005},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1502634247005},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1502634247005},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1502634247005},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1502634247033}],"Category":[],"Data":[],"Page":[{"title":"share","date":"2017-07-31T09:39:52.000Z","_content":"","source":"share/index.md","raw":"---\ntitle: share\ndate: 2017-07-31 17:39:52\n---\n","updated":"2017-08-12T10:42:07.147Z","path":"share/index.html","comments":1,"layout":"page","_id":"cj6atmsix0000ecvjwyhlc7d0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于我","date":"2017-08-02T08:50:08.000Z","tags":null,"_content":"# 本人三观端正，无不良嗜好\n# 个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\n# 爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\n# 犯我中华者，虽远必诛\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2017-08-02 16:50:08\ntags:\n---\n# 本人三观端正，无不良嗜好\n# 个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\n# 爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\n# 犯我中华者，虽远必诛\n","updated":"2017-08-12T10:42:07.147Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj6atmsj20002ecvjwpyfyao7","content":"<h1 id=\"本人三观端正，无不良嗜好\"><a href=\"#本人三观端正，无不良嗜好\" class=\"headerlink\" title=\"本人三观端正，无不良嗜好\"></a>本人三观端正，无不良嗜好</h1><h1 id=\"个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\"><a href=\"#个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\" class=\"headerlink\" title=\"个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\"></a>个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇</h1><h1 id=\"爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\"><a href=\"#爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\" class=\"headerlink\" title=\"爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\"></a>爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛</h1><h1 id=\"犯我中华者，虽远必诛\"><a href=\"#犯我中华者，虽远必诛\" class=\"headerlink\" title=\"犯我中华者，虽远必诛\"></a>犯我中华者，虽远必诛</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"本人三观端正，无不良嗜好\"><a href=\"#本人三观端正，无不良嗜好\" class=\"headerlink\" title=\"本人三观端正，无不良嗜好\"></a>本人三观端正，无不良嗜好</h1><h1 id=\"个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\"><a href=\"#个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\" class=\"headerlink\" title=\"个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\"></a>个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇</h1><h1 id=\"爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\"><a href=\"#爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\" class=\"headerlink\" title=\"爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\"></a>爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛</h1><h1 id=\"犯我中华者，虽远必诛\"><a href=\"#犯我中华者，虽远必诛\" class=\"headerlink\" title=\"犯我中华者，虽远必诛\"></a>犯我中华者，虽远必诛</h1>"}],"Post":[{"title":"DOM，BOM笔记要点","date":"2016-06-06T01:01:30.000Z","_content":"DOM: Document Object Model\n\n# DOM是专门操作网页内容的API标准\n    为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题\n    所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。\n    结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器\n    何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.\n    DOM Tree:\n    \n    什么是: 网页中一切内容在内存中都是以树形结构存储的\n           网页中每一项内容都是树上的一个节点对象\n           包括: 元素, 文字, 属性...\n           树只有一个根节点: document, 包含了所有网页内容\n    Node: 每个节点都是一个node类型的对象\n          node是所有节点的父类型\n# 三大公共: nodeType nodeName nodeValue\n\n    nodeType: 节点的类型\n      值: document   9\n         element     1\n         attribute     2\n         text         3\n      何时: 只要判断节点类型，就用nodeType\n            因为不同类型的节点，能执行的操作是不一样的\n      问题: 不能进一步区分元素的名称\n      解决:\n    nodeName: 节点的名称\n      值: document   #document\n         element    全大写的标签名\n         attribute    属性名\n         text        #text\n      何时: 只要细致鉴别元素的标签名时\n        强调: nodeName返回的是全大写的标签名\n    nodeValue: 节点值:\n      值: document   null\n         element     null\n         attribute     属性值\n         text         文本内容\n# 2、查找: 4种:\n\n      a. 不需要查找，可直接获得的元素\n            html   document.documentElement\n            head   document.head\n            body   document.body\n      b. 按节点间关系查找:\n    节点树: 包含所有节点: 元素和文本\n      1. 父子: elem.parentNode  找elem的父节点\n            elem.childNodes  找elem的所有*直接*子节点\n                返回，所有直接子节点组成的集合(类数组)\n            elem.firstChild   找elem的第一个*直接*子节点\n            elem.lastChild   找elem的最后一个*直接*子节点\n      2. 兄弟: elem.previousSibling 找elem的前一个兄弟\n            elem.nextSibling   找elem的下一个兄弟\n     何时: 前提: 已经获得了一个节点\n          要找周围临近的节点时\n     问题: 连看不见的空字符，也算文本节点——干扰\n     解决:\n    元素树: 仅包含元素节点的树结构\n           不是一棵新树，仅是节点树的子集\n     1. 父子: elem.parentElement  找elem的父元素\n            elem.children  找elem的所有*直接*子元素\n                返回，所有直接子元素组成的集合(类数组)\n            elem.firstElementChild   第一个*直接*子元素\n            elem.lastElementChild   最后一个*直接*子元素\n     2. 兄弟:\n       elem.previousElementSibling 找elem的前一个兄弟元素\n       elem.nextElementSibling   找elem的下一个兄弟元素\n     何时: 只要仅关心元素节点，不关心文本节点时\n     问题: IE9+\n     强调: childNodes和children返回的都是动态集合！\n       凡是遍历动态集合，都要先缓存元素个数，再遍历\n       for(var i=0,len= childNodes.length;i<len;i++)\n         不会导致反复查找DOM树\n# 3、 按HTML查找:\n\n        优: 范围可大可小,可设置条件\n    a、按id查找: var elem=document.getElementById(\"id\")\n      强调: 1. 只能在document对象上调用\n           2. 返回一个元素对象\n    b、按标签名查找:\n        var elems=parent.getElementsByTagName(\"标签名\");\n      强调: 1. 可在任意父元素上\n           2. 返回多个元素组成的集合\n           3. 不但查找直接子元素，还查找所有后代元素\n    c、按name属性查找: 了解\n       专门找表单中有name属性的表单元素\n        var elems=document.getElementsByName(\"name\")\n        强调: 1. 只能在document上调用\n             2. 返回多个元素组成的集合\n    d、按class属性查找:\n        var elems=parent.getElementsByClassName(\"class\")\n        强调: 1. 可在任意父元素上调用\n             2. 返回多个元素组成的集合\n             3. 不要求完整匹配，只要包含即可！\n    缺: 每次只能按一个条件查找\n       如果条件复杂，就无法一句话获得想要的元素\n# 4、 按选择器查找:\n\n    a. 只找一个元素:\n      var elem=parent.querySelector(\"selector\");\n    b. 找多个元素\n      var elems=parent.querySelectorAll(\"selector\");\n# 5、 总结:\n\n     A首次查找:\n        1. 如果条件简单: 按HTML查找: id, 标签, className\n        2. 如果条件复杂: 按选择器查找:\n     B已经获得一个元素，找周围相邻: 按节点间关系\n    鄙视: 按HTML查找 vs 按选择器查找\n     1.使用的难易程度: 当条件复杂时:\n        按选择器查找——简单, 按HTML查找——繁琐\n     2.返回值:\n        getElementsByTagName() 返回多个元素的*动态*集合\n          什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树\n        querySelectorAll()  返回多个元素的*非动态*集合\n          什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树\n     3.单次效率:\n        按HTML查找——效率高!\n        按选择器查找——效率低\n# 6、 修改: (内容, 属性, 样式)\n\n    1. 修改:\n    标准属性: 2种:\n      1. 核心DOM: 操作一切结构化文档的API(HTML，XML)\n        elem.attributes集合: 保存了当前元素的所有属性节点\n        获取属性值: elem.getAttribute(\"属性名\")\n        修改属性值: elem.setAttribute(\"属性名\",\"值\")\n        判断是否包含属性: elem.hasAttribute(\"属性名\")\n        移除属性: elem.removeAttribute(\"属性名\")\n      2. HTML DOM: 对部分常用DOM API的简化版本\n         HTML DOM将标准属性都预定义在元素对象中\n        获取属性值: elem.属性名\n        修改属性值: elem.属性名=\"值\";\n        判断是否包含属性: elem.属性名===\"\" 不包含\n        移除属性: elem.属性名=\"\"\n        特例: class属性和ES标准中的class重名\n              -> DOM -> className\n        自定义属性: 比如: data-toggle=\"dropdown\"\n          HTML DOM不能操作自定义属性\n          暂时只能用核心DOM操作:\n        三大状态: disabled  selected   checked\n          核心DOM无法操作三大状态属性\n          HTMLDOM: elem.disabled elem.selected  elem.checked\n                值都是bool类型true/false\n# 6.1、修改css样式:\n\n    1. 仅获取/修改内联样式:  elem.style.css属性名\n      问题1: css属性名有的带-\n      解决: 所有css属性名都要去横线变驼峰\n         比如: background-color: backgroundColor\n              list-style-type: listStyleType\n      问题2: 所有数值类型的属性值都是带单位的字符串\n      解决: 获取时: 都要去单位，转数值\n            修改时: 将单位拼回数值\n      问题3: 仅能获得内联样式, 无法获得样式表中的样式\n      解决: 计算后的样式: 最终应用到元素上的完整样式\n        何时: 只要希望获得元素完整的样式时\n        如何: 2步:\n          1. 获得完整样式对象style\n            var style=getComputedStyle(elem)\n          2. 获得style对象中的css属性\n            style.css属性名\n         强调: style对象中的样式都是只读\n    结论: 1. 获取样式: getComputedStyle\n         2. 修改样式: elem.style.css属性名\n    2. 运行时修改样式表中的样式:\n      Step1: 获得样式表对象:\n       var sheet=document.styleSheets[i]\n      Step2: 获得样式表对象中某个CSSRule(一个选择器{})\n       var rule=sheet.cssRules[i]\n      Step3: 修改rule.style.css属性名=值\n# 7、 添加和删除:\n\n    添加: 3步:\n     Step1: 创建空元素:\n      var a=document.createElement(\"a\");\n      <a></a>\n     Step2: 设置关键属性:\n         a.href=\"http://tmooc.cn\"\n         a.innerHTML=\"go to tmooc\";\n      <a href=\"http://tmooc.cn\">go to tmooc</a>\n     Step3: 将元素添加到DOM树: 3种:\n       1. 末尾追加: parent.appendChild(child)\n       2. 中间插入: parent.insertBefore(child, oldChild)\n       3. 替换: parent.replaceChild(child, oldChild)\n# 优化: 尽量少的修改DOM树\n\n    原因: 页面加载过程:\n      html -> DOM Tree(松树)\n               ↓\n            render Tree(圣诞树)-> layout(计算绝对布局)->paint\n               ↑                 最耗时\n      css  -> cssRules(装饰品)\n      每次修改DOM树，都会导致重新layout，耗时。\n    如何: 2种:\n     1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树\n        结果: 只触发一次layout\n# 1、 HTML DOM 常用对象: 对常用HTML元素操作的简化\n\n    Select: 代表页面上的一个select元素\n     属性: select.value 当前选中项的value\n                     没有value，就返回选中项的内容\n          select.options 保存select下所有option元素对象\n            相当于: select.getElementsByTagName(\"option\")\n            select.options.length 保存select下option的个数\n            清空select下所有option: select.options.length=0;\n          select.length 等效于select.options.length\n            清空select下所有option: select.length=0;\n                                   select.innerHTML=\"\";\n          select.selectedIndex 当前选中项的下标\n      事件: onchange 当选中项发生改变时\n      方法: select.add(option) 向select中添加一个option\n             相当于: select.appendChild(option)\n             不支持文档片段\n           select.remove(i) 移除select中i位置的一个option\n    Option: 代表页面上的一个option元素\n      创建: var opt=new Option(text,value);\n         创建一个option对象，同时设置opt的内容为text，设置opt的值为value\n         相当于: var opt=document.createElement(\"option\");\n                opt.innerHTML=text;\n                opt.value=value;\n      属性: .text 代替.innerHTML\n           .index  表示当前option在select下的下标位置\n# Table: 代表网页中一个table元素\n\n     管着行分组：\n       添加行分组: var 行分组=table.createTHead|TBody|TFoot();\n           强调: 即创建，同时又将行分组添加到table\n       删除行分组: table.deleteTHead|TFoot()\n       获取行分组: table.tHead|tFoot\n                  table.tBodies[i]\n    行分组: THead TBody TFoot\n      管着行:\n       添加行: var tr=行分组.insertRow(i)\n           在行分组中i位置插入一个新行\n           强调: 中间插入行，原i位置的行向后顺移\n           固定套路: 1. 末尾追加一个新行: 行分组.insertRow()\n                    2. 开头插入: 行分组.insertRow(0)\n       删除行: 行分组.deleteRow(i)\n           删除行分组中第i行\n           强调: i是当前行在行分组内的相对下标位置\n       获取行: 行分组.rows\n    \n    行: tr\n      管着td:\n        添加td: var td=tr.insertCell(i);\n            省略i表示右侧末尾追加\n            insertCell不支持添加th，只能添加td\n        删除td: tr.deleteCell(i);\n        获取td: tr.cells\n    \n    删除行:\n     tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标\n     问题：行分组，无法使用tr.rowIndex删除行。\n     解决: table.deleteRow(tr.rowIndex)\n     总结: 今后，删除行都用table.deleteRow(tr.rowIndex)\n# form: 代表页面上一个表单元素\n\n     获取: var form=document.forms[i/id]\n     属性: form.elements 保存了表单中所有表单元素的数组\n            包括: input   select   textarea  button\n          form.elements.length 获得表单中表单元素的个数\n          form.length => form.elements.length\n     方法: form.submit();  用于手动提交表单\n     事件: form.onsubmit  以任何方式提交表单之前自动触发\n              常用于在提交之前，验证所有表单元素的内容\n    表单元素:\n     获取: var elem=form.elements[i/id/name]\n            简写: 如果表单元素有name属性: form.name\n     方法: elem.focus() 让elem获得焦点\n          elem.blur()  让elem失去焦点\n    \n    Image: 代表页面上一个img元素\n      创建: var img=new Image();\n# DOM总结: 查找->绑定事件->查找->修改/添加/删除\n\n    查找: 4种:\n      1. 不需要查找可直接获得: html  head  body  form\n      2. 节点间关系: 节点树/元素树\n          鄙视: 递归遍历\n      3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName\n      4. 按选择器: 2种:\n          只找一个: querySelector()\n          找多个: querySelectorAll()\n    修改:\n      内容: .innerHTML  .textContent/.innerText  .value\n      属性:\n        1. 标准属性: 1. 核心DOM; 2. HTML DOM\n        2. 自定义属性: 核心DOM\n        3. 状态属性: HTML DOM\n      样式:\n        修改: elem.style.css属性=值\n        获取: var style=getComputedStyle(elem)\n             style.css属性 ——只读\n        可通过修改class属性批量应用修改多个css属性\n    添加: 3步:\n       1. createElement,\n       2.设置关键属性,\n       3. appendChild/insertBefore/replaceChild\n      优化: 尽量少的操作DOM树\n      如何: 2种:\n       1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面\n       2. 同时添加多个平级子元素: fragment\n    删除: parent.removeChild(child)\n    HTML DOM: Select/Option  Table/...  From/Element  Image\n    过渡动画: 2步:\n      css中: 添加transition\n      js中: 修改css属性值\n       不支持transition: display  zIndex\n       支持: width  height  opacity   bottom/top/left/right ...\n# 2、BOM: Browser Object Model\n\n    什么是: 专门操作浏览器窗口的API\n    比如: alert prompt confirm\n    问题: 1. 没有标准——兼容性问题;\n         2. 不可定制\n    window对象: 2个角色:\n      1. 代替ES中的Global充当全局作用域对象\n      2. 封装所有BOM和DOM的API\n    \n    打开超链接: 4种:\n      1. 在当前窗口打开，可后退\n        html: <a href=\"url\" target=\"_self\"></a>\n        js: /*window.*/open(\"url\",\"_self\")\n      2. 在当前窗口打开，不可后退\n        js: location.replace(\"url\");\n           用新url代替history中当前url，结果: 无法后退\n      3. 在新窗口打开，可打开多个\n        html: <a href=\"url\" target=\"_blank\"></a>\n        js: open(\"url\",\"_blank\")\n      4. 在新窗口打开，只能打开一个\n        html: <a href=\"url\" target=\"自定义name属性值\"></a>\n        js: open(\"url\",\"自定义name属性值\")\n        原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口\n          浏览器规定，相同name属性的窗口只能打开一个\n        其实: html中的target属性就是在设置新窗口的name属性值。\n        如果target中使用自定义的窗口名，则只能打开一个\n        预定义:\n          _self: 默认使用当前窗口自己的name属性\n               结果，新窗口覆盖当前窗口\n          _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。\n               结果: 每次打开新窗口都随机生成不同的name\n                     结果: 可打开任意多个\n# 定时器: 2种:\n\n    1. 周期性定时器:\n      什么是: 让程序按照指定时间间隔，反复执行一项任务\n      何时: 只要让程序按照指定时间间隔，反复执行一项任务\n      如何: 3件事:\n        1. 任务函数: 让定时器反复调用的函数\n        2. 启动定时器:\n         var timer=setInterval(任务函数, 间隔的毫秒数)\n        3. 停止定时器: clearInterval(timer)\n            问题: timer中的序号会残留在timer变量中\n            解决: 停止定时器后，主动清空timer\n                 timer=null\n      停止定时器: 2种:\n        1. 用户手动停止定时器: 用按钮调用clearInterval\n        2. 自动停止定时器: 在任务函数中:\n           1. 设定临界条件\n           2. 如果达到临界条件就自动调用clearInterval\n    \n    2. 一次性定时器:\n     什么是: 让程序先等待一段时间，再自动执行一次任务\n             执行一次后，定时器自动停止\n     何时: 只要先等待，再执行一次任务\n     如何: 三件事\n       1. 任务函数\n       2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)\n       3. 停止: clearTimeout(timer)\n    鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行\n    \n    for(var i=0;i<3;i++){\n      setTimeout(function(){\n        console.log(i);\n      },0);\n    }//结果: 3 3 3\n    //alert(\"Hello\") 如果不点确定，则永远不输出333\n# window:\n# history，location，document，navigator，screen，event \n\n    history: 保存当前窗口打开后，成功访问过的历史记录的栈\n      history封装的非常严密\n      只能前进，后退，刷新: history.go(n)\n       前进: go(1)  后退:go(-1)  刷新:go(0)\n    \n    location: 专门保存当前窗口正在打开的url的对象\n     属性: location.href 保存了完整的url\n            在当前窗口打开: location.href=新url\n          location.protocol: 协议\n                .host: 主机名+端口号\n                .hostname: 主机名\n                .port: 端口号\n          location.pathname: 相对路径\n                .hash: 锚点地址#xxx\n                .search: 表单提交后地址栏中的查询字符串\n                       ?变量名=值&变量名=值&...\n     方法:\n       1. 替换history中当前url,实现进制后退:\n         location.replace(\"新url\")\n       2. 在当前页面打开，可后退:\n         location.assign(\"新url\")\n           => location.href=\"新url\"\n            => location=\"新url\"\n       3. 刷新页面:  location.reload(false/true);\n         鄙视: false/true的差别\n           浏览器本地是有缓存的\n             浏览器的缓存中会保存css，图片等静态资源\n           每次请求时，首先查看缓存中是否有想要文件\n             没有想要文件，或文件过期，才去服务器下载新文件\n           reload(false) 优先使用本地缓存的文件\n           reload(true) 强制去服务器下载新文件\n         查 浏览器缓存的原理！\n# 1、event\n\n    绑定事件: 2种:\n     1. 在HTML中绑定: <ANY on事件名=\"js语句\"\n        问题: 不符合内容与行为分离的原则——不便于维护\n     2. 在js中动态绑定: 2种:\n        1. 一个事件只绑定一个处理函数:\n           elem.on事件名=function(){\n             //this->elem\n           }\n           解除绑定: elem.on事件名=null;\n           问题: 每个事件只能绑定一个处理函数\n           解决:\n        2. 一个事件可同时绑定多个处理函数:\n           elem.addEventListener(\"事件名\",function(){\n             //this->elem\n           })\n           解除绑定:\n            elem.removeEventListener(\"事件名\",\"函数名\");\n            强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数\n    \n        事件模型: DOM标准: 3个阶段\n          1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数\n          2. 目标触发: 首先执行目标元素上的事件处理函数\n          3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数\n    \n        事件对象: 事件发生时自动创建的\n                 封装事件信息\n                 提供操作事件的API 的对象\n          何时: 只要希望获得事件信息或修改事件的默认行为\n          如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！\n              .on事件名=function(e){\n                 //e会自动获得事件对象\n              }\n        阻止蔓延/冒泡: e.stopPropagation();\n        利用冒泡:\n          优化: 尽量少的添加事件监听\n          原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢\n          如何: 如果多个子元素都要绑定相同的事件\n              只要在父元素绑定一次，所有子元素即可共用\n          难题:\n             1. 获得目标元素:\n                不能用this, 因为this指父元素\n                应该用e.target，保存实际点击的目标元素\n             2. 鉴别目标元素:\n                先判断目标元素的nodeName或className...\n                只有目标元素符合要求时，才执行事件操作\n        取消事件/阻止默认行为: e.preventDefault();\n        事件坐标: 3对儿:\n          1. 相对于整个屏幕左上角的坐标: e.screenX|screenY\n          2. 相对于文档显示区左上角的坐标: e.clientX|clientY\n          3. 相对于当前元素左上角的坐标: e.offsetX|offsetY\n    \n        页面滚动:\n          事件: window.onscroll\n          获得页面滚动位置: document.body.scrollTop\n              页面超出文档显示区顶部的距离","source":"_posts/DOM-BOM.md","raw":"---\ntitle: DOM，BOM笔记要点\ndate: 2016-06-06 09:01:30\ntags:\n---\nDOM: Document Object Model\n\n# DOM是专门操作网页内容的API标准\n    为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题\n    所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。\n    结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器\n    何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.\n    DOM Tree:\n    \n    什么是: 网页中一切内容在内存中都是以树形结构存储的\n           网页中每一项内容都是树上的一个节点对象\n           包括: 元素, 文字, 属性...\n           树只有一个根节点: document, 包含了所有网页内容\n    Node: 每个节点都是一个node类型的对象\n          node是所有节点的父类型\n# 三大公共: nodeType nodeName nodeValue\n\n    nodeType: 节点的类型\n      值: document   9\n         element     1\n         attribute     2\n         text         3\n      何时: 只要判断节点类型，就用nodeType\n            因为不同类型的节点，能执行的操作是不一样的\n      问题: 不能进一步区分元素的名称\n      解决:\n    nodeName: 节点的名称\n      值: document   #document\n         element    全大写的标签名\n         attribute    属性名\n         text        #text\n      何时: 只要细致鉴别元素的标签名时\n        强调: nodeName返回的是全大写的标签名\n    nodeValue: 节点值:\n      值: document   null\n         element     null\n         attribute     属性值\n         text         文本内容\n# 2、查找: 4种:\n\n      a. 不需要查找，可直接获得的元素\n            html   document.documentElement\n            head   document.head\n            body   document.body\n      b. 按节点间关系查找:\n    节点树: 包含所有节点: 元素和文本\n      1. 父子: elem.parentNode  找elem的父节点\n            elem.childNodes  找elem的所有*直接*子节点\n                返回，所有直接子节点组成的集合(类数组)\n            elem.firstChild   找elem的第一个*直接*子节点\n            elem.lastChild   找elem的最后一个*直接*子节点\n      2. 兄弟: elem.previousSibling 找elem的前一个兄弟\n            elem.nextSibling   找elem的下一个兄弟\n     何时: 前提: 已经获得了一个节点\n          要找周围临近的节点时\n     问题: 连看不见的空字符，也算文本节点——干扰\n     解决:\n    元素树: 仅包含元素节点的树结构\n           不是一棵新树，仅是节点树的子集\n     1. 父子: elem.parentElement  找elem的父元素\n            elem.children  找elem的所有*直接*子元素\n                返回，所有直接子元素组成的集合(类数组)\n            elem.firstElementChild   第一个*直接*子元素\n            elem.lastElementChild   最后一个*直接*子元素\n     2. 兄弟:\n       elem.previousElementSibling 找elem的前一个兄弟元素\n       elem.nextElementSibling   找elem的下一个兄弟元素\n     何时: 只要仅关心元素节点，不关心文本节点时\n     问题: IE9+\n     强调: childNodes和children返回的都是动态集合！\n       凡是遍历动态集合，都要先缓存元素个数，再遍历\n       for(var i=0,len= childNodes.length;i<len;i++)\n         不会导致反复查找DOM树\n# 3、 按HTML查找:\n\n        优: 范围可大可小,可设置条件\n    a、按id查找: var elem=document.getElementById(\"id\")\n      强调: 1. 只能在document对象上调用\n           2. 返回一个元素对象\n    b、按标签名查找:\n        var elems=parent.getElementsByTagName(\"标签名\");\n      强调: 1. 可在任意父元素上\n           2. 返回多个元素组成的集合\n           3. 不但查找直接子元素，还查找所有后代元素\n    c、按name属性查找: 了解\n       专门找表单中有name属性的表单元素\n        var elems=document.getElementsByName(\"name\")\n        强调: 1. 只能在document上调用\n             2. 返回多个元素组成的集合\n    d、按class属性查找:\n        var elems=parent.getElementsByClassName(\"class\")\n        强调: 1. 可在任意父元素上调用\n             2. 返回多个元素组成的集合\n             3. 不要求完整匹配，只要包含即可！\n    缺: 每次只能按一个条件查找\n       如果条件复杂，就无法一句话获得想要的元素\n# 4、 按选择器查找:\n\n    a. 只找一个元素:\n      var elem=parent.querySelector(\"selector\");\n    b. 找多个元素\n      var elems=parent.querySelectorAll(\"selector\");\n# 5、 总结:\n\n     A首次查找:\n        1. 如果条件简单: 按HTML查找: id, 标签, className\n        2. 如果条件复杂: 按选择器查找:\n     B已经获得一个元素，找周围相邻: 按节点间关系\n    鄙视: 按HTML查找 vs 按选择器查找\n     1.使用的难易程度: 当条件复杂时:\n        按选择器查找——简单, 按HTML查找——繁琐\n     2.返回值:\n        getElementsByTagName() 返回多个元素的*动态*集合\n          什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树\n        querySelectorAll()  返回多个元素的*非动态*集合\n          什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树\n     3.单次效率:\n        按HTML查找——效率高!\n        按选择器查找——效率低\n# 6、 修改: (内容, 属性, 样式)\n\n    1. 修改:\n    标准属性: 2种:\n      1. 核心DOM: 操作一切结构化文档的API(HTML，XML)\n        elem.attributes集合: 保存了当前元素的所有属性节点\n        获取属性值: elem.getAttribute(\"属性名\")\n        修改属性值: elem.setAttribute(\"属性名\",\"值\")\n        判断是否包含属性: elem.hasAttribute(\"属性名\")\n        移除属性: elem.removeAttribute(\"属性名\")\n      2. HTML DOM: 对部分常用DOM API的简化版本\n         HTML DOM将标准属性都预定义在元素对象中\n        获取属性值: elem.属性名\n        修改属性值: elem.属性名=\"值\";\n        判断是否包含属性: elem.属性名===\"\" 不包含\n        移除属性: elem.属性名=\"\"\n        特例: class属性和ES标准中的class重名\n              -> DOM -> className\n        自定义属性: 比如: data-toggle=\"dropdown\"\n          HTML DOM不能操作自定义属性\n          暂时只能用核心DOM操作:\n        三大状态: disabled  selected   checked\n          核心DOM无法操作三大状态属性\n          HTMLDOM: elem.disabled elem.selected  elem.checked\n                值都是bool类型true/false\n# 6.1、修改css样式:\n\n    1. 仅获取/修改内联样式:  elem.style.css属性名\n      问题1: css属性名有的带-\n      解决: 所有css属性名都要去横线变驼峰\n         比如: background-color: backgroundColor\n              list-style-type: listStyleType\n      问题2: 所有数值类型的属性值都是带单位的字符串\n      解决: 获取时: 都要去单位，转数值\n            修改时: 将单位拼回数值\n      问题3: 仅能获得内联样式, 无法获得样式表中的样式\n      解决: 计算后的样式: 最终应用到元素上的完整样式\n        何时: 只要希望获得元素完整的样式时\n        如何: 2步:\n          1. 获得完整样式对象style\n            var style=getComputedStyle(elem)\n          2. 获得style对象中的css属性\n            style.css属性名\n         强调: style对象中的样式都是只读\n    结论: 1. 获取样式: getComputedStyle\n         2. 修改样式: elem.style.css属性名\n    2. 运行时修改样式表中的样式:\n      Step1: 获得样式表对象:\n       var sheet=document.styleSheets[i]\n      Step2: 获得样式表对象中某个CSSRule(一个选择器{})\n       var rule=sheet.cssRules[i]\n      Step3: 修改rule.style.css属性名=值\n# 7、 添加和删除:\n\n    添加: 3步:\n     Step1: 创建空元素:\n      var a=document.createElement(\"a\");\n      <a></a>\n     Step2: 设置关键属性:\n         a.href=\"http://tmooc.cn\"\n         a.innerHTML=\"go to tmooc\";\n      <a href=\"http://tmooc.cn\">go to tmooc</a>\n     Step3: 将元素添加到DOM树: 3种:\n       1. 末尾追加: parent.appendChild(child)\n       2. 中间插入: parent.insertBefore(child, oldChild)\n       3. 替换: parent.replaceChild(child, oldChild)\n# 优化: 尽量少的修改DOM树\n\n    原因: 页面加载过程:\n      html -> DOM Tree(松树)\n               ↓\n            render Tree(圣诞树)-> layout(计算绝对布局)->paint\n               ↑                 最耗时\n      css  -> cssRules(装饰品)\n      每次修改DOM树，都会导致重新layout，耗时。\n    如何: 2种:\n     1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树\n        结果: 只触发一次layout\n# 1、 HTML DOM 常用对象: 对常用HTML元素操作的简化\n\n    Select: 代表页面上的一个select元素\n     属性: select.value 当前选中项的value\n                     没有value，就返回选中项的内容\n          select.options 保存select下所有option元素对象\n            相当于: select.getElementsByTagName(\"option\")\n            select.options.length 保存select下option的个数\n            清空select下所有option: select.options.length=0;\n          select.length 等效于select.options.length\n            清空select下所有option: select.length=0;\n                                   select.innerHTML=\"\";\n          select.selectedIndex 当前选中项的下标\n      事件: onchange 当选中项发生改变时\n      方法: select.add(option) 向select中添加一个option\n             相当于: select.appendChild(option)\n             不支持文档片段\n           select.remove(i) 移除select中i位置的一个option\n    Option: 代表页面上的一个option元素\n      创建: var opt=new Option(text,value);\n         创建一个option对象，同时设置opt的内容为text，设置opt的值为value\n         相当于: var opt=document.createElement(\"option\");\n                opt.innerHTML=text;\n                opt.value=value;\n      属性: .text 代替.innerHTML\n           .index  表示当前option在select下的下标位置\n# Table: 代表网页中一个table元素\n\n     管着行分组：\n       添加行分组: var 行分组=table.createTHead|TBody|TFoot();\n           强调: 即创建，同时又将行分组添加到table\n       删除行分组: table.deleteTHead|TFoot()\n       获取行分组: table.tHead|tFoot\n                  table.tBodies[i]\n    行分组: THead TBody TFoot\n      管着行:\n       添加行: var tr=行分组.insertRow(i)\n           在行分组中i位置插入一个新行\n           强调: 中间插入行，原i位置的行向后顺移\n           固定套路: 1. 末尾追加一个新行: 行分组.insertRow()\n                    2. 开头插入: 行分组.insertRow(0)\n       删除行: 行分组.deleteRow(i)\n           删除行分组中第i行\n           强调: i是当前行在行分组内的相对下标位置\n       获取行: 行分组.rows\n    \n    行: tr\n      管着td:\n        添加td: var td=tr.insertCell(i);\n            省略i表示右侧末尾追加\n            insertCell不支持添加th，只能添加td\n        删除td: tr.deleteCell(i);\n        获取td: tr.cells\n    \n    删除行:\n     tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标\n     问题：行分组，无法使用tr.rowIndex删除行。\n     解决: table.deleteRow(tr.rowIndex)\n     总结: 今后，删除行都用table.deleteRow(tr.rowIndex)\n# form: 代表页面上一个表单元素\n\n     获取: var form=document.forms[i/id]\n     属性: form.elements 保存了表单中所有表单元素的数组\n            包括: input   select   textarea  button\n          form.elements.length 获得表单中表单元素的个数\n          form.length => form.elements.length\n     方法: form.submit();  用于手动提交表单\n     事件: form.onsubmit  以任何方式提交表单之前自动触发\n              常用于在提交之前，验证所有表单元素的内容\n    表单元素:\n     获取: var elem=form.elements[i/id/name]\n            简写: 如果表单元素有name属性: form.name\n     方法: elem.focus() 让elem获得焦点\n          elem.blur()  让elem失去焦点\n    \n    Image: 代表页面上一个img元素\n      创建: var img=new Image();\n# DOM总结: 查找->绑定事件->查找->修改/添加/删除\n\n    查找: 4种:\n      1. 不需要查找可直接获得: html  head  body  form\n      2. 节点间关系: 节点树/元素树\n          鄙视: 递归遍历\n      3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName\n      4. 按选择器: 2种:\n          只找一个: querySelector()\n          找多个: querySelectorAll()\n    修改:\n      内容: .innerHTML  .textContent/.innerText  .value\n      属性:\n        1. 标准属性: 1. 核心DOM; 2. HTML DOM\n        2. 自定义属性: 核心DOM\n        3. 状态属性: HTML DOM\n      样式:\n        修改: elem.style.css属性=值\n        获取: var style=getComputedStyle(elem)\n             style.css属性 ——只读\n        可通过修改class属性批量应用修改多个css属性\n    添加: 3步:\n       1. createElement,\n       2.设置关键属性,\n       3. appendChild/insertBefore/replaceChild\n      优化: 尽量少的操作DOM树\n      如何: 2种:\n       1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面\n       2. 同时添加多个平级子元素: fragment\n    删除: parent.removeChild(child)\n    HTML DOM: Select/Option  Table/...  From/Element  Image\n    过渡动画: 2步:\n      css中: 添加transition\n      js中: 修改css属性值\n       不支持transition: display  zIndex\n       支持: width  height  opacity   bottom/top/left/right ...\n# 2、BOM: Browser Object Model\n\n    什么是: 专门操作浏览器窗口的API\n    比如: alert prompt confirm\n    问题: 1. 没有标准——兼容性问题;\n         2. 不可定制\n    window对象: 2个角色:\n      1. 代替ES中的Global充当全局作用域对象\n      2. 封装所有BOM和DOM的API\n    \n    打开超链接: 4种:\n      1. 在当前窗口打开，可后退\n        html: <a href=\"url\" target=\"_self\"></a>\n        js: /*window.*/open(\"url\",\"_self\")\n      2. 在当前窗口打开，不可后退\n        js: location.replace(\"url\");\n           用新url代替history中当前url，结果: 无法后退\n      3. 在新窗口打开，可打开多个\n        html: <a href=\"url\" target=\"_blank\"></a>\n        js: open(\"url\",\"_blank\")\n      4. 在新窗口打开，只能打开一个\n        html: <a href=\"url\" target=\"自定义name属性值\"></a>\n        js: open(\"url\",\"自定义name属性值\")\n        原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口\n          浏览器规定，相同name属性的窗口只能打开一个\n        其实: html中的target属性就是在设置新窗口的name属性值。\n        如果target中使用自定义的窗口名，则只能打开一个\n        预定义:\n          _self: 默认使用当前窗口自己的name属性\n               结果，新窗口覆盖当前窗口\n          _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。\n               结果: 每次打开新窗口都随机生成不同的name\n                     结果: 可打开任意多个\n# 定时器: 2种:\n\n    1. 周期性定时器:\n      什么是: 让程序按照指定时间间隔，反复执行一项任务\n      何时: 只要让程序按照指定时间间隔，反复执行一项任务\n      如何: 3件事:\n        1. 任务函数: 让定时器反复调用的函数\n        2. 启动定时器:\n         var timer=setInterval(任务函数, 间隔的毫秒数)\n        3. 停止定时器: clearInterval(timer)\n            问题: timer中的序号会残留在timer变量中\n            解决: 停止定时器后，主动清空timer\n                 timer=null\n      停止定时器: 2种:\n        1. 用户手动停止定时器: 用按钮调用clearInterval\n        2. 自动停止定时器: 在任务函数中:\n           1. 设定临界条件\n           2. 如果达到临界条件就自动调用clearInterval\n    \n    2. 一次性定时器:\n     什么是: 让程序先等待一段时间，再自动执行一次任务\n             执行一次后，定时器自动停止\n     何时: 只要先等待，再执行一次任务\n     如何: 三件事\n       1. 任务函数\n       2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)\n       3. 停止: clearTimeout(timer)\n    鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行\n    \n    for(var i=0;i<3;i++){\n      setTimeout(function(){\n        console.log(i);\n      },0);\n    }//结果: 3 3 3\n    //alert(\"Hello\") 如果不点确定，则永远不输出333\n# window:\n# history，location，document，navigator，screen，event \n\n    history: 保存当前窗口打开后，成功访问过的历史记录的栈\n      history封装的非常严密\n      只能前进，后退，刷新: history.go(n)\n       前进: go(1)  后退:go(-1)  刷新:go(0)\n    \n    location: 专门保存当前窗口正在打开的url的对象\n     属性: location.href 保存了完整的url\n            在当前窗口打开: location.href=新url\n          location.protocol: 协议\n                .host: 主机名+端口号\n                .hostname: 主机名\n                .port: 端口号\n          location.pathname: 相对路径\n                .hash: 锚点地址#xxx\n                .search: 表单提交后地址栏中的查询字符串\n                       ?变量名=值&变量名=值&...\n     方法:\n       1. 替换history中当前url,实现进制后退:\n         location.replace(\"新url\")\n       2. 在当前页面打开，可后退:\n         location.assign(\"新url\")\n           => location.href=\"新url\"\n            => location=\"新url\"\n       3. 刷新页面:  location.reload(false/true);\n         鄙视: false/true的差别\n           浏览器本地是有缓存的\n             浏览器的缓存中会保存css，图片等静态资源\n           每次请求时，首先查看缓存中是否有想要文件\n             没有想要文件，或文件过期，才去服务器下载新文件\n           reload(false) 优先使用本地缓存的文件\n           reload(true) 强制去服务器下载新文件\n         查 浏览器缓存的原理！\n# 1、event\n\n    绑定事件: 2种:\n     1. 在HTML中绑定: <ANY on事件名=\"js语句\"\n        问题: 不符合内容与行为分离的原则——不便于维护\n     2. 在js中动态绑定: 2种:\n        1. 一个事件只绑定一个处理函数:\n           elem.on事件名=function(){\n             //this->elem\n           }\n           解除绑定: elem.on事件名=null;\n           问题: 每个事件只能绑定一个处理函数\n           解决:\n        2. 一个事件可同时绑定多个处理函数:\n           elem.addEventListener(\"事件名\",function(){\n             //this->elem\n           })\n           解除绑定:\n            elem.removeEventListener(\"事件名\",\"函数名\");\n            强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数\n    \n        事件模型: DOM标准: 3个阶段\n          1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数\n          2. 目标触发: 首先执行目标元素上的事件处理函数\n          3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数\n    \n        事件对象: 事件发生时自动创建的\n                 封装事件信息\n                 提供操作事件的API 的对象\n          何时: 只要希望获得事件信息或修改事件的默认行为\n          如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！\n              .on事件名=function(e){\n                 //e会自动获得事件对象\n              }\n        阻止蔓延/冒泡: e.stopPropagation();\n        利用冒泡:\n          优化: 尽量少的添加事件监听\n          原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢\n          如何: 如果多个子元素都要绑定相同的事件\n              只要在父元素绑定一次，所有子元素即可共用\n          难题:\n             1. 获得目标元素:\n                不能用this, 因为this指父元素\n                应该用e.target，保存实际点击的目标元素\n             2. 鉴别目标元素:\n                先判断目标元素的nodeName或className...\n                只有目标元素符合要求时，才执行事件操作\n        取消事件/阻止默认行为: e.preventDefault();\n        事件坐标: 3对儿:\n          1. 相对于整个屏幕左上角的坐标: e.screenX|screenY\n          2. 相对于文档显示区左上角的坐标: e.clientX|clientY\n          3. 相对于当前元素左上角的坐标: e.offsetX|offsetY\n    \n        页面滚动:\n          事件: window.onscroll\n          获得页面滚动位置: document.body.scrollTop\n              页面超出文档显示区顶部的距离","slug":"DOM-BOM","published":1,"updated":"2017-08-12T10:42:07.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsiy0001ecvjks4osqhh","content":"<p>DOM: Document Object Model</p>\n<h1 id=\"DOM是专门操作网页内容的API标准\"><a href=\"#DOM是专门操作网页内容的API标准\" class=\"headerlink\" title=\"DOM是专门操作网页内容的API标准\"></a>DOM是专门操作网页内容的API标准</h1><pre><code>为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题\n所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。\n结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器\n何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.\nDOM Tree:\n\n什么是: 网页中一切内容在内存中都是以树形结构存储的\n       网页中每一项内容都是树上的一个节点对象\n       包括: 元素, 文字, 属性...\n       树只有一个根节点: document, 包含了所有网页内容\nNode: 每个节点都是一个node类型的对象\n      node是所有节点的父类型\n</code></pre><h1 id=\"三大公共-nodeType-nodeName-nodeValue\"><a href=\"#三大公共-nodeType-nodeName-nodeValue\" class=\"headerlink\" title=\"三大公共: nodeType nodeName nodeValue\"></a>三大公共: nodeType nodeName nodeValue</h1><pre><code>nodeType: 节点的类型\n  值: document   9\n     element     1\n     attribute     2\n     text         3\n  何时: 只要判断节点类型，就用nodeType\n        因为不同类型的节点，能执行的操作是不一样的\n  问题: 不能进一步区分元素的名称\n  解决:\nnodeName: 节点的名称\n  值: document   #document\n     element    全大写的标签名\n     attribute    属性名\n     text        #text\n  何时: 只要细致鉴别元素的标签名时\n    强调: nodeName返回的是全大写的标签名\nnodeValue: 节点值:\n  值: document   null\n     element     null\n     attribute     属性值\n     text         文本内容\n</code></pre><h1 id=\"2、查找-4种\"><a href=\"#2、查找-4种\" class=\"headerlink\" title=\"2、查找: 4种:\"></a>2、查找: 4种:</h1><pre><code>  a. 不需要查找，可直接获得的元素\n        html   document.documentElement\n        head   document.head\n        body   document.body\n  b. 按节点间关系查找:\n节点树: 包含所有节点: 元素和文本\n  1. 父子: elem.parentNode  找elem的父节点\n        elem.childNodes  找elem的所有*直接*子节点\n            返回，所有直接子节点组成的集合(类数组)\n        elem.firstChild   找elem的第一个*直接*子节点\n        elem.lastChild   找elem的最后一个*直接*子节点\n  2. 兄弟: elem.previousSibling 找elem的前一个兄弟\n        elem.nextSibling   找elem的下一个兄弟\n 何时: 前提: 已经获得了一个节点\n      要找周围临近的节点时\n 问题: 连看不见的空字符，也算文本节点——干扰\n 解决:\n元素树: 仅包含元素节点的树结构\n       不是一棵新树，仅是节点树的子集\n 1. 父子: elem.parentElement  找elem的父元素\n        elem.children  找elem的所有*直接*子元素\n            返回，所有直接子元素组成的集合(类数组)\n        elem.firstElementChild   第一个*直接*子元素\n        elem.lastElementChild   最后一个*直接*子元素\n 2. 兄弟:\n   elem.previousElementSibling 找elem的前一个兄弟元素\n   elem.nextElementSibling   找elem的下一个兄弟元素\n 何时: 只要仅关心元素节点，不关心文本节点时\n 问题: IE9+\n 强调: childNodes和children返回的都是动态集合！\n   凡是遍历动态集合，都要先缓存元素个数，再遍历\n   for(var i=0,len= childNodes.length;i&lt;len;i++)\n     不会导致反复查找DOM树\n</code></pre><h1 id=\"3、-按HTML查找\"><a href=\"#3、-按HTML查找\" class=\"headerlink\" title=\"3、 按HTML查找:\"></a>3、 按HTML查找:</h1><pre><code>    优: 范围可大可小,可设置条件\na、按id查找: var elem=document.getElementById(&quot;id&quot;)\n  强调: 1. 只能在document对象上调用\n       2. 返回一个元素对象\nb、按标签名查找:\n    var elems=parent.getElementsByTagName(&quot;标签名&quot;);\n  强调: 1. 可在任意父元素上\n       2. 返回多个元素组成的集合\n       3. 不但查找直接子元素，还查找所有后代元素\nc、按name属性查找: 了解\n   专门找表单中有name属性的表单元素\n    var elems=document.getElementsByName(&quot;name&quot;)\n    强调: 1. 只能在document上调用\n         2. 返回多个元素组成的集合\nd、按class属性查找:\n    var elems=parent.getElementsByClassName(&quot;class&quot;)\n    强调: 1. 可在任意父元素上调用\n         2. 返回多个元素组成的集合\n         3. 不要求完整匹配，只要包含即可！\n缺: 每次只能按一个条件查找\n   如果条件复杂，就无法一句话获得想要的元素\n</code></pre><h1 id=\"4、-按选择器查找\"><a href=\"#4、-按选择器查找\" class=\"headerlink\" title=\"4、 按选择器查找:\"></a>4、 按选择器查找:</h1><pre><code>a. 只找一个元素:\n  var elem=parent.querySelector(&quot;selector&quot;);\nb. 找多个元素\n  var elems=parent.querySelectorAll(&quot;selector&quot;);\n</code></pre><h1 id=\"5、-总结\"><a href=\"#5、-总结\" class=\"headerlink\" title=\"5、 总结:\"></a>5、 总结:</h1><pre><code> A首次查找:\n    1. 如果条件简单: 按HTML查找: id, 标签, className\n    2. 如果条件复杂: 按选择器查找:\n B已经获得一个元素，找周围相邻: 按节点间关系\n鄙视: 按HTML查找 vs 按选择器查找\n 1.使用的难易程度: 当条件复杂时:\n    按选择器查找——简单, 按HTML查找——繁琐\n 2.返回值:\n    getElementsByTagName() 返回多个元素的*动态*集合\n      什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树\n    querySelectorAll()  返回多个元素的*非动态*集合\n      什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树\n 3.单次效率:\n    按HTML查找——效率高!\n    按选择器查找——效率低\n</code></pre><h1 id=\"6、-修改-内容-属性-样式\"><a href=\"#6、-修改-内容-属性-样式\" class=\"headerlink\" title=\"6、 修改: (内容, 属性, 样式)\"></a>6、 修改: (内容, 属性, 样式)</h1><pre><code>1. 修改:\n标准属性: 2种:\n  1. 核心DOM: 操作一切结构化文档的API(HTML，XML)\n    elem.attributes集合: 保存了当前元素的所有属性节点\n    获取属性值: elem.getAttribute(&quot;属性名&quot;)\n    修改属性值: elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;)\n    判断是否包含属性: elem.hasAttribute(&quot;属性名&quot;)\n    移除属性: elem.removeAttribute(&quot;属性名&quot;)\n  2. HTML DOM: 对部分常用DOM API的简化版本\n     HTML DOM将标准属性都预定义在元素对象中\n    获取属性值: elem.属性名\n    修改属性值: elem.属性名=&quot;值&quot;;\n    判断是否包含属性: elem.属性名===&quot;&quot; 不包含\n    移除属性: elem.属性名=&quot;&quot;\n    特例: class属性和ES标准中的class重名\n          -&gt; DOM -&gt; className\n    自定义属性: 比如: data-toggle=&quot;dropdown&quot;\n      HTML DOM不能操作自定义属性\n      暂时只能用核心DOM操作:\n    三大状态: disabled  selected   checked\n      核心DOM无法操作三大状态属性\n      HTMLDOM: elem.disabled elem.selected  elem.checked\n            值都是bool类型true/false\n</code></pre><h1 id=\"6-1、修改css样式\"><a href=\"#6-1、修改css样式\" class=\"headerlink\" title=\"6.1、修改css样式:\"></a>6.1、修改css样式:</h1><pre><code>1. 仅获取/修改内联样式:  elem.style.css属性名\n  问题1: css属性名有的带-\n  解决: 所有css属性名都要去横线变驼峰\n     比如: background-color: backgroundColor\n          list-style-type: listStyleType\n  问题2: 所有数值类型的属性值都是带单位的字符串\n  解决: 获取时: 都要去单位，转数值\n        修改时: 将单位拼回数值\n  问题3: 仅能获得内联样式, 无法获得样式表中的样式\n  解决: 计算后的样式: 最终应用到元素上的完整样式\n    何时: 只要希望获得元素完整的样式时\n    如何: 2步:\n      1. 获得完整样式对象style\n        var style=getComputedStyle(elem)\n      2. 获得style对象中的css属性\n        style.css属性名\n     强调: style对象中的样式都是只读\n结论: 1. 获取样式: getComputedStyle\n     2. 修改样式: elem.style.css属性名\n2. 运行时修改样式表中的样式:\n  Step1: 获得样式表对象:\n   var sheet=document.styleSheets[i]\n  Step2: 获得样式表对象中某个CSSRule(一个选择器{})\n   var rule=sheet.cssRules[i]\n  Step3: 修改rule.style.css属性名=值\n</code></pre><h1 id=\"7、-添加和删除\"><a href=\"#7、-添加和删除\" class=\"headerlink\" title=\"7、 添加和删除:\"></a>7、 添加和删除:</h1><pre><code>添加: 3步:\n Step1: 创建空元素:\n  var a=document.createElement(&quot;a&quot;);\n  &lt;a&gt;&lt;/a&gt;\n Step2: 设置关键属性:\n     a.href=&quot;http://tmooc.cn&quot;\n     a.innerHTML=&quot;go to tmooc&quot;;\n  &lt;a href=&quot;http://tmooc.cn&quot;&gt;go to tmooc&lt;/a&gt;\n Step3: 将元素添加到DOM树: 3种:\n   1. 末尾追加: parent.appendChild(child)\n   2. 中间插入: parent.insertBefore(child, oldChild)\n   3. 替换: parent.replaceChild(child, oldChild)\n</code></pre><h1 id=\"优化-尽量少的修改DOM树\"><a href=\"#优化-尽量少的修改DOM树\" class=\"headerlink\" title=\"优化: 尽量少的修改DOM树\"></a>优化: 尽量少的修改DOM树</h1><pre><code>原因: 页面加载过程:\n  html -&gt; DOM Tree(松树)\n           ↓\n        render Tree(圣诞树)-&gt; layout(计算绝对布局)-&gt;paint\n           ↑                 最耗时\n  css  -&gt; cssRules(装饰品)\n  每次修改DOM树，都会导致重新layout，耗时。\n如何: 2种:\n 1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树\n    结果: 只触发一次layout\n</code></pre><h1 id=\"1、-HTML-DOM-常用对象-对常用HTML元素操作的简化\"><a href=\"#1、-HTML-DOM-常用对象-对常用HTML元素操作的简化\" class=\"headerlink\" title=\"1、 HTML DOM 常用对象: 对常用HTML元素操作的简化\"></a>1、 HTML DOM 常用对象: 对常用HTML元素操作的简化</h1><pre><code>Select: 代表页面上的一个select元素\n 属性: select.value 当前选中项的value\n                 没有value，就返回选中项的内容\n      select.options 保存select下所有option元素对象\n        相当于: select.getElementsByTagName(&quot;option&quot;)\n        select.options.length 保存select下option的个数\n        清空select下所有option: select.options.length=0;\n      select.length 等效于select.options.length\n        清空select下所有option: select.length=0;\n                               select.innerHTML=&quot;&quot;;\n      select.selectedIndex 当前选中项的下标\n  事件: onchange 当选中项发生改变时\n  方法: select.add(option) 向select中添加一个option\n         相当于: select.appendChild(option)\n         不支持文档片段\n       select.remove(i) 移除select中i位置的一个option\nOption: 代表页面上的一个option元素\n  创建: var opt=new Option(text,value);\n     创建一个option对象，同时设置opt的内容为text，设置opt的值为value\n     相当于: var opt=document.createElement(&quot;option&quot;);\n            opt.innerHTML=text;\n            opt.value=value;\n  属性: .text 代替.innerHTML\n       .index  表示当前option在select下的下标位置\n</code></pre><h1 id=\"Table-代表网页中一个table元素\"><a href=\"#Table-代表网页中一个table元素\" class=\"headerlink\" title=\"Table: 代表网页中一个table元素\"></a>Table: 代表网页中一个table元素</h1><pre><code> 管着行分组：\n   添加行分组: var 行分组=table.createTHead|TBody|TFoot();\n       强调: 即创建，同时又将行分组添加到table\n   删除行分组: table.deleteTHead|TFoot()\n   获取行分组: table.tHead|tFoot\n              table.tBodies[i]\n行分组: THead TBody TFoot\n  管着行:\n   添加行: var tr=行分组.insertRow(i)\n       在行分组中i位置插入一个新行\n       强调: 中间插入行，原i位置的行向后顺移\n       固定套路: 1. 末尾追加一个新行: 行分组.insertRow()\n                2. 开头插入: 行分组.insertRow(0)\n   删除行: 行分组.deleteRow(i)\n       删除行分组中第i行\n       强调: i是当前行在行分组内的相对下标位置\n   获取行: 行分组.rows\n\n行: tr\n  管着td:\n    添加td: var td=tr.insertCell(i);\n        省略i表示右侧末尾追加\n        insertCell不支持添加th，只能添加td\n    删除td: tr.deleteCell(i);\n    获取td: tr.cells\n\n删除行:\n tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标\n 问题：行分组，无法使用tr.rowIndex删除行。\n 解决: table.deleteRow(tr.rowIndex)\n 总结: 今后，删除行都用table.deleteRow(tr.rowIndex)\n</code></pre><h1 id=\"form-代表页面上一个表单元素\"><a href=\"#form-代表页面上一个表单元素\" class=\"headerlink\" title=\"form: 代表页面上一个表单元素\"></a>form: 代表页面上一个表单元素</h1><pre><code> 获取: var form=document.forms[i/id]\n 属性: form.elements 保存了表单中所有表单元素的数组\n        包括: input   select   textarea  button\n      form.elements.length 获得表单中表单元素的个数\n      form.length =&gt; form.elements.length\n 方法: form.submit();  用于手动提交表单\n 事件: form.onsubmit  以任何方式提交表单之前自动触发\n          常用于在提交之前，验证所有表单元素的内容\n表单元素:\n 获取: var elem=form.elements[i/id/name]\n        简写: 如果表单元素有name属性: form.name\n 方法: elem.focus() 让elem获得焦点\n      elem.blur()  让elem失去焦点\n\nImage: 代表页面上一个img元素\n  创建: var img=new Image();\n</code></pre><h1 id=\"DOM总结-查找-gt-绑定事件-gt-查找-gt-修改-添加-删除\"><a href=\"#DOM总结-查找-gt-绑定事件-gt-查找-gt-修改-添加-删除\" class=\"headerlink\" title=\"DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除\"></a>DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除</h1><pre><code>查找: 4种:\n  1. 不需要查找可直接获得: html  head  body  form\n  2. 节点间关系: 节点树/元素树\n      鄙视: 递归遍历\n  3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName\n  4. 按选择器: 2种:\n      只找一个: querySelector()\n      找多个: querySelectorAll()\n修改:\n  内容: .innerHTML  .textContent/.innerText  .value\n  属性:\n    1. 标准属性: 1. 核心DOM; 2. HTML DOM\n    2. 自定义属性: 核心DOM\n    3. 状态属性: HTML DOM\n  样式:\n    修改: elem.style.css属性=值\n    获取: var style=getComputedStyle(elem)\n         style.css属性 ——只读\n    可通过修改class属性批量应用修改多个css属性\n添加: 3步:\n   1. createElement,\n   2.设置关键属性,\n   3. appendChild/insertBefore/replaceChild\n  优化: 尽量少的操作DOM树\n  如何: 2种:\n   1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面\n   2. 同时添加多个平级子元素: fragment\n删除: parent.removeChild(child)\nHTML DOM: Select/Option  Table/...  From/Element  Image\n过渡动画: 2步:\n  css中: 添加transition\n  js中: 修改css属性值\n   不支持transition: display  zIndex\n   支持: width  height  opacity   bottom/top/left/right ...\n</code></pre><h1 id=\"2、BOM-Browser-Object-Model\"><a href=\"#2、BOM-Browser-Object-Model\" class=\"headerlink\" title=\"2、BOM: Browser Object Model\"></a>2、BOM: Browser Object Model</h1><pre><code>什么是: 专门操作浏览器窗口的API\n比如: alert prompt confirm\n问题: 1. 没有标准——兼容性问题;\n     2. 不可定制\nwindow对象: 2个角色:\n  1. 代替ES中的Global充当全局作用域对象\n  2. 封装所有BOM和DOM的API\n\n打开超链接: 4种:\n  1. 在当前窗口打开，可后退\n    html: &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;\n    js: /*window.*/open(&quot;url&quot;,&quot;_self&quot;)\n  2. 在当前窗口打开，不可后退\n    js: location.replace(&quot;url&quot;);\n       用新url代替history中当前url，结果: 无法后退\n  3. 在新窗口打开，可打开多个\n    html: &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;\n    js: open(&quot;url&quot;,&quot;_blank&quot;)\n  4. 在新窗口打开，只能打开一个\n    html: &lt;a href=&quot;url&quot; target=&quot;自定义name属性值&quot;&gt;&lt;/a&gt;\n    js: open(&quot;url&quot;,&quot;自定义name属性值&quot;)\n    原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口\n      浏览器规定，相同name属性的窗口只能打开一个\n    其实: html中的target属性就是在设置新窗口的name属性值。\n    如果target中使用自定义的窗口名，则只能打开一个\n    预定义:\n      _self: 默认使用当前窗口自己的name属性\n           结果，新窗口覆盖当前窗口\n      _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。\n           结果: 每次打开新窗口都随机生成不同的name\n                 结果: 可打开任意多个\n</code></pre><h1 id=\"定时器-2种\"><a href=\"#定时器-2种\" class=\"headerlink\" title=\"定时器: 2种:\"></a>定时器: 2种:</h1><pre><code>1. 周期性定时器:\n  什么是: 让程序按照指定时间间隔，反复执行一项任务\n  何时: 只要让程序按照指定时间间隔，反复执行一项任务\n  如何: 3件事:\n    1. 任务函数: 让定时器反复调用的函数\n    2. 启动定时器:\n     var timer=setInterval(任务函数, 间隔的毫秒数)\n    3. 停止定时器: clearInterval(timer)\n        问题: timer中的序号会残留在timer变量中\n        解决: 停止定时器后，主动清空timer\n             timer=null\n  停止定时器: 2种:\n    1. 用户手动停止定时器: 用按钮调用clearInterval\n    2. 自动停止定时器: 在任务函数中:\n       1. 设定临界条件\n       2. 如果达到临界条件就自动调用clearInterval\n\n2. 一次性定时器:\n 什么是: 让程序先等待一段时间，再自动执行一次任务\n         执行一次后，定时器自动停止\n 何时: 只要先等待，再执行一次任务\n 如何: 三件事\n   1. 任务函数\n   2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)\n   3. 停止: clearTimeout(timer)\n鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行\n\nfor(var i=0;i&lt;3;i++){\n  setTimeout(function(){\n    console.log(i);\n  },0);\n}//结果: 3 3 3\n//alert(&quot;Hello&quot;) 如果不点确定，则永远不输出333\n</code></pre><h1 id=\"window\"><a href=\"#window\" class=\"headerlink\" title=\"window:\"></a>window:</h1><h1 id=\"history，location，document，navigator，screen，event\"><a href=\"#history，location，document，navigator，screen，event\" class=\"headerlink\" title=\"history，location，document，navigator，screen，event\"></a>history，location，document，navigator，screen，event</h1><pre><code>history: 保存当前窗口打开后，成功访问过的历史记录的栈\n  history封装的非常严密\n  只能前进，后退，刷新: history.go(n)\n   前进: go(1)  后退:go(-1)  刷新:go(0)\n\nlocation: 专门保存当前窗口正在打开的url的对象\n 属性: location.href 保存了完整的url\n        在当前窗口打开: location.href=新url\n      location.protocol: 协议\n            .host: 主机名+端口号\n            .hostname: 主机名\n            .port: 端口号\n      location.pathname: 相对路径\n            .hash: 锚点地址#xxx\n            .search: 表单提交后地址栏中的查询字符串\n                   ?变量名=值&amp;变量名=值&amp;...\n 方法:\n   1. 替换history中当前url,实现进制后退:\n     location.replace(&quot;新url&quot;)\n   2. 在当前页面打开，可后退:\n     location.assign(&quot;新url&quot;)\n       =&gt; location.href=&quot;新url&quot;\n        =&gt; location=&quot;新url&quot;\n   3. 刷新页面:  location.reload(false/true);\n     鄙视: false/true的差别\n       浏览器本地是有缓存的\n         浏览器的缓存中会保存css，图片等静态资源\n       每次请求时，首先查看缓存中是否有想要文件\n         没有想要文件，或文件过期，才去服务器下载新文件\n       reload(false) 优先使用本地缓存的文件\n       reload(true) 强制去服务器下载新文件\n     查 浏览器缓存的原理！\n</code></pre><h1 id=\"1、event\"><a href=\"#1、event\" class=\"headerlink\" title=\"1、event\"></a>1、event</h1><pre><code>绑定事件: 2种:\n 1. 在HTML中绑定: &lt;ANY on事件名=&quot;js语句&quot;\n    问题: 不符合内容与行为分离的原则——不便于维护\n 2. 在js中动态绑定: 2种:\n    1. 一个事件只绑定一个处理函数:\n       elem.on事件名=function(){\n         //this-&gt;elem\n       }\n       解除绑定: elem.on事件名=null;\n       问题: 每个事件只能绑定一个处理函数\n       解决:\n    2. 一个事件可同时绑定多个处理函数:\n       elem.addEventListener(&quot;事件名&quot;,function(){\n         //this-&gt;elem\n       })\n       解除绑定:\n        elem.removeEventListener(&quot;事件名&quot;,&quot;函数名&quot;);\n        强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数\n\n    事件模型: DOM标准: 3个阶段\n      1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数\n      2. 目标触发: 首先执行目标元素上的事件处理函数\n      3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数\n\n    事件对象: 事件发生时自动创建的\n             封装事件信息\n             提供操作事件的API 的对象\n      何时: 只要希望获得事件信息或修改事件的默认行为\n      如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！\n          .on事件名=function(e){\n             //e会自动获得事件对象\n          }\n    阻止蔓延/冒泡: e.stopPropagation();\n    利用冒泡:\n      优化: 尽量少的添加事件监听\n      原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢\n      如何: 如果多个子元素都要绑定相同的事件\n          只要在父元素绑定一次，所有子元素即可共用\n      难题:\n         1. 获得目标元素:\n            不能用this, 因为this指父元素\n            应该用e.target，保存实际点击的目标元素\n         2. 鉴别目标元素:\n            先判断目标元素的nodeName或className...\n            只有目标元素符合要求时，才执行事件操作\n    取消事件/阻止默认行为: e.preventDefault();\n    事件坐标: 3对儿:\n      1. 相对于整个屏幕左上角的坐标: e.screenX|screenY\n      2. 相对于文档显示区左上角的坐标: e.clientX|clientY\n      3. 相对于当前元素左上角的坐标: e.offsetX|offsetY\n\n    页面滚动:\n      事件: window.onscroll\n      获得页面滚动位置: document.body.scrollTop\n          页面超出文档显示区顶部的距离\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>DOM: Document Object Model</p>\n<h1 id=\"DOM是专门操作网页内容的API标准\"><a href=\"#DOM是专门操作网页内容的API标准\" class=\"headerlink\" title=\"DOM是专门操作网页内容的API标准\"></a>DOM是专门操作网页内容的API标准</h1><pre><code>为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题\n所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。\n结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器\n何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.\nDOM Tree:\n\n什么是: 网页中一切内容在内存中都是以树形结构存储的\n       网页中每一项内容都是树上的一个节点对象\n       包括: 元素, 文字, 属性...\n       树只有一个根节点: document, 包含了所有网页内容\nNode: 每个节点都是一个node类型的对象\n      node是所有节点的父类型\n</code></pre><h1 id=\"三大公共-nodeType-nodeName-nodeValue\"><a href=\"#三大公共-nodeType-nodeName-nodeValue\" class=\"headerlink\" title=\"三大公共: nodeType nodeName nodeValue\"></a>三大公共: nodeType nodeName nodeValue</h1><pre><code>nodeType: 节点的类型\n  值: document   9\n     element     1\n     attribute     2\n     text         3\n  何时: 只要判断节点类型，就用nodeType\n        因为不同类型的节点，能执行的操作是不一样的\n  问题: 不能进一步区分元素的名称\n  解决:\nnodeName: 节点的名称\n  值: document   #document\n     element    全大写的标签名\n     attribute    属性名\n     text        #text\n  何时: 只要细致鉴别元素的标签名时\n    强调: nodeName返回的是全大写的标签名\nnodeValue: 节点值:\n  值: document   null\n     element     null\n     attribute     属性值\n     text         文本内容\n</code></pre><h1 id=\"2、查找-4种\"><a href=\"#2、查找-4种\" class=\"headerlink\" title=\"2、查找: 4种:\"></a>2、查找: 4种:</h1><pre><code>  a. 不需要查找，可直接获得的元素\n        html   document.documentElement\n        head   document.head\n        body   document.body\n  b. 按节点间关系查找:\n节点树: 包含所有节点: 元素和文本\n  1. 父子: elem.parentNode  找elem的父节点\n        elem.childNodes  找elem的所有*直接*子节点\n            返回，所有直接子节点组成的集合(类数组)\n        elem.firstChild   找elem的第一个*直接*子节点\n        elem.lastChild   找elem的最后一个*直接*子节点\n  2. 兄弟: elem.previousSibling 找elem的前一个兄弟\n        elem.nextSibling   找elem的下一个兄弟\n 何时: 前提: 已经获得了一个节点\n      要找周围临近的节点时\n 问题: 连看不见的空字符，也算文本节点——干扰\n 解决:\n元素树: 仅包含元素节点的树结构\n       不是一棵新树，仅是节点树的子集\n 1. 父子: elem.parentElement  找elem的父元素\n        elem.children  找elem的所有*直接*子元素\n            返回，所有直接子元素组成的集合(类数组)\n        elem.firstElementChild   第一个*直接*子元素\n        elem.lastElementChild   最后一个*直接*子元素\n 2. 兄弟:\n   elem.previousElementSibling 找elem的前一个兄弟元素\n   elem.nextElementSibling   找elem的下一个兄弟元素\n 何时: 只要仅关心元素节点，不关心文本节点时\n 问题: IE9+\n 强调: childNodes和children返回的都是动态集合！\n   凡是遍历动态集合，都要先缓存元素个数，再遍历\n   for(var i=0,len= childNodes.length;i&lt;len;i++)\n     不会导致反复查找DOM树\n</code></pre><h1 id=\"3、-按HTML查找\"><a href=\"#3、-按HTML查找\" class=\"headerlink\" title=\"3、 按HTML查找:\"></a>3、 按HTML查找:</h1><pre><code>    优: 范围可大可小,可设置条件\na、按id查找: var elem=document.getElementById(&quot;id&quot;)\n  强调: 1. 只能在document对象上调用\n       2. 返回一个元素对象\nb、按标签名查找:\n    var elems=parent.getElementsByTagName(&quot;标签名&quot;);\n  强调: 1. 可在任意父元素上\n       2. 返回多个元素组成的集合\n       3. 不但查找直接子元素，还查找所有后代元素\nc、按name属性查找: 了解\n   专门找表单中有name属性的表单元素\n    var elems=document.getElementsByName(&quot;name&quot;)\n    强调: 1. 只能在document上调用\n         2. 返回多个元素组成的集合\nd、按class属性查找:\n    var elems=parent.getElementsByClassName(&quot;class&quot;)\n    强调: 1. 可在任意父元素上调用\n         2. 返回多个元素组成的集合\n         3. 不要求完整匹配，只要包含即可！\n缺: 每次只能按一个条件查找\n   如果条件复杂，就无法一句话获得想要的元素\n</code></pre><h1 id=\"4、-按选择器查找\"><a href=\"#4、-按选择器查找\" class=\"headerlink\" title=\"4、 按选择器查找:\"></a>4、 按选择器查找:</h1><pre><code>a. 只找一个元素:\n  var elem=parent.querySelector(&quot;selector&quot;);\nb. 找多个元素\n  var elems=parent.querySelectorAll(&quot;selector&quot;);\n</code></pre><h1 id=\"5、-总结\"><a href=\"#5、-总结\" class=\"headerlink\" title=\"5、 总结:\"></a>5、 总结:</h1><pre><code> A首次查找:\n    1. 如果条件简单: 按HTML查找: id, 标签, className\n    2. 如果条件复杂: 按选择器查找:\n B已经获得一个元素，找周围相邻: 按节点间关系\n鄙视: 按HTML查找 vs 按选择器查找\n 1.使用的难易程度: 当条件复杂时:\n    按选择器查找——简单, 按HTML查找——繁琐\n 2.返回值:\n    getElementsByTagName() 返回多个元素的*动态*集合\n      什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树\n    querySelectorAll()  返回多个元素的*非动态*集合\n      什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树\n 3.单次效率:\n    按HTML查找——效率高!\n    按选择器查找——效率低\n</code></pre><h1 id=\"6、-修改-内容-属性-样式\"><a href=\"#6、-修改-内容-属性-样式\" class=\"headerlink\" title=\"6、 修改: (内容, 属性, 样式)\"></a>6、 修改: (内容, 属性, 样式)</h1><pre><code>1. 修改:\n标准属性: 2种:\n  1. 核心DOM: 操作一切结构化文档的API(HTML，XML)\n    elem.attributes集合: 保存了当前元素的所有属性节点\n    获取属性值: elem.getAttribute(&quot;属性名&quot;)\n    修改属性值: elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;)\n    判断是否包含属性: elem.hasAttribute(&quot;属性名&quot;)\n    移除属性: elem.removeAttribute(&quot;属性名&quot;)\n  2. HTML DOM: 对部分常用DOM API的简化版本\n     HTML DOM将标准属性都预定义在元素对象中\n    获取属性值: elem.属性名\n    修改属性值: elem.属性名=&quot;值&quot;;\n    判断是否包含属性: elem.属性名===&quot;&quot; 不包含\n    移除属性: elem.属性名=&quot;&quot;\n    特例: class属性和ES标准中的class重名\n          -&gt; DOM -&gt; className\n    自定义属性: 比如: data-toggle=&quot;dropdown&quot;\n      HTML DOM不能操作自定义属性\n      暂时只能用核心DOM操作:\n    三大状态: disabled  selected   checked\n      核心DOM无法操作三大状态属性\n      HTMLDOM: elem.disabled elem.selected  elem.checked\n            值都是bool类型true/false\n</code></pre><h1 id=\"6-1、修改css样式\"><a href=\"#6-1、修改css样式\" class=\"headerlink\" title=\"6.1、修改css样式:\"></a>6.1、修改css样式:</h1><pre><code>1. 仅获取/修改内联样式:  elem.style.css属性名\n  问题1: css属性名有的带-\n  解决: 所有css属性名都要去横线变驼峰\n     比如: background-color: backgroundColor\n          list-style-type: listStyleType\n  问题2: 所有数值类型的属性值都是带单位的字符串\n  解决: 获取时: 都要去单位，转数值\n        修改时: 将单位拼回数值\n  问题3: 仅能获得内联样式, 无法获得样式表中的样式\n  解决: 计算后的样式: 最终应用到元素上的完整样式\n    何时: 只要希望获得元素完整的样式时\n    如何: 2步:\n      1. 获得完整样式对象style\n        var style=getComputedStyle(elem)\n      2. 获得style对象中的css属性\n        style.css属性名\n     强调: style对象中的样式都是只读\n结论: 1. 获取样式: getComputedStyle\n     2. 修改样式: elem.style.css属性名\n2. 运行时修改样式表中的样式:\n  Step1: 获得样式表对象:\n   var sheet=document.styleSheets[i]\n  Step2: 获得样式表对象中某个CSSRule(一个选择器{})\n   var rule=sheet.cssRules[i]\n  Step3: 修改rule.style.css属性名=值\n</code></pre><h1 id=\"7、-添加和删除\"><a href=\"#7、-添加和删除\" class=\"headerlink\" title=\"7、 添加和删除:\"></a>7、 添加和删除:</h1><pre><code>添加: 3步:\n Step1: 创建空元素:\n  var a=document.createElement(&quot;a&quot;);\n  &lt;a&gt;&lt;/a&gt;\n Step2: 设置关键属性:\n     a.href=&quot;http://tmooc.cn&quot;\n     a.innerHTML=&quot;go to tmooc&quot;;\n  &lt;a href=&quot;http://tmooc.cn&quot;&gt;go to tmooc&lt;/a&gt;\n Step3: 将元素添加到DOM树: 3种:\n   1. 末尾追加: parent.appendChild(child)\n   2. 中间插入: parent.insertBefore(child, oldChild)\n   3. 替换: parent.replaceChild(child, oldChild)\n</code></pre><h1 id=\"优化-尽量少的修改DOM树\"><a href=\"#优化-尽量少的修改DOM树\" class=\"headerlink\" title=\"优化: 尽量少的修改DOM树\"></a>优化: 尽量少的修改DOM树</h1><pre><code>原因: 页面加载过程:\n  html -&gt; DOM Tree(松树)\n           ↓\n        render Tree(圣诞树)-&gt; layout(计算绝对布局)-&gt;paint\n           ↑                 最耗时\n  css  -&gt; cssRules(装饰品)\n  每次修改DOM树，都会导致重新layout，耗时。\n如何: 2种:\n 1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树\n    结果: 只触发一次layout\n</code></pre><h1 id=\"1、-HTML-DOM-常用对象-对常用HTML元素操作的简化\"><a href=\"#1、-HTML-DOM-常用对象-对常用HTML元素操作的简化\" class=\"headerlink\" title=\"1、 HTML DOM 常用对象: 对常用HTML元素操作的简化\"></a>1、 HTML DOM 常用对象: 对常用HTML元素操作的简化</h1><pre><code>Select: 代表页面上的一个select元素\n 属性: select.value 当前选中项的value\n                 没有value，就返回选中项的内容\n      select.options 保存select下所有option元素对象\n        相当于: select.getElementsByTagName(&quot;option&quot;)\n        select.options.length 保存select下option的个数\n        清空select下所有option: select.options.length=0;\n      select.length 等效于select.options.length\n        清空select下所有option: select.length=0;\n                               select.innerHTML=&quot;&quot;;\n      select.selectedIndex 当前选中项的下标\n  事件: onchange 当选中项发生改变时\n  方法: select.add(option) 向select中添加一个option\n         相当于: select.appendChild(option)\n         不支持文档片段\n       select.remove(i) 移除select中i位置的一个option\nOption: 代表页面上的一个option元素\n  创建: var opt=new Option(text,value);\n     创建一个option对象，同时设置opt的内容为text，设置opt的值为value\n     相当于: var opt=document.createElement(&quot;option&quot;);\n            opt.innerHTML=text;\n            opt.value=value;\n  属性: .text 代替.innerHTML\n       .index  表示当前option在select下的下标位置\n</code></pre><h1 id=\"Table-代表网页中一个table元素\"><a href=\"#Table-代表网页中一个table元素\" class=\"headerlink\" title=\"Table: 代表网页中一个table元素\"></a>Table: 代表网页中一个table元素</h1><pre><code> 管着行分组：\n   添加行分组: var 行分组=table.createTHead|TBody|TFoot();\n       强调: 即创建，同时又将行分组添加到table\n   删除行分组: table.deleteTHead|TFoot()\n   获取行分组: table.tHead|tFoot\n              table.tBodies[i]\n行分组: THead TBody TFoot\n  管着行:\n   添加行: var tr=行分组.insertRow(i)\n       在行分组中i位置插入一个新行\n       强调: 中间插入行，原i位置的行向后顺移\n       固定套路: 1. 末尾追加一个新行: 行分组.insertRow()\n                2. 开头插入: 行分组.insertRow(0)\n   删除行: 行分组.deleteRow(i)\n       删除行分组中第i行\n       强调: i是当前行在行分组内的相对下标位置\n   获取行: 行分组.rows\n\n行: tr\n  管着td:\n    添加td: var td=tr.insertCell(i);\n        省略i表示右侧末尾追加\n        insertCell不支持添加th，只能添加td\n    删除td: tr.deleteCell(i);\n    获取td: tr.cells\n\n删除行:\n tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标\n 问题：行分组，无法使用tr.rowIndex删除行。\n 解决: table.deleteRow(tr.rowIndex)\n 总结: 今后，删除行都用table.deleteRow(tr.rowIndex)\n</code></pre><h1 id=\"form-代表页面上一个表单元素\"><a href=\"#form-代表页面上一个表单元素\" class=\"headerlink\" title=\"form: 代表页面上一个表单元素\"></a>form: 代表页面上一个表单元素</h1><pre><code> 获取: var form=document.forms[i/id]\n 属性: form.elements 保存了表单中所有表单元素的数组\n        包括: input   select   textarea  button\n      form.elements.length 获得表单中表单元素的个数\n      form.length =&gt; form.elements.length\n 方法: form.submit();  用于手动提交表单\n 事件: form.onsubmit  以任何方式提交表单之前自动触发\n          常用于在提交之前，验证所有表单元素的内容\n表单元素:\n 获取: var elem=form.elements[i/id/name]\n        简写: 如果表单元素有name属性: form.name\n 方法: elem.focus() 让elem获得焦点\n      elem.blur()  让elem失去焦点\n\nImage: 代表页面上一个img元素\n  创建: var img=new Image();\n</code></pre><h1 id=\"DOM总结-查找-gt-绑定事件-gt-查找-gt-修改-添加-删除\"><a href=\"#DOM总结-查找-gt-绑定事件-gt-查找-gt-修改-添加-删除\" class=\"headerlink\" title=\"DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除\"></a>DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除</h1><pre><code>查找: 4种:\n  1. 不需要查找可直接获得: html  head  body  form\n  2. 节点间关系: 节点树/元素树\n      鄙视: 递归遍历\n  3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName\n  4. 按选择器: 2种:\n      只找一个: querySelector()\n      找多个: querySelectorAll()\n修改:\n  内容: .innerHTML  .textContent/.innerText  .value\n  属性:\n    1. 标准属性: 1. 核心DOM; 2. HTML DOM\n    2. 自定义属性: 核心DOM\n    3. 状态属性: HTML DOM\n  样式:\n    修改: elem.style.css属性=值\n    获取: var style=getComputedStyle(elem)\n         style.css属性 ——只读\n    可通过修改class属性批量应用修改多个css属性\n添加: 3步:\n   1. createElement,\n   2.设置关键属性,\n   3. appendChild/insertBefore/replaceChild\n  优化: 尽量少的操作DOM树\n  如何: 2种:\n   1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面\n   2. 同时添加多个平级子元素: fragment\n删除: parent.removeChild(child)\nHTML DOM: Select/Option  Table/...  From/Element  Image\n过渡动画: 2步:\n  css中: 添加transition\n  js中: 修改css属性值\n   不支持transition: display  zIndex\n   支持: width  height  opacity   bottom/top/left/right ...\n</code></pre><h1 id=\"2、BOM-Browser-Object-Model\"><a href=\"#2、BOM-Browser-Object-Model\" class=\"headerlink\" title=\"2、BOM: Browser Object Model\"></a>2、BOM: Browser Object Model</h1><pre><code>什么是: 专门操作浏览器窗口的API\n比如: alert prompt confirm\n问题: 1. 没有标准——兼容性问题;\n     2. 不可定制\nwindow对象: 2个角色:\n  1. 代替ES中的Global充当全局作用域对象\n  2. 封装所有BOM和DOM的API\n\n打开超链接: 4种:\n  1. 在当前窗口打开，可后退\n    html: &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;\n    js: /*window.*/open(&quot;url&quot;,&quot;_self&quot;)\n  2. 在当前窗口打开，不可后退\n    js: location.replace(&quot;url&quot;);\n       用新url代替history中当前url，结果: 无法后退\n  3. 在新窗口打开，可打开多个\n    html: &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;\n    js: open(&quot;url&quot;,&quot;_blank&quot;)\n  4. 在新窗口打开，只能打开一个\n    html: &lt;a href=&quot;url&quot; target=&quot;自定义name属性值&quot;&gt;&lt;/a&gt;\n    js: open(&quot;url&quot;,&quot;自定义name属性值&quot;)\n    原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口\n      浏览器规定，相同name属性的窗口只能打开一个\n    其实: html中的target属性就是在设置新窗口的name属性值。\n    如果target中使用自定义的窗口名，则只能打开一个\n    预定义:\n      _self: 默认使用当前窗口自己的name属性\n           结果，新窗口覆盖当前窗口\n      _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。\n           结果: 每次打开新窗口都随机生成不同的name\n                 结果: 可打开任意多个\n</code></pre><h1 id=\"定时器-2种\"><a href=\"#定时器-2种\" class=\"headerlink\" title=\"定时器: 2种:\"></a>定时器: 2种:</h1><pre><code>1. 周期性定时器:\n  什么是: 让程序按照指定时间间隔，反复执行一项任务\n  何时: 只要让程序按照指定时间间隔，反复执行一项任务\n  如何: 3件事:\n    1. 任务函数: 让定时器反复调用的函数\n    2. 启动定时器:\n     var timer=setInterval(任务函数, 间隔的毫秒数)\n    3. 停止定时器: clearInterval(timer)\n        问题: timer中的序号会残留在timer变量中\n        解决: 停止定时器后，主动清空timer\n             timer=null\n  停止定时器: 2种:\n    1. 用户手动停止定时器: 用按钮调用clearInterval\n    2. 自动停止定时器: 在任务函数中:\n       1. 设定临界条件\n       2. 如果达到临界条件就自动调用clearInterval\n\n2. 一次性定时器:\n 什么是: 让程序先等待一段时间，再自动执行一次任务\n         执行一次后，定时器自动停止\n 何时: 只要先等待，再执行一次任务\n 如何: 三件事\n   1. 任务函数\n   2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)\n   3. 停止: clearTimeout(timer)\n鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行\n\nfor(var i=0;i&lt;3;i++){\n  setTimeout(function(){\n    console.log(i);\n  },0);\n}//结果: 3 3 3\n//alert(&quot;Hello&quot;) 如果不点确定，则永远不输出333\n</code></pre><h1 id=\"window\"><a href=\"#window\" class=\"headerlink\" title=\"window:\"></a>window:</h1><h1 id=\"history，location，document，navigator，screen，event\"><a href=\"#history，location，document，navigator，screen，event\" class=\"headerlink\" title=\"history，location，document，navigator，screen，event\"></a>history，location，document，navigator，screen，event</h1><pre><code>history: 保存当前窗口打开后，成功访问过的历史记录的栈\n  history封装的非常严密\n  只能前进，后退，刷新: history.go(n)\n   前进: go(1)  后退:go(-1)  刷新:go(0)\n\nlocation: 专门保存当前窗口正在打开的url的对象\n 属性: location.href 保存了完整的url\n        在当前窗口打开: location.href=新url\n      location.protocol: 协议\n            .host: 主机名+端口号\n            .hostname: 主机名\n            .port: 端口号\n      location.pathname: 相对路径\n            .hash: 锚点地址#xxx\n            .search: 表单提交后地址栏中的查询字符串\n                   ?变量名=值&amp;变量名=值&amp;...\n 方法:\n   1. 替换history中当前url,实现进制后退:\n     location.replace(&quot;新url&quot;)\n   2. 在当前页面打开，可后退:\n     location.assign(&quot;新url&quot;)\n       =&gt; location.href=&quot;新url&quot;\n        =&gt; location=&quot;新url&quot;\n   3. 刷新页面:  location.reload(false/true);\n     鄙视: false/true的差别\n       浏览器本地是有缓存的\n         浏览器的缓存中会保存css，图片等静态资源\n       每次请求时，首先查看缓存中是否有想要文件\n         没有想要文件，或文件过期，才去服务器下载新文件\n       reload(false) 优先使用本地缓存的文件\n       reload(true) 强制去服务器下载新文件\n     查 浏览器缓存的原理！\n</code></pre><h1 id=\"1、event\"><a href=\"#1、event\" class=\"headerlink\" title=\"1、event\"></a>1、event</h1><pre><code>绑定事件: 2种:\n 1. 在HTML中绑定: &lt;ANY on事件名=&quot;js语句&quot;\n    问题: 不符合内容与行为分离的原则——不便于维护\n 2. 在js中动态绑定: 2种:\n    1. 一个事件只绑定一个处理函数:\n       elem.on事件名=function(){\n         //this-&gt;elem\n       }\n       解除绑定: elem.on事件名=null;\n       问题: 每个事件只能绑定一个处理函数\n       解决:\n    2. 一个事件可同时绑定多个处理函数:\n       elem.addEventListener(&quot;事件名&quot;,function(){\n         //this-&gt;elem\n       })\n       解除绑定:\n        elem.removeEventListener(&quot;事件名&quot;,&quot;函数名&quot;);\n        强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数\n\n    事件模型: DOM标准: 3个阶段\n      1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数\n      2. 目标触发: 首先执行目标元素上的事件处理函数\n      3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数\n\n    事件对象: 事件发生时自动创建的\n             封装事件信息\n             提供操作事件的API 的对象\n      何时: 只要希望获得事件信息或修改事件的默认行为\n      如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！\n          .on事件名=function(e){\n             //e会自动获得事件对象\n          }\n    阻止蔓延/冒泡: e.stopPropagation();\n    利用冒泡:\n      优化: 尽量少的添加事件监听\n      原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢\n      如何: 如果多个子元素都要绑定相同的事件\n          只要在父元素绑定一次，所有子元素即可共用\n      难题:\n         1. 获得目标元素:\n            不能用this, 因为this指父元素\n            应该用e.target，保存实际点击的目标元素\n         2. 鉴别目标元素:\n            先判断目标元素的nodeName或className...\n            只有目标元素符合要求时，才执行事件操作\n    取消事件/阻止默认行为: e.preventDefault();\n    事件坐标: 3对儿:\n      1. 相对于整个屏幕左上角的坐标: e.screenX|screenY\n      2. 相对于文档显示区左上角的坐标: e.clientX|clientY\n      3. 相对于当前元素左上角的坐标: e.offsetX|offsetY\n\n    页面滚动:\n      事件: window.onscroll\n      获得页面滚动位置: document.body.scrollTop\n          页面超出文档显示区顶部的距离\n</code></pre>"},{"title":"css3笔记","date":"2016-07-01T07:38:52.000Z","_content":"# 1、复杂选择器 \n\n# 1、兄弟选择器 \n       通过兄弟级别的位置关系来匹配页面元素\n        注意，兄弟选择器，只能向后找，不能向前找\n        语法：\n            相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素\n            选择器1+选择器2\n            如：div+p   #top+.important\n                    通用兄弟选择器：用于匹配某元素后面所有的兄弟元素\n            选择器1~选择器2\n                如#d1~div\n# 2、属性选择器\n    通过元素所附带的属性及其值来匹配页面中的元素\n    语法：\n        基础属性选择器  [attr]\n            匹配页面中的有附带attr属性的元素\n        elem[attr]\n            elem:表示任意元素名称\n            attr:表示任意属性名称\n            匹配页面中附带attr属性的elem元素\n            如：div[id]:匹配页面中所有附带id属性的div元素\n        [attr1][attr2][attr3]\n            匹配页面中同时附带attr1和attr2属性的所有元素\n            如 input[name][hype]\n        [attr=value]\n            匹配页面中所有attr属性的值为value的元素\n            如input[type=text]\n        [class~=value]\n            主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素\n        [attr^=value]\n            匹配以value值作为开始的attr属性的元素\n        [attr$=value]\n            匹配以value值作为结束的attr属性的元素\n        [attr*=value]\n            匹配attr属性值中包含value字符的所有元素\n# 3、伪类选择器\n    目标伪类\n        突出显示活动的HTML锚元素\n        语法： ：target\n    结构伪类\n        通过元素之间的结构关系来匹配元素\n        ：first-child     获取属于其父元素中的首个子元素\n        ：last-child     获取属于其父元素中的尾（最后）子元素\n        :nth-child(N)  获取属于其父元素中的第N个子元素\n        ：empty   空的，匹配没有子元素的元素，包含文本\n        ：only-child   匹配属于其父元素中的唯一子元素\n    否定伪类\n        把匹配某选择器元素排除出去\n        ：not(选择器 )\n# 4、伪元素选择器\n    伪类与伪元素\n        伪类：匹配元素不同的状态\n        伪元素：是匹配元素中的内容\n    语法：\n        ：first-letter\n        ::first-letter  匹配某元素的首字符\n        ：first-line    匹配某元素的首行字符\n        ：：selection 匹配用户选取的内容部分\n    ：和：：区别\n        在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示\n        在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示\n# 2、内容生成\n    通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容\n    伪元素选择器\n        ：before   定位到元素内容区域之前\n        ：after    定位到元素内容区域之后\n    语法：\n        属性：content\n        取值：普通文本\n             图像，url(...)\n             计数器\n    问题处理：\n        外边距溢出问题\n            为父元素添加边框\n            使用父元素的内边距取代子元素的外边距\n            在父元素的第一个或最后一个子元素位置处增加一个空的table\n        浮动元素父元素的高度问题\n# 3、弹性布局\n    flexible box,可伸缩布局，为普通布局带来更大的灵活性\n    基本概念‘\n        flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放\n        flex项目：简称项目，存放在flex容器中的内容\n    \n    语法：\n        容器：display\n            取值：flex 将块级元素变为flex容器\n                  inline-flex  将行内元素变为flex容器\n            注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用\n        容器属性;\n            该组属性要添加在容器元素上，控制子元素的位置\n            flex-direction  决定主轴的方向（main-axsis）\n                取值：\n                    row  主轴为水平方向的轴，起点在容器左端，默认值\n                    row-reverse 主轴为水平方向的轴，起点在容器右端\n                    column  主轴为交叉轴，起点在容器的顶端\n                    column-reverse 主轴为交叉轴，起点在容器的底端\n            flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行\n                取值：\n                    nowrap     默认值，不换行\n                    wrap        换行\n                    wrap-reverse  反方向换行\n            flex-flow   dirextion和wrap的缩写方式\n                取值：\n                    row nowrap 默认值\n                    direction wrap\n            justify-content   定义项目在主轴上的对齐方式\n                取值：\n                    flex-start   主轴起点对齐\n                    flex-end   主轴终点对齐\n                    center    居中对齐\n                    space-between  两端对齐，项目之间的距离是相等的\n                    space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍\n            align-items  定义项目在交叉轴的对齐方式（单行项目有效）\n                取值：\n                    flex-start  交叉轴起点对齐\n                    flex-end   交叉轴终点对齐\n                    center     交叉轴中间对齐\n                    baseline   基线对齐，以所有项目中的第一行文本为准\n                    stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度\n            align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效\n                取值：\n                    flex-start   交叉轴顶端对齐\n                    flex-end    交叉轴底端对齐\n                    center      交叉轴中间对齐\n                    space-between  与交叉轴两端对齐\n                    space-around     项目与项目间对齐\n        项目属性：\n            该组属性主要设置于项目中\n            order  定义项目在排列顺序，值越小，越靠前，默认为0\n            flex-grow  指定项目的放大比例，默认为0，即不放大\n            flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小\n            flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小\n            flex  是flex-grow,flex-shrink,flex-basis 的简写模式\n                取值，auto  相当于1  1   auto\n                     none  相当于0 0  auto\n                     flex-grow【,flex-shrink,flex-basis】\n            align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果\n                取值： auto 默认值，使用\n                      flex-start   主轴起点对齐\n                    flex-end   主轴终点对齐\n                    center    居中对齐\n                    base-line\n                    stretch\n# 4、CSS Hack 兼容性\n    标准模式和混杂模式和准标准模式\n    IE6之前，没有兼容性说法\n    IE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式\n        混杂模式  无标准可言\n            编写代码时，不写<!doctylpe>就是混杂模式，采用的是IE5.5的内核进行渲染\n        标准模式  安全支持\n        准标准模式，即支持标准，也同时向前兼容非标准代码\n    如何根据不同的浏览器编写不同的css\n        css类内部Hack\n            在属性名称前和值添加前后缀以便识别不同的浏览器\n        选择器Hack\n            在选择器前添加特殊标识以便识别不同的浏览器\n        头部引用hack\n            通过html的条件注释来判断浏览器版本，去执行不同的CSS\n            条件注释\n                条件：\n                    gt:判断当前浏览器是否大于指定定版本\n                    gte：判断当前浏览器是否大于等于指定定版本\n                    it:   判断当前浏览器是否小于指定版本\n                    ite： 判断当前浏览器是否小于等于指定版本\n                    !：   判断当前浏览器是否为非指定版本\n                        <!--[if !IE 8]>\n                            该段内容在除IE8以外浏览器中显示\n                        <![endif]-->\n# 5、转换\n    \n    说明：改变元素在页面中的形状，角度 大小 位置的一种效果\n        允许进行2D和3D方向的转换\n        2D转换：在平面中进行的操作\n        3D转换：在空间中进行的操作\n    转换属性：\n        rtansform:为元素应用2D或3D转换效果\n            取值：none;  没有效果\n                transform-functions:一组转换函数\n                    位移转换函数：translate()\n                    改变形状函数：skew()\n                    注意：如果指定多个转换函数的话中间用空格隔开\n        转换原点：\n            属性：transform-origin\n            默认：转换原点在元素中心处\n            取值：轴线给值\n                两个轴线值：X Y\n                三个轴线值：X Y Z\n    2D转换\n        位移：改变元素在页面中的位置\n            语法：transform\n                fransform(x)  改变元素在X轴的位置\n                fransform(X ,Y)  改变元素在两轴的位置\n                fransformX(X) 只在X轴上位置移动\n                fransformY(Y)  只在Y轴上位置移动\n        缩放： 改变元素在页面中的大小】\n            语法：transform\n                scale(value)  表示两轴等比缩放\n                    取值：默认  为1\n                        放大   为大于1的数值\n                        缩小   为0~1之间小数\n                        返转   负数\n                sacle(X,Y)\n                saclex(y)\n                sacley(y)\n        旋转：改变元素在页面上的角度，要根据原点实现转换效果\n            语法：transform\n                rotate(ndeg)\n                    n 取值正，顺时针旋转\n                    n 取值负，逆时针旋转\n                    deg 为角度\n                    0~360范围\n            注意：转换原点问题\n                元素坐标轴也跟着旋转\n        倾斜：改变元素在页面中形状\n            语法：transform\n                skew(xdeg)  横向倾斜指定度数\n                    x 取值正，y轴逆时针倾斜一定角度\n                      取值负，Y轴顺时针倾斜一定角度\n                skew(xdeg,ydeg)\n                skewx(xdeg)\n                skewy(ydeg)\n    3D转换\n        感觉空间\n        属性：perspetive 假定人眼到投射平面的距离\n        注意：该属性要放在3D转换元素的父元素上\n            兼容性chrome和safari需要加前缀\n                -wedkit-perspective:500px;\n        旋转：以X轴中心轴旋转\n                rotatex(xdeg)\n              以Y轴中心轴旋转\n                rotatey(ydeg)\n              以Z轴中心轴旋转\n                rotatez(zdeg)\n            取值：正  顺时针\n                负   逆时针\n            以多个轴同时进行旋转\n                rotate3d(x ,y, z ,ndeg)\n                    x y z 取值为1，该轴参与旋转\n                    x y z  取值为0 ，该轴不参与旋转\n        位移：改变元素在Z轴上的位置\n            语法：transform\n                translatez(z)\n    \n                transform-style\n                    取值：flat  默认值，子元素不保留3D位置\n                         preserve-3D  子元素保留3D位置\n# 6、过渡\n\n    作用效果：使得css属性值在一段时间内平缓变化的效果\n    要素与属性：\n        指定过渡属性：指定哪个属性值在变化时使用过渡效果展示\n            transition-property: 属性名称（width）\n                          all   全部属性\n                          none\n            允许设置过渡效果的属性：\n                颜色属性\n                渐变属性\n                取值为数字属性\n                转换属性 transition-property:transform;\n                visibility属性\n                阴影属性\n        指定过渡时长\n            transition-duration: 以S、MS为单位数值\n        指定过渡时速曲线函数  可选\n            transition-timing-function\n                取值：ease  默认值，慢速开始，快速变快，慢速结束\n                     linear  匀速进行\n                     ease-in   慢速开始，快速结束\n                     ease-out  快速开始，慢速结束\n                     ease-in-out  慢速开始和结束，先加速后减速\n        指定过渡的延迟时间   可选\n            transition-delay\n                取值：以S或MS做为单位\n        简写属性：transition:prop duration  timing-fun delay;\n            多个过渡效果\n                transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;\n    触发过渡条件\n        将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,\n        将过渡编写在:hover,:active伪类中\n# 7、动画\n    \n    使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀\n    动画使用步骤\n        声明动画\n            指定动画名称\n            指定动画中的关键帧（keyframes）\n                时间点（以百分比描述时间）\n                元素状态（CSS样式）\n        为元素调用动画\n            指定调用动画的名称以及执行时长\n    语法：\n        声明动画     注意前缀，兼容性问题\n            <style>\n                @keyframes 名称{\n                    0%{   动画开始时，元素的状态   }\n                    。。。。\n                    100%{  动画结束时，元素的状态  }\n                }\n            </style>\n        调用动画(animation)\n            animation-name  指定调用动画名称\n            animation-duration   指定动画周期时长，以S或MS为单位\n            animation-timing-function  指定动画的速度时间出线函数\n                取值：ease  默认值，慢速开始，快速变快，慢速结束\n                     linear  匀速进行\n                     ease-in   慢速开始，快速结束\n                     ease-out  快速开始，慢速结束\n                     ease-in-out  慢速开始和结束，先加速后减速\n            animation-delay  指定动画延迟时间\n            animation-iteration-count  指定动画播放次数\n                取值：默认1次，具体数值\n                    infinite:无限次播放\n            animation-direction  指定动画的播放方向\n                取值：normal  从0%~100%\n                    reverse  从100%~0%\n                    alternate  轮流来回播放 奇数 0%~100%\n                                     偶数 100%~0%\n            animation  简写方式\n                取值：name  duration  timing-fun delay  iteration-count direction;\n            animation-fill-mode  指定动画播放之前、之后的填充模式\n                取值：none  默认值\n                     forwards  动画播放完成后，保持在最后一帧的位置\n                     backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置\n                     both 同时应用在开始和最后的位置帧上\n            animation-play-state  动画播放状态\n                取值：paused 暂停\n                     running 播放\n                     \n                        ","source":"_posts/css3.md","raw":"---\ntitle: css3笔记\ndate: 2016-07-01 15:38:52\ntags:\n---\n# 1、复杂选择器 \n\n# 1、兄弟选择器 \n       通过兄弟级别的位置关系来匹配页面元素\n        注意，兄弟选择器，只能向后找，不能向前找\n        语法：\n            相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素\n            选择器1+选择器2\n            如：div+p   #top+.important\n                    通用兄弟选择器：用于匹配某元素后面所有的兄弟元素\n            选择器1~选择器2\n                如#d1~div\n# 2、属性选择器\n    通过元素所附带的属性及其值来匹配页面中的元素\n    语法：\n        基础属性选择器  [attr]\n            匹配页面中的有附带attr属性的元素\n        elem[attr]\n            elem:表示任意元素名称\n            attr:表示任意属性名称\n            匹配页面中附带attr属性的elem元素\n            如：div[id]:匹配页面中所有附带id属性的div元素\n        [attr1][attr2][attr3]\n            匹配页面中同时附带attr1和attr2属性的所有元素\n            如 input[name][hype]\n        [attr=value]\n            匹配页面中所有attr属性的值为value的元素\n            如input[type=text]\n        [class~=value]\n            主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素\n        [attr^=value]\n            匹配以value值作为开始的attr属性的元素\n        [attr$=value]\n            匹配以value值作为结束的attr属性的元素\n        [attr*=value]\n            匹配attr属性值中包含value字符的所有元素\n# 3、伪类选择器\n    目标伪类\n        突出显示活动的HTML锚元素\n        语法： ：target\n    结构伪类\n        通过元素之间的结构关系来匹配元素\n        ：first-child     获取属于其父元素中的首个子元素\n        ：last-child     获取属于其父元素中的尾（最后）子元素\n        :nth-child(N)  获取属于其父元素中的第N个子元素\n        ：empty   空的，匹配没有子元素的元素，包含文本\n        ：only-child   匹配属于其父元素中的唯一子元素\n    否定伪类\n        把匹配某选择器元素排除出去\n        ：not(选择器 )\n# 4、伪元素选择器\n    伪类与伪元素\n        伪类：匹配元素不同的状态\n        伪元素：是匹配元素中的内容\n    语法：\n        ：first-letter\n        ::first-letter  匹配某元素的首字符\n        ：first-line    匹配某元素的首行字符\n        ：：selection 匹配用户选取的内容部分\n    ：和：：区别\n        在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示\n        在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示\n# 2、内容生成\n    通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容\n    伪元素选择器\n        ：before   定位到元素内容区域之前\n        ：after    定位到元素内容区域之后\n    语法：\n        属性：content\n        取值：普通文本\n             图像，url(...)\n             计数器\n    问题处理：\n        外边距溢出问题\n            为父元素添加边框\n            使用父元素的内边距取代子元素的外边距\n            在父元素的第一个或最后一个子元素位置处增加一个空的table\n        浮动元素父元素的高度问题\n# 3、弹性布局\n    flexible box,可伸缩布局，为普通布局带来更大的灵活性\n    基本概念‘\n        flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放\n        flex项目：简称项目，存放在flex容器中的内容\n    \n    语法：\n        容器：display\n            取值：flex 将块级元素变为flex容器\n                  inline-flex  将行内元素变为flex容器\n            注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用\n        容器属性;\n            该组属性要添加在容器元素上，控制子元素的位置\n            flex-direction  决定主轴的方向（main-axsis）\n                取值：\n                    row  主轴为水平方向的轴，起点在容器左端，默认值\n                    row-reverse 主轴为水平方向的轴，起点在容器右端\n                    column  主轴为交叉轴，起点在容器的顶端\n                    column-reverse 主轴为交叉轴，起点在容器的底端\n            flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行\n                取值：\n                    nowrap     默认值，不换行\n                    wrap        换行\n                    wrap-reverse  反方向换行\n            flex-flow   dirextion和wrap的缩写方式\n                取值：\n                    row nowrap 默认值\n                    direction wrap\n            justify-content   定义项目在主轴上的对齐方式\n                取值：\n                    flex-start   主轴起点对齐\n                    flex-end   主轴终点对齐\n                    center    居中对齐\n                    space-between  两端对齐，项目之间的距离是相等的\n                    space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍\n            align-items  定义项目在交叉轴的对齐方式（单行项目有效）\n                取值：\n                    flex-start  交叉轴起点对齐\n                    flex-end   交叉轴终点对齐\n                    center     交叉轴中间对齐\n                    baseline   基线对齐，以所有项目中的第一行文本为准\n                    stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度\n            align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效\n                取值：\n                    flex-start   交叉轴顶端对齐\n                    flex-end    交叉轴底端对齐\n                    center      交叉轴中间对齐\n                    space-between  与交叉轴两端对齐\n                    space-around     项目与项目间对齐\n        项目属性：\n            该组属性主要设置于项目中\n            order  定义项目在排列顺序，值越小，越靠前，默认为0\n            flex-grow  指定项目的放大比例，默认为0，即不放大\n            flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小\n            flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小\n            flex  是flex-grow,flex-shrink,flex-basis 的简写模式\n                取值，auto  相当于1  1   auto\n                     none  相当于0 0  auto\n                     flex-grow【,flex-shrink,flex-basis】\n            align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果\n                取值： auto 默认值，使用\n                      flex-start   主轴起点对齐\n                    flex-end   主轴终点对齐\n                    center    居中对齐\n                    base-line\n                    stretch\n# 4、CSS Hack 兼容性\n    标准模式和混杂模式和准标准模式\n    IE6之前，没有兼容性说法\n    IE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式\n        混杂模式  无标准可言\n            编写代码时，不写<!doctylpe>就是混杂模式，采用的是IE5.5的内核进行渲染\n        标准模式  安全支持\n        准标准模式，即支持标准，也同时向前兼容非标准代码\n    如何根据不同的浏览器编写不同的css\n        css类内部Hack\n            在属性名称前和值添加前后缀以便识别不同的浏览器\n        选择器Hack\n            在选择器前添加特殊标识以便识别不同的浏览器\n        头部引用hack\n            通过html的条件注释来判断浏览器版本，去执行不同的CSS\n            条件注释\n                条件：\n                    gt:判断当前浏览器是否大于指定定版本\n                    gte：判断当前浏览器是否大于等于指定定版本\n                    it:   判断当前浏览器是否小于指定版本\n                    ite： 判断当前浏览器是否小于等于指定版本\n                    !：   判断当前浏览器是否为非指定版本\n                        <!--[if !IE 8]>\n                            该段内容在除IE8以外浏览器中显示\n                        <![endif]-->\n# 5、转换\n    \n    说明：改变元素在页面中的形状，角度 大小 位置的一种效果\n        允许进行2D和3D方向的转换\n        2D转换：在平面中进行的操作\n        3D转换：在空间中进行的操作\n    转换属性：\n        rtansform:为元素应用2D或3D转换效果\n            取值：none;  没有效果\n                transform-functions:一组转换函数\n                    位移转换函数：translate()\n                    改变形状函数：skew()\n                    注意：如果指定多个转换函数的话中间用空格隔开\n        转换原点：\n            属性：transform-origin\n            默认：转换原点在元素中心处\n            取值：轴线给值\n                两个轴线值：X Y\n                三个轴线值：X Y Z\n    2D转换\n        位移：改变元素在页面中的位置\n            语法：transform\n                fransform(x)  改变元素在X轴的位置\n                fransform(X ,Y)  改变元素在两轴的位置\n                fransformX(X) 只在X轴上位置移动\n                fransformY(Y)  只在Y轴上位置移动\n        缩放： 改变元素在页面中的大小】\n            语法：transform\n                scale(value)  表示两轴等比缩放\n                    取值：默认  为1\n                        放大   为大于1的数值\n                        缩小   为0~1之间小数\n                        返转   负数\n                sacle(X,Y)\n                saclex(y)\n                sacley(y)\n        旋转：改变元素在页面上的角度，要根据原点实现转换效果\n            语法：transform\n                rotate(ndeg)\n                    n 取值正，顺时针旋转\n                    n 取值负，逆时针旋转\n                    deg 为角度\n                    0~360范围\n            注意：转换原点问题\n                元素坐标轴也跟着旋转\n        倾斜：改变元素在页面中形状\n            语法：transform\n                skew(xdeg)  横向倾斜指定度数\n                    x 取值正，y轴逆时针倾斜一定角度\n                      取值负，Y轴顺时针倾斜一定角度\n                skew(xdeg,ydeg)\n                skewx(xdeg)\n                skewy(ydeg)\n    3D转换\n        感觉空间\n        属性：perspetive 假定人眼到投射平面的距离\n        注意：该属性要放在3D转换元素的父元素上\n            兼容性chrome和safari需要加前缀\n                -wedkit-perspective:500px;\n        旋转：以X轴中心轴旋转\n                rotatex(xdeg)\n              以Y轴中心轴旋转\n                rotatey(ydeg)\n              以Z轴中心轴旋转\n                rotatez(zdeg)\n            取值：正  顺时针\n                负   逆时针\n            以多个轴同时进行旋转\n                rotate3d(x ,y, z ,ndeg)\n                    x y z 取值为1，该轴参与旋转\n                    x y z  取值为0 ，该轴不参与旋转\n        位移：改变元素在Z轴上的位置\n            语法：transform\n                translatez(z)\n    \n                transform-style\n                    取值：flat  默认值，子元素不保留3D位置\n                         preserve-3D  子元素保留3D位置\n# 6、过渡\n\n    作用效果：使得css属性值在一段时间内平缓变化的效果\n    要素与属性：\n        指定过渡属性：指定哪个属性值在变化时使用过渡效果展示\n            transition-property: 属性名称（width）\n                          all   全部属性\n                          none\n            允许设置过渡效果的属性：\n                颜色属性\n                渐变属性\n                取值为数字属性\n                转换属性 transition-property:transform;\n                visibility属性\n                阴影属性\n        指定过渡时长\n            transition-duration: 以S、MS为单位数值\n        指定过渡时速曲线函数  可选\n            transition-timing-function\n                取值：ease  默认值，慢速开始，快速变快，慢速结束\n                     linear  匀速进行\n                     ease-in   慢速开始，快速结束\n                     ease-out  快速开始，慢速结束\n                     ease-in-out  慢速开始和结束，先加速后减速\n        指定过渡的延迟时间   可选\n            transition-delay\n                取值：以S或MS做为单位\n        简写属性：transition:prop duration  timing-fun delay;\n            多个过渡效果\n                transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;\n    触发过渡条件\n        将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,\n        将过渡编写在:hover,:active伪类中\n# 7、动画\n    \n    使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀\n    动画使用步骤\n        声明动画\n            指定动画名称\n            指定动画中的关键帧（keyframes）\n                时间点（以百分比描述时间）\n                元素状态（CSS样式）\n        为元素调用动画\n            指定调用动画的名称以及执行时长\n    语法：\n        声明动画     注意前缀，兼容性问题\n            <style>\n                @keyframes 名称{\n                    0%{   动画开始时，元素的状态   }\n                    。。。。\n                    100%{  动画结束时，元素的状态  }\n                }\n            </style>\n        调用动画(animation)\n            animation-name  指定调用动画名称\n            animation-duration   指定动画周期时长，以S或MS为单位\n            animation-timing-function  指定动画的速度时间出线函数\n                取值：ease  默认值，慢速开始，快速变快，慢速结束\n                     linear  匀速进行\n                     ease-in   慢速开始，快速结束\n                     ease-out  快速开始，慢速结束\n                     ease-in-out  慢速开始和结束，先加速后减速\n            animation-delay  指定动画延迟时间\n            animation-iteration-count  指定动画播放次数\n                取值：默认1次，具体数值\n                    infinite:无限次播放\n            animation-direction  指定动画的播放方向\n                取值：normal  从0%~100%\n                    reverse  从100%~0%\n                    alternate  轮流来回播放 奇数 0%~100%\n                                     偶数 100%~0%\n            animation  简写方式\n                取值：name  duration  timing-fun delay  iteration-count direction;\n            animation-fill-mode  指定动画播放之前、之后的填充模式\n                取值：none  默认值\n                     forwards  动画播放完成后，保持在最后一帧的位置\n                     backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置\n                     both 同时应用在开始和最后的位置帧上\n            animation-play-state  动画播放状态\n                取值：paused 暂停\n                     running 播放\n                     \n                        ","slug":"css3","published":1,"updated":"2017-08-12T10:42:07.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsj30003ecvji271w3o9","content":"<h1 id=\"1、复杂选择器\"><a href=\"#1、复杂选择器\" class=\"headerlink\" title=\"1、复杂选择器\"></a>1、复杂选择器</h1><h1 id=\"1、兄弟选择器\"><a href=\"#1、兄弟选择器\" class=\"headerlink\" title=\"1、兄弟选择器\"></a>1、兄弟选择器</h1><pre><code>通过兄弟级别的位置关系来匹配页面元素\n 注意，兄弟选择器，只能向后找，不能向前找\n 语法：\n     相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素\n     选择器1+选择器2\n     如：div+p   #top+.important\n             通用兄弟选择器：用于匹配某元素后面所有的兄弟元素\n     选择器1~选择器2\n         如#d1~div\n</code></pre><h1 id=\"2、属性选择器\"><a href=\"#2、属性选择器\" class=\"headerlink\" title=\"2、属性选择器\"></a>2、属性选择器</h1><pre><code>通过元素所附带的属性及其值来匹配页面中的元素\n语法：\n    基础属性选择器  [attr]\n        匹配页面中的有附带attr属性的元素\n    elem[attr]\n        elem:表示任意元素名称\n        attr:表示任意属性名称\n        匹配页面中附带attr属性的elem元素\n        如：div[id]:匹配页面中所有附带id属性的div元素\n    [attr1][attr2][attr3]\n        匹配页面中同时附带attr1和attr2属性的所有元素\n        如 input[name][hype]\n    [attr=value]\n        匹配页面中所有attr属性的值为value的元素\n        如input[type=text]\n    [class~=value]\n        主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素\n    [attr^=value]\n        匹配以value值作为开始的attr属性的元素\n    [attr$=value]\n        匹配以value值作为结束的attr属性的元素\n    [attr*=value]\n        匹配attr属性值中包含value字符的所有元素\n</code></pre><h1 id=\"3、伪类选择器\"><a href=\"#3、伪类选择器\" class=\"headerlink\" title=\"3、伪类选择器\"></a>3、伪类选择器</h1><pre><code>目标伪类\n    突出显示活动的HTML锚元素\n    语法： ：target\n结构伪类\n    通过元素之间的结构关系来匹配元素\n    ：first-child     获取属于其父元素中的首个子元素\n    ：last-child     获取属于其父元素中的尾（最后）子元素\n    :nth-child(N)  获取属于其父元素中的第N个子元素\n    ：empty   空的，匹配没有子元素的元素，包含文本\n    ：only-child   匹配属于其父元素中的唯一子元素\n否定伪类\n    把匹配某选择器元素排除出去\n    ：not(选择器 )\n</code></pre><h1 id=\"4、伪元素选择器\"><a href=\"#4、伪元素选择器\" class=\"headerlink\" title=\"4、伪元素选择器\"></a>4、伪元素选择器</h1><pre><code>伪类与伪元素\n    伪类：匹配元素不同的状态\n    伪元素：是匹配元素中的内容\n语法：\n    ：first-letter\n    ::first-letter  匹配某元素的首字符\n    ：first-line    匹配某元素的首行字符\n    ：：selection 匹配用户选取的内容部分\n：和：：区别\n    在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示\n    在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示\n</code></pre><h1 id=\"2、内容生成\"><a href=\"#2、内容生成\" class=\"headerlink\" title=\"2、内容生成\"></a>2、内容生成</h1><pre><code>通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容\n伪元素选择器\n    ：before   定位到元素内容区域之前\n    ：after    定位到元素内容区域之后\n语法：\n    属性：content\n    取值：普通文本\n         图像，url(...)\n         计数器\n问题处理：\n    外边距溢出问题\n        为父元素添加边框\n        使用父元素的内边距取代子元素的外边距\n        在父元素的第一个或最后一个子元素位置处增加一个空的table\n    浮动元素父元素的高度问题\n</code></pre><h1 id=\"3、弹性布局\"><a href=\"#3、弹性布局\" class=\"headerlink\" title=\"3、弹性布局\"></a>3、弹性布局</h1><pre><code>flexible box,可伸缩布局，为普通布局带来更大的灵活性\n基本概念‘\n    flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放\n    flex项目：简称项目，存放在flex容器中的内容\n\n语法：\n    容器：display\n        取值：flex 将块级元素变为flex容器\n              inline-flex  将行内元素变为flex容器\n        注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用\n    容器属性;\n        该组属性要添加在容器元素上，控制子元素的位置\n        flex-direction  决定主轴的方向（main-axsis）\n            取值：\n                row  主轴为水平方向的轴，起点在容器左端，默认值\n                row-reverse 主轴为水平方向的轴，起点在容器右端\n                column  主轴为交叉轴，起点在容器的顶端\n                column-reverse 主轴为交叉轴，起点在容器的底端\n        flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行\n            取值：\n                nowrap     默认值，不换行\n                wrap        换行\n                wrap-reverse  反方向换行\n        flex-flow   dirextion和wrap的缩写方式\n            取值：\n                row nowrap 默认值\n                direction wrap\n        justify-content   定义项目在主轴上的对齐方式\n            取值：\n                flex-start   主轴起点对齐\n                flex-end   主轴终点对齐\n                center    居中对齐\n                space-between  两端对齐，项目之间的距离是相等的\n                space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍\n        align-items  定义项目在交叉轴的对齐方式（单行项目有效）\n            取值：\n                flex-start  交叉轴起点对齐\n                flex-end   交叉轴终点对齐\n                center     交叉轴中间对齐\n                baseline   基线对齐，以所有项目中的第一行文本为准\n                stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度\n        align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效\n            取值：\n                flex-start   交叉轴顶端对齐\n                flex-end    交叉轴底端对齐\n                center      交叉轴中间对齐\n                space-between  与交叉轴两端对齐\n                space-around     项目与项目间对齐\n    项目属性：\n        该组属性主要设置于项目中\n        order  定义项目在排列顺序，值越小，越靠前，默认为0\n        flex-grow  指定项目的放大比例，默认为0，即不放大\n        flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小\n        flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小\n        flex  是flex-grow,flex-shrink,flex-basis 的简写模式\n            取值，auto  相当于1  1   auto\n                 none  相当于0 0  auto\n                 flex-grow【,flex-shrink,flex-basis】\n        align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果\n            取值： auto 默认值，使用\n                  flex-start   主轴起点对齐\n                flex-end   主轴终点对齐\n                center    居中对齐\n                base-line\n                stretch\n</code></pre><h1 id=\"4、CSS-Hack-兼容性\"><a href=\"#4、CSS-Hack-兼容性\" class=\"headerlink\" title=\"4、CSS Hack 兼容性\"></a>4、CSS Hack 兼容性</h1><pre><code>标准模式和混杂模式和准标准模式\nIE6之前，没有兼容性说法\nIE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式\n    混杂模式  无标准可言\n        编写代码时，不写&lt;!doctylpe&gt;就是混杂模式，采用的是IE5.5的内核进行渲染\n    标准模式  安全支持\n    准标准模式，即支持标准，也同时向前兼容非标准代码\n如何根据不同的浏览器编写不同的css\n    css类内部Hack\n        在属性名称前和值添加前后缀以便识别不同的浏览器\n    选择器Hack\n        在选择器前添加特殊标识以便识别不同的浏览器\n    头部引用hack\n        通过html的条件注释来判断浏览器版本，去执行不同的CSS\n        条件注释\n            条件：\n                gt:判断当前浏览器是否大于指定定版本\n                gte：判断当前浏览器是否大于等于指定定版本\n                it:   判断当前浏览器是否小于指定版本\n                ite： 判断当前浏览器是否小于等于指定版本\n                !：   判断当前浏览器是否为非指定版本\n                    &lt;!--[if !IE 8]&gt;\n                        该段内容在除IE8以外浏览器中显示\n                    &lt;![endif]--&gt;\n</code></pre><h1 id=\"5、转换\"><a href=\"#5、转换\" class=\"headerlink\" title=\"5、转换\"></a>5、转换</h1><pre><code>说明：改变元素在页面中的形状，角度 大小 位置的一种效果\n    允许进行2D和3D方向的转换\n    2D转换：在平面中进行的操作\n    3D转换：在空间中进行的操作\n转换属性：\n    rtansform:为元素应用2D或3D转换效果\n        取值：none;  没有效果\n            transform-functions:一组转换函数\n                位移转换函数：translate()\n                改变形状函数：skew()\n                注意：如果指定多个转换函数的话中间用空格隔开\n    转换原点：\n        属性：transform-origin\n        默认：转换原点在元素中心处\n        取值：轴线给值\n            两个轴线值：X Y\n            三个轴线值：X Y Z\n2D转换\n    位移：改变元素在页面中的位置\n        语法：transform\n            fransform(x)  改变元素在X轴的位置\n            fransform(X ,Y)  改变元素在两轴的位置\n            fransformX(X) 只在X轴上位置移动\n            fransformY(Y)  只在Y轴上位置移动\n    缩放： 改变元素在页面中的大小】\n        语法：transform\n            scale(value)  表示两轴等比缩放\n                取值：默认  为1\n                    放大   为大于1的数值\n                    缩小   为0~1之间小数\n                    返转   负数\n            sacle(X,Y)\n            saclex(y)\n            sacley(y)\n    旋转：改变元素在页面上的角度，要根据原点实现转换效果\n        语法：transform\n            rotate(ndeg)\n                n 取值正，顺时针旋转\n                n 取值负，逆时针旋转\n                deg 为角度\n                0~360范围\n        注意：转换原点问题\n            元素坐标轴也跟着旋转\n    倾斜：改变元素在页面中形状\n        语法：transform\n            skew(xdeg)  横向倾斜指定度数\n                x 取值正，y轴逆时针倾斜一定角度\n                  取值负，Y轴顺时针倾斜一定角度\n            skew(xdeg,ydeg)\n            skewx(xdeg)\n            skewy(ydeg)\n3D转换\n    感觉空间\n    属性：perspetive 假定人眼到投射平面的距离\n    注意：该属性要放在3D转换元素的父元素上\n        兼容性chrome和safari需要加前缀\n            -wedkit-perspective:500px;\n    旋转：以X轴中心轴旋转\n            rotatex(xdeg)\n          以Y轴中心轴旋转\n            rotatey(ydeg)\n          以Z轴中心轴旋转\n            rotatez(zdeg)\n        取值：正  顺时针\n            负   逆时针\n        以多个轴同时进行旋转\n            rotate3d(x ,y, z ,ndeg)\n                x y z 取值为1，该轴参与旋转\n                x y z  取值为0 ，该轴不参与旋转\n    位移：改变元素在Z轴上的位置\n        语法：transform\n            translatez(z)\n\n            transform-style\n                取值：flat  默认值，子元素不保留3D位置\n                     preserve-3D  子元素保留3D位置\n</code></pre><h1 id=\"6、过渡\"><a href=\"#6、过渡\" class=\"headerlink\" title=\"6、过渡\"></a>6、过渡</h1><pre><code>作用效果：使得css属性值在一段时间内平缓变化的效果\n要素与属性：\n    指定过渡属性：指定哪个属性值在变化时使用过渡效果展示\n        transition-property: 属性名称（width）\n                      all   全部属性\n                      none\n        允许设置过渡效果的属性：\n            颜色属性\n            渐变属性\n            取值为数字属性\n            转换属性 transition-property:transform;\n            visibility属性\n            阴影属性\n    指定过渡时长\n        transition-duration: 以S、MS为单位数值\n    指定过渡时速曲线函数  可选\n        transition-timing-function\n            取值：ease  默认值，慢速开始，快速变快，慢速结束\n                 linear  匀速进行\n                 ease-in   慢速开始，快速结束\n                 ease-out  快速开始，慢速结束\n                 ease-in-out  慢速开始和结束，先加速后减速\n    指定过渡的延迟时间   可选\n        transition-delay\n            取值：以S或MS做为单位\n    简写属性：transition:prop duration  timing-fun delay;\n        多个过渡效果\n            transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;\n触发过渡条件\n    将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,\n    将过渡编写在:hover,:active伪类中\n</code></pre><h1 id=\"7、动画\"><a href=\"#7、动画\" class=\"headerlink\" title=\"7、动画\"></a>7、动画</h1><pre><code>使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀\n动画使用步骤\n    声明动画\n        指定动画名称\n        指定动画中的关键帧（keyframes）\n            时间点（以百分比描述时间）\n            元素状态（CSS样式）\n    为元素调用动画\n        指定调用动画的名称以及执行时长\n语法：\n    声明动画     注意前缀，兼容性问题\n        &lt;style&gt;\n            @keyframes 名称{\n                0%{   动画开始时，元素的状态   }\n                。。。。\n                100%{  动画结束时，元素的状态  }\n            }\n        &lt;/style&gt;\n    调用动画(animation)\n        animation-name  指定调用动画名称\n        animation-duration   指定动画周期时长，以S或MS为单位\n        animation-timing-function  指定动画的速度时间出线函数\n            取值：ease  默认值，慢速开始，快速变快，慢速结束\n                 linear  匀速进行\n                 ease-in   慢速开始，快速结束\n                 ease-out  快速开始，慢速结束\n                 ease-in-out  慢速开始和结束，先加速后减速\n        animation-delay  指定动画延迟时间\n        animation-iteration-count  指定动画播放次数\n            取值：默认1次，具体数值\n                infinite:无限次播放\n        animation-direction  指定动画的播放方向\n            取值：normal  从0%~100%\n                reverse  从100%~0%\n                alternate  轮流来回播放 奇数 0%~100%\n                                 偶数 100%~0%\n        animation  简写方式\n            取值：name  duration  timing-fun delay  iteration-count direction;\n        animation-fill-mode  指定动画播放之前、之后的填充模式\n            取值：none  默认值\n                 forwards  动画播放完成后，保持在最后一帧的位置\n                 backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置\n                 both 同时应用在开始和最后的位置帧上\n        animation-play-state  动画播放状态\n            取值：paused 暂停\n                 running 播放\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、复杂选择器\"><a href=\"#1、复杂选择器\" class=\"headerlink\" title=\"1、复杂选择器\"></a>1、复杂选择器</h1><h1 id=\"1、兄弟选择器\"><a href=\"#1、兄弟选择器\" class=\"headerlink\" title=\"1、兄弟选择器\"></a>1、兄弟选择器</h1><pre><code>通过兄弟级别的位置关系来匹配页面元素\n 注意，兄弟选择器，只能向后找，不能向前找\n 语法：\n     相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素\n     选择器1+选择器2\n     如：div+p   #top+.important\n             通用兄弟选择器：用于匹配某元素后面所有的兄弟元素\n     选择器1~选择器2\n         如#d1~div\n</code></pre><h1 id=\"2、属性选择器\"><a href=\"#2、属性选择器\" class=\"headerlink\" title=\"2、属性选择器\"></a>2、属性选择器</h1><pre><code>通过元素所附带的属性及其值来匹配页面中的元素\n语法：\n    基础属性选择器  [attr]\n        匹配页面中的有附带attr属性的元素\n    elem[attr]\n        elem:表示任意元素名称\n        attr:表示任意属性名称\n        匹配页面中附带attr属性的elem元素\n        如：div[id]:匹配页面中所有附带id属性的div元素\n    [attr1][attr2][attr3]\n        匹配页面中同时附带attr1和attr2属性的所有元素\n        如 input[name][hype]\n    [attr=value]\n        匹配页面中所有attr属性的值为value的元素\n        如input[type=text]\n    [class~=value]\n        主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素\n    [attr^=value]\n        匹配以value值作为开始的attr属性的元素\n    [attr$=value]\n        匹配以value值作为结束的attr属性的元素\n    [attr*=value]\n        匹配attr属性值中包含value字符的所有元素\n</code></pre><h1 id=\"3、伪类选择器\"><a href=\"#3、伪类选择器\" class=\"headerlink\" title=\"3、伪类选择器\"></a>3、伪类选择器</h1><pre><code>目标伪类\n    突出显示活动的HTML锚元素\n    语法： ：target\n结构伪类\n    通过元素之间的结构关系来匹配元素\n    ：first-child     获取属于其父元素中的首个子元素\n    ：last-child     获取属于其父元素中的尾（最后）子元素\n    :nth-child(N)  获取属于其父元素中的第N个子元素\n    ：empty   空的，匹配没有子元素的元素，包含文本\n    ：only-child   匹配属于其父元素中的唯一子元素\n否定伪类\n    把匹配某选择器元素排除出去\n    ：not(选择器 )\n</code></pre><h1 id=\"4、伪元素选择器\"><a href=\"#4、伪元素选择器\" class=\"headerlink\" title=\"4、伪元素选择器\"></a>4、伪元素选择器</h1><pre><code>伪类与伪元素\n    伪类：匹配元素不同的状态\n    伪元素：是匹配元素中的内容\n语法：\n    ：first-letter\n    ::first-letter  匹配某元素的首字符\n    ：first-line    匹配某元素的首行字符\n    ：：selection 匹配用户选取的内容部分\n：和：：区别\n    在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示\n    在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示\n</code></pre><h1 id=\"2、内容生成\"><a href=\"#2、内容生成\" class=\"headerlink\" title=\"2、内容生成\"></a>2、内容生成</h1><pre><code>通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容\n伪元素选择器\n    ：before   定位到元素内容区域之前\n    ：after    定位到元素内容区域之后\n语法：\n    属性：content\n    取值：普通文本\n         图像，url(...)\n         计数器\n问题处理：\n    外边距溢出问题\n        为父元素添加边框\n        使用父元素的内边距取代子元素的外边距\n        在父元素的第一个或最后一个子元素位置处增加一个空的table\n    浮动元素父元素的高度问题\n</code></pre><h1 id=\"3、弹性布局\"><a href=\"#3、弹性布局\" class=\"headerlink\" title=\"3、弹性布局\"></a>3、弹性布局</h1><pre><code>flexible box,可伸缩布局，为普通布局带来更大的灵活性\n基本概念‘\n    flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放\n    flex项目：简称项目，存放在flex容器中的内容\n\n语法：\n    容器：display\n        取值：flex 将块级元素变为flex容器\n              inline-flex  将行内元素变为flex容器\n        注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用\n    容器属性;\n        该组属性要添加在容器元素上，控制子元素的位置\n        flex-direction  决定主轴的方向（main-axsis）\n            取值：\n                row  主轴为水平方向的轴，起点在容器左端，默认值\n                row-reverse 主轴为水平方向的轴，起点在容器右端\n                column  主轴为交叉轴，起点在容器的顶端\n                column-reverse 主轴为交叉轴，起点在容器的底端\n        flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行\n            取值：\n                nowrap     默认值，不换行\n                wrap        换行\n                wrap-reverse  反方向换行\n        flex-flow   dirextion和wrap的缩写方式\n            取值：\n                row nowrap 默认值\n                direction wrap\n        justify-content   定义项目在主轴上的对齐方式\n            取值：\n                flex-start   主轴起点对齐\n                flex-end   主轴终点对齐\n                center    居中对齐\n                space-between  两端对齐，项目之间的距离是相等的\n                space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍\n        align-items  定义项目在交叉轴的对齐方式（单行项目有效）\n            取值：\n                flex-start  交叉轴起点对齐\n                flex-end   交叉轴终点对齐\n                center     交叉轴中间对齐\n                baseline   基线对齐，以所有项目中的第一行文本为准\n                stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度\n        align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效\n            取值：\n                flex-start   交叉轴顶端对齐\n                flex-end    交叉轴底端对齐\n                center      交叉轴中间对齐\n                space-between  与交叉轴两端对齐\n                space-around     项目与项目间对齐\n    项目属性：\n        该组属性主要设置于项目中\n        order  定义项目在排列顺序，值越小，越靠前，默认为0\n        flex-grow  指定项目的放大比例，默认为0，即不放大\n        flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小\n        flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小\n        flex  是flex-grow,flex-shrink,flex-basis 的简写模式\n            取值，auto  相当于1  1   auto\n                 none  相当于0 0  auto\n                 flex-grow【,flex-shrink,flex-basis】\n        align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果\n            取值： auto 默认值，使用\n                  flex-start   主轴起点对齐\n                flex-end   主轴终点对齐\n                center    居中对齐\n                base-line\n                stretch\n</code></pre><h1 id=\"4、CSS-Hack-兼容性\"><a href=\"#4、CSS-Hack-兼容性\" class=\"headerlink\" title=\"4、CSS Hack 兼容性\"></a>4、CSS Hack 兼容性</h1><pre><code>标准模式和混杂模式和准标准模式\nIE6之前，没有兼容性说法\nIE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式\n    混杂模式  无标准可言\n        编写代码时，不写&lt;!doctylpe&gt;就是混杂模式，采用的是IE5.5的内核进行渲染\n    标准模式  安全支持\n    准标准模式，即支持标准，也同时向前兼容非标准代码\n如何根据不同的浏览器编写不同的css\n    css类内部Hack\n        在属性名称前和值添加前后缀以便识别不同的浏览器\n    选择器Hack\n        在选择器前添加特殊标识以便识别不同的浏览器\n    头部引用hack\n        通过html的条件注释来判断浏览器版本，去执行不同的CSS\n        条件注释\n            条件：\n                gt:判断当前浏览器是否大于指定定版本\n                gte：判断当前浏览器是否大于等于指定定版本\n                it:   判断当前浏览器是否小于指定版本\n                ite： 判断当前浏览器是否小于等于指定版本\n                !：   判断当前浏览器是否为非指定版本\n                    &lt;!--[if !IE 8]&gt;\n                        该段内容在除IE8以外浏览器中显示\n                    &lt;![endif]--&gt;\n</code></pre><h1 id=\"5、转换\"><a href=\"#5、转换\" class=\"headerlink\" title=\"5、转换\"></a>5、转换</h1><pre><code>说明：改变元素在页面中的形状，角度 大小 位置的一种效果\n    允许进行2D和3D方向的转换\n    2D转换：在平面中进行的操作\n    3D转换：在空间中进行的操作\n转换属性：\n    rtansform:为元素应用2D或3D转换效果\n        取值：none;  没有效果\n            transform-functions:一组转换函数\n                位移转换函数：translate()\n                改变形状函数：skew()\n                注意：如果指定多个转换函数的话中间用空格隔开\n    转换原点：\n        属性：transform-origin\n        默认：转换原点在元素中心处\n        取值：轴线给值\n            两个轴线值：X Y\n            三个轴线值：X Y Z\n2D转换\n    位移：改变元素在页面中的位置\n        语法：transform\n            fransform(x)  改变元素在X轴的位置\n            fransform(X ,Y)  改变元素在两轴的位置\n            fransformX(X) 只在X轴上位置移动\n            fransformY(Y)  只在Y轴上位置移动\n    缩放： 改变元素在页面中的大小】\n        语法：transform\n            scale(value)  表示两轴等比缩放\n                取值：默认  为1\n                    放大   为大于1的数值\n                    缩小   为0~1之间小数\n                    返转   负数\n            sacle(X,Y)\n            saclex(y)\n            sacley(y)\n    旋转：改变元素在页面上的角度，要根据原点实现转换效果\n        语法：transform\n            rotate(ndeg)\n                n 取值正，顺时针旋转\n                n 取值负，逆时针旋转\n                deg 为角度\n                0~360范围\n        注意：转换原点问题\n            元素坐标轴也跟着旋转\n    倾斜：改变元素在页面中形状\n        语法：transform\n            skew(xdeg)  横向倾斜指定度数\n                x 取值正，y轴逆时针倾斜一定角度\n                  取值负，Y轴顺时针倾斜一定角度\n            skew(xdeg,ydeg)\n            skewx(xdeg)\n            skewy(ydeg)\n3D转换\n    感觉空间\n    属性：perspetive 假定人眼到投射平面的距离\n    注意：该属性要放在3D转换元素的父元素上\n        兼容性chrome和safari需要加前缀\n            -wedkit-perspective:500px;\n    旋转：以X轴中心轴旋转\n            rotatex(xdeg)\n          以Y轴中心轴旋转\n            rotatey(ydeg)\n          以Z轴中心轴旋转\n            rotatez(zdeg)\n        取值：正  顺时针\n            负   逆时针\n        以多个轴同时进行旋转\n            rotate3d(x ,y, z ,ndeg)\n                x y z 取值为1，该轴参与旋转\n                x y z  取值为0 ，该轴不参与旋转\n    位移：改变元素在Z轴上的位置\n        语法：transform\n            translatez(z)\n\n            transform-style\n                取值：flat  默认值，子元素不保留3D位置\n                     preserve-3D  子元素保留3D位置\n</code></pre><h1 id=\"6、过渡\"><a href=\"#6、过渡\" class=\"headerlink\" title=\"6、过渡\"></a>6、过渡</h1><pre><code>作用效果：使得css属性值在一段时间内平缓变化的效果\n要素与属性：\n    指定过渡属性：指定哪个属性值在变化时使用过渡效果展示\n        transition-property: 属性名称（width）\n                      all   全部属性\n                      none\n        允许设置过渡效果的属性：\n            颜色属性\n            渐变属性\n            取值为数字属性\n            转换属性 transition-property:transform;\n            visibility属性\n            阴影属性\n    指定过渡时长\n        transition-duration: 以S、MS为单位数值\n    指定过渡时速曲线函数  可选\n        transition-timing-function\n            取值：ease  默认值，慢速开始，快速变快，慢速结束\n                 linear  匀速进行\n                 ease-in   慢速开始，快速结束\n                 ease-out  快速开始，慢速结束\n                 ease-in-out  慢速开始和结束，先加速后减速\n    指定过渡的延迟时间   可选\n        transition-delay\n            取值：以S或MS做为单位\n    简写属性：transition:prop duration  timing-fun delay;\n        多个过渡效果\n            transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;\n触发过渡条件\n    将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,\n    将过渡编写在:hover,:active伪类中\n</code></pre><h1 id=\"7、动画\"><a href=\"#7、动画\" class=\"headerlink\" title=\"7、动画\"></a>7、动画</h1><pre><code>使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀\n动画使用步骤\n    声明动画\n        指定动画名称\n        指定动画中的关键帧（keyframes）\n            时间点（以百分比描述时间）\n            元素状态（CSS样式）\n    为元素调用动画\n        指定调用动画的名称以及执行时长\n语法：\n    声明动画     注意前缀，兼容性问题\n        &lt;style&gt;\n            @keyframes 名称{\n                0%{   动画开始时，元素的状态   }\n                。。。。\n                100%{  动画结束时，元素的状态  }\n            }\n        &lt;/style&gt;\n    调用动画(animation)\n        animation-name  指定调用动画名称\n        animation-duration   指定动画周期时长，以S或MS为单位\n        animation-timing-function  指定动画的速度时间出线函数\n            取值：ease  默认值，慢速开始，快速变快，慢速结束\n                 linear  匀速进行\n                 ease-in   慢速开始，快速结束\n                 ease-out  快速开始，慢速结束\n                 ease-in-out  慢速开始和结束，先加速后减速\n        animation-delay  指定动画延迟时间\n        animation-iteration-count  指定动画播放次数\n            取值：默认1次，具体数值\n                infinite:无限次播放\n        animation-direction  指定动画的播放方向\n            取值：normal  从0%~100%\n                reverse  从100%~0%\n                alternate  轮流来回播放 奇数 0%~100%\n                                 偶数 100%~0%\n        animation  简写方式\n            取值：name  duration  timing-fun delay  iteration-count direction;\n        animation-fill-mode  指定动画播放之前、之后的填充模式\n            取值：none  默认值\n                 forwards  动画播放完成后，保持在最后一帧的位置\n                 backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置\n                 both 同时应用在开始和最后的位置帧上\n        animation-play-state  动画播放状态\n            取值：paused 暂停\n                 running 播放\n</code></pre>"},{"title":"搭建hexo博客","date":"2016-06-05T01:32:32.000Z","_content":"\n# 一、关于搭建的流程\n\n1. 创建仓库，http://liyuezhang.github.io；\n2. 创建两个分支：master 与 hexo；\n3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n4. 使用git clone git@github.com/liyuezhang/liyuezhang.github.io.git拷贝仓库；\n5. 在本地http://liyuezhang.github.io文件夹下通过Git bash依次执行npm install hexo、\nhexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n6. 修改_config.yml中的deploy参数，分支应为master；\n7. 依次执行git add .、git commit -m \"...\"、git push origin hexo提交网站相关的文件；\n8. 执行hexo g -d生成网站并部署到GitHub上。\n这样一来，在GitHub上的http://liyuezhang.github.io仓库就有两个分支，\n一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！\n\n\n# 二、关于日常的改动流程在本地对博客进行修改\n（添加新博文、修改样式等等）后，通过下面的流程进行管理。\n1. 依次执行git add .、git commit -m \"...\"、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；\n2. 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催....的情况，调转顺序就有问题了）。\n\n\n# 三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\n1. 使用git clone git@github.com/liyuezhang/liyuezhang.github.io.git拷贝仓库（默认分支为hexo）；\n2. 在本地新拷贝的http://liyuezhang.github.io文件夹下通过Git bash依次执行下列指令：\nnpm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。","source":"_posts/dajian.md","raw":"---\ntitle: 搭建hexo博客\ndate: 2016-06-05 09:32:32\ntags:\n---\n\n# 一、关于搭建的流程\n\n1. 创建仓库，http://liyuezhang.github.io；\n2. 创建两个分支：master 与 hexo；\n3. 设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；\n4. 使用git clone git@github.com/liyuezhang/liyuezhang.github.io.git拷贝仓库；\n5. 在本地http://liyuezhang.github.io文件夹下通过Git bash依次执行npm install hexo、\nhexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;\n6. 修改_config.yml中的deploy参数，分支应为master；\n7. 依次执行git add .、git commit -m \"...\"、git push origin hexo提交网站相关的文件；\n8. 执行hexo g -d生成网站并部署到GitHub上。\n这样一来，在GitHub上的http://liyuezhang.github.io仓库就有两个分支，\n一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！\n\n\n# 二、关于日常的改动流程在本地对博客进行修改\n（添加新博文、修改样式等等）后，通过下面的流程进行管理。\n1. 依次执行git add .、git commit -m \"...\"、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；\n2. 然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催....的情况，调转顺序就有问题了）。\n\n\n# 三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\n1. 使用git clone git@github.com/liyuezhang/liyuezhang.github.io.git拷贝仓库（默认分支为hexo）；\n2. 在本地新拷贝的http://liyuezhang.github.io文件夹下通过Git bash依次执行下列指令：\nnpm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。","slug":"dajian","published":1,"updated":"2017-08-13T13:49:06.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsj50004ecvje1ep4hht","content":"<h1 id=\"一、关于搭建的流程\"><a href=\"#一、关于搭建的流程\" class=\"headerlink\" title=\"一、关于搭建的流程\"></a>一、关于搭建的流程</h1><ol>\n<li>创建仓库，<a href=\"http://liyuezhang.github.io；\" target=\"_blank\" rel=\"external\">http://liyuezhang.github.io；</a></li>\n<li>创建两个分支：master 与 hexo；</li>\n<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</li>\n<li>使用git clone git@github.com/liyuezhang/liyuezhang.github.io.git拷贝仓库；</li>\n<li>在本地<a href=\"http://liyuezhang.github.io文件夹下通过Git\" target=\"_blank\" rel=\"external\">http://liyuezhang.github.io文件夹下通过Git</a> bash依次执行npm install hexo、<br>hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</li>\n<li>修改_config.yml中的deploy参数，分支应为master；</li>\n<li>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</li>\n<li>执行hexo g -d生成网站并部署到GitHub上。<br>这样一来，在GitHub上的<a href=\"http://liyuezhang.github.io仓库就有两个分支，\" target=\"_blank\" rel=\"external\">http://liyuezhang.github.io仓库就有两个分支，</a><br>一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！</li>\n</ol>\n<h1 id=\"二、关于日常的改动流程在本地对博客进行修改\"><a href=\"#二、关于日常的改动流程在本地对博客进行修改\" class=\"headerlink\" title=\"二、关于日常的改动流程在本地对博客进行修改\"></a>二、关于日常的改动流程在本地对博客进行修改</h1><p>（添加新博文、修改样式等等）后，通过下面的流程进行管理。</p>\n<ol>\n<li>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；</li>\n<li>然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</li>\n</ol>\n<h1 id=\"三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\"><a href=\"#三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\" class=\"headerlink\" title=\"三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\"></a>三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</h1><ol>\n<li>使用git clone git@github.com/liyuezhang/liyuezhang.github.io.git拷贝仓库（默认分支为hexo）；</li>\n<li>在本地新拷贝的<a href=\"http://liyuezhang.github.io文件夹下通过Git\" target=\"_blank\" rel=\"external\">http://liyuezhang.github.io文件夹下通过Git</a> bash依次执行下列指令：<br>npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、关于搭建的流程\"><a href=\"#一、关于搭建的流程\" class=\"headerlink\" title=\"一、关于搭建的流程\"></a>一、关于搭建的流程</h1><ol>\n<li>创建仓库，<a href=\"http://liyuezhang.github.io；\" target=\"_blank\" rel=\"external\">http://liyuezhang.github.io；</a></li>\n<li>创建两个分支：master 与 hexo；</li>\n<li>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）；</li>\n<li>使用git clone git@github.com/liyuezhang/liyuezhang.github.io.git拷贝仓库；</li>\n<li>在本地<a href=\"http://liyuezhang.github.io文件夹下通过Git\" target=\"_blank\" rel=\"external\">http://liyuezhang.github.io文件夹下通过Git</a> bash依次执行npm install hexo、<br>hexo init、npm install 和 npm install hexo-deployer-git（此时当前分支应显示为hexo）;</li>\n<li>修改_config.yml中的deploy参数，分支应为master；</li>\n<li>依次执行git add .、git commit -m “…”、git push origin hexo提交网站相关的文件；</li>\n<li>执行hexo g -d生成网站并部署到GitHub上。<br>这样一来，在GitHub上的<a href=\"http://liyuezhang.github.io仓库就有两个分支，\" target=\"_blank\" rel=\"external\">http://liyuezhang.github.io仓库就有两个分支，</a><br>一个hexo分支用来存放网站的原始文件，一个master分支用来存放生成的静态网页。完美( •̀ ω •́ )y！</li>\n</ol>\n<h1 id=\"二、关于日常的改动流程在本地对博客进行修改\"><a href=\"#二、关于日常的改动流程在本地对博客进行修改\" class=\"headerlink\" title=\"二、关于日常的改动流程在本地对博客进行修改\"></a>二、关于日常的改动流程在本地对博客进行修改</h1><p>（添加新博文、修改样式等等）后，通过下面的流程进行管理。</p>\n<ol>\n<li>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；</li>\n<li>然后才执行hexo g -d发布网站到master分支上。虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</li>\n</ol>\n<h1 id=\"三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\"><a href=\"#三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\" class=\"headerlink\" title=\"三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：\"></a>三、本地资料丢失后的流程当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</h1><ol>\n<li>使用git clone git@github.com/liyuezhang/liyuezhang.github.io.git拷贝仓库（默认分支为hexo）；</li>\n<li>在本地新拷贝的<a href=\"http://liyuezhang.github.io文件夹下通过Git\" target=\"_blank\" rel=\"external\">http://liyuezhang.github.io文件夹下通过Git</a> bash依次执行下列指令：<br>npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</li>\n</ol>\n"},{"title":"git常用命令","date":"2016-06-15T12:54:34.000Z","_content":"# 使用方法\n\n安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息：\n\ngit  config  --global   user.name   \"name\"\ngit  config  --global   user.email   \"email@qq.com\"\n# 指令说明\n\ngit  status               查看工作区所有文件状态\ngit  add  1.jpg          把指定文件添加到暂存区\ngit  add  *.jpg          把指定后缀名的文件添加到暂存区\ngit  add  *              把所有文件添加到暂存区\ngit  add  .              把所有文件添加到暂存区\ngit  commit  -m  \"消息内容\"   把暂存区的修改提交给仓库\ngit  log                 查看仓库中所有的提交记录\n\ngit  reset  --hard  版本号     工作区回退到指定的版本\ngit  log       查看当前已经生效的所有版本号\ngit  reflog     查看当前已经生效&撤销生效的所有版本号\n# 远程仓库相关\n\ngit  clone  远程仓库的地址\ngit  clone  git@github.com:jquery/jquery.git\ngit  clone  https://github.com/jquery/jquery.git\n# 创建关联使用方法\n\ngit  init           本地创建一个空白仓库\ngit  remote       查看当前仓库关联到哪些远程仓库\ngit  remote  add  关联仓库名  远程仓库的地址\ngit  pull  关联仓库名  master    从远程仓库“拉取(pull)”已有的文件和版本信息到本地仓库\ngit  add  .        修改本地仓库中的文件，添加到本地暂存区，提交给本地的仓库\ngit  commit   -m   \"说明信息\"\ngit  push  远程仓库名  master    把本地仓库中的新的版本信息“推送(push)”给远程仓库\n\ngit subtree push --prefix=dist origin gh-pages  建立分支结构","source":"_posts/git.md","raw":"---\ntitle: git常用命令\ndate: 2016-06-15 20:54:34\ntags:\n---\n# 使用方法\n\n安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息：\n\ngit  config  --global   user.name   \"name\"\ngit  config  --global   user.email   \"email@qq.com\"\n# 指令说明\n\ngit  status               查看工作区所有文件状态\ngit  add  1.jpg          把指定文件添加到暂存区\ngit  add  *.jpg          把指定后缀名的文件添加到暂存区\ngit  add  *              把所有文件添加到暂存区\ngit  add  .              把所有文件添加到暂存区\ngit  commit  -m  \"消息内容\"   把暂存区的修改提交给仓库\ngit  log                 查看仓库中所有的提交记录\n\ngit  reset  --hard  版本号     工作区回退到指定的版本\ngit  log       查看当前已经生效的所有版本号\ngit  reflog     查看当前已经生效&撤销生效的所有版本号\n# 远程仓库相关\n\ngit  clone  远程仓库的地址\ngit  clone  git@github.com:jquery/jquery.git\ngit  clone  https://github.com/jquery/jquery.git\n# 创建关联使用方法\n\ngit  init           本地创建一个空白仓库\ngit  remote       查看当前仓库关联到哪些远程仓库\ngit  remote  add  关联仓库名  远程仓库的地址\ngit  pull  关联仓库名  master    从远程仓库“拉取(pull)”已有的文件和版本信息到本地仓库\ngit  add  .        修改本地仓库中的文件，添加到本地暂存区，提交给本地的仓库\ngit  commit   -m   \"说明信息\"\ngit  push  远程仓库名  master    把本地仓库中的新的版本信息“推送(push)”给远程仓库\n\ngit subtree push --prefix=dist origin gh-pages  建立分支结构","slug":"git","published":1,"updated":"2017-08-13T14:23:38.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsj60005ecvjmgb2fi15","content":"<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><p>安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息：</p>\n<p>git  config  –global   user.name   “name”<br>git  config  –global   user.email   “email@qq.com”</p>\n<h1 id=\"指令说明\"><a href=\"#指令说明\" class=\"headerlink\" title=\"指令说明\"></a>指令说明</h1><p>git  status               查看工作区所有文件状态<br>git  add  1.jpg          把指定文件添加到暂存区<br>git  add  <em>.jpg          把指定后缀名的文件添加到暂存区<br>git  add  </em>              把所有文件添加到暂存区<br>git  add  .              把所有文件添加到暂存区<br>git  commit  -m  “消息内容”   把暂存区的修改提交给仓库<br>git  log                 查看仓库中所有的提交记录</p>\n<p>git  reset  –hard  版本号     工作区回退到指定的版本<br>git  log       查看当前已经生效的所有版本号<br>git  reflog     查看当前已经生效&amp;撤销生效的所有版本号</p>\n<h1 id=\"远程仓库相关\"><a href=\"#远程仓库相关\" class=\"headerlink\" title=\"远程仓库相关\"></a>远程仓库相关</h1><p>git  clone  远程仓库的地址<br>git  clone  git@github.com:jquery/jquery.git<br>git  clone  <a href=\"https://github.com/jquery/jquery.git\" target=\"_blank\" rel=\"external\">https://github.com/jquery/jquery.git</a></p>\n<h1 id=\"创建关联使用方法\"><a href=\"#创建关联使用方法\" class=\"headerlink\" title=\"创建关联使用方法\"></a>创建关联使用方法</h1><p>git  init           本地创建一个空白仓库<br>git  remote       查看当前仓库关联到哪些远程仓库<br>git  remote  add  关联仓库名  远程仓库的地址<br>git  pull  关联仓库名  master    从远程仓库“拉取(pull)”已有的文件和版本信息到本地仓库<br>git  add  .        修改本地仓库中的文件，添加到本地暂存区，提交给本地的仓库<br>git  commit   -m   “说明信息”<br>git  push  远程仓库名  master    把本地仓库中的新的版本信息“推送(push)”给远程仓库</p>\n<p>git subtree push –prefix=dist origin gh-pages  建立分支结构</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><p>安装 Git 之后，你要做的第一件事情就是去配置你的名字和邮箱，因为每一次提交都需要这些信息：</p>\n<p>git  config  –global   user.name   “name”<br>git  config  –global   user.email   “email@qq.com”</p>\n<h1 id=\"指令说明\"><a href=\"#指令说明\" class=\"headerlink\" title=\"指令说明\"></a>指令说明</h1><p>git  status               查看工作区所有文件状态<br>git  add  1.jpg          把指定文件添加到暂存区<br>git  add  <em>.jpg          把指定后缀名的文件添加到暂存区<br>git  add  </em>              把所有文件添加到暂存区<br>git  add  .              把所有文件添加到暂存区<br>git  commit  -m  “消息内容”   把暂存区的修改提交给仓库<br>git  log                 查看仓库中所有的提交记录</p>\n<p>git  reset  –hard  版本号     工作区回退到指定的版本<br>git  log       查看当前已经生效的所有版本号<br>git  reflog     查看当前已经生效&amp;撤销生效的所有版本号</p>\n<h1 id=\"远程仓库相关\"><a href=\"#远程仓库相关\" class=\"headerlink\" title=\"远程仓库相关\"></a>远程仓库相关</h1><p>git  clone  远程仓库的地址<br>git  clone  git@github.com:jquery/jquery.git<br>git  clone  <a href=\"https://github.com/jquery/jquery.git\" target=\"_blank\" rel=\"external\">https://github.com/jquery/jquery.git</a></p>\n<h1 id=\"创建关联使用方法\"><a href=\"#创建关联使用方法\" class=\"headerlink\" title=\"创建关联使用方法\"></a>创建关联使用方法</h1><p>git  init           本地创建一个空白仓库<br>git  remote       查看当前仓库关联到哪些远程仓库<br>git  remote  add  关联仓库名  远程仓库的地址<br>git  pull  关联仓库名  master    从远程仓库“拉取(pull)”已有的文件和版本信息到本地仓库<br>git  add  .        修改本地仓库中的文件，添加到本地暂存区，提交给本地的仓库<br>git  commit   -m   “说明信息”<br>git  push  远程仓库名  master    把本地仓库中的新的版本信息“推送(push)”给远程仓库</p>\n<p>git subtree push –prefix=dist origin gh-pages  建立分支结构</p>\n"},{"title":"http协议","date":"2017-05-13T11:33:05.000Z","_content":"HTTP简介 \nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\nHTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。\n\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n\n \n主要特点 \n1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n\n2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n\n3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 \n5、支持B/S及C/S模式。\n\nHTTP之URL \nHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息\n\nURL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：\n\nhttp://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name\n\n从上面的URL可以看出，一个完整的URL包括以下几部分： \n1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符\n\n2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用\n\n3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口\n\n4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”\n\n5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名\n\n6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分\n\n7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。\n\n（原文：http://blog.csdn.net/ergouge/article/details/8185219 ）\n\nURI和URL的区别 \nURI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。\n\nWeb上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的 \nURI一般由三部组成： \n①访问资源的命名机制 \n②存放资源的主机名 \n③资源自身的名称，由路径表示，着重强调于资源。\n\nURL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。\n\nURL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。 \n采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成： \n①协议(或称为服务方式) \n②存有该资源的主机IP地址(有时也包括端口号) \n③主机资源的具体地址。如目录和文件名等\n\nURN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。\n\nURI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。\n\n在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 \n在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。 \n相反的是，URL类可以打开一个到达资源的流。\n\nHTTP之请求消息Request \n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：\n\n请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。\n\n\n\n\n请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。 \nGet请求例子，使用Charles抓取的request：\n\nGET /562f25980001b1b106000338.jpg HTTP/1.1 \nHost img.mukewang.com \nUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 \nAccept image/webp,image/,/*;q=0.8 \nReferer http://www.imooc.com/ \nAccept-Encoding gzip, deflate, sdch \nAccept-Language zh-CN,zh;q=0.8 \n第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.\n\nGET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。\n\n第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息\n\n从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等\n\n第三部分：空行，请求头部后面的空行是必须的\n\n即使第四部分的请求数据为空，也必须有空行。\n\n第四部分：请求数据也叫主体，可以添加任意的其他数据。\n\n这个例子的请求数据为空。\n\nPOST请求例子，使用Charles抓取的request：\n\nPOST / HTTP1.1 \nHost:www.wrox.com \nUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022) \nContent-Type:application/x-www-form-urlencoded \nContent-Length:40 \nConnection: Keep-Alive\n\nname=Professional%20Ajax&publisher=Wiley \n第一部分：请求行，第一行明了是post请求，以及http1.1版本。 \n第二部分：请求头部，第二行至第六行。 \n第三部分：空行，第七行的空行。 \n第四部分：请求数据，第八行。\n\nHTTP之响应消息Response \n一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n\n\n例子\n\nHTTP/1.1 200 OK \nDate: Fri, 22 May 2009 06:07:21 GMT \nContent-Type: text/html; charset=UTF-8\n    \n    <html>\n          <head></head>\n          <body>\n                <!--body goes here-->\n          </body>\n    </html>\n第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n\n第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）\n\n第二部分：消息报头，用来说明客户端要使用的一些附加信息\n\n第二行和第三行为消息报头， \nDate:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8\n\n第三部分：空行，消息报头后面的空行是必须的\n\n第四部分：响应正文，服务器返回给客户端的文本信息。\n\n空行后面的html部分为响应正文。\n\nHTTP之状态码 \n状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:\n\n1xx：指示信息–表示请求已接收，继续处理\n\n2xx：成功–表示请求已被成功接收、理解、接受\n\n3xx：重定向–要完成请求必须进行更进一步的操作\n\n4xx：客户端错误–请求有语法错误或请求无法实现\n\n5xx：服务器端错误–服务器未能实现合法的请求\n\n常见状态码：\n\n200 OK //客户端请求成功 \n400 Bad Request //客户端请求有语法错误，不能被服务器所理解 \n401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 \n403 Forbidden //服务器收到请求，但是拒绝提供服务 \n404 Not Found //请求资源不存在，eg：输入了错误的URL \n500 Internal Server Error //服务器发生不可预期的错误 \n503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 \n更多状态码http://www.runoob.com/http/http-status-codes.html\n\nHTTP请求方法 \n根据HTTP标准，HTTP请求可以使用多种请求方法。 \nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 \nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\nGET 请求指定的页面信息，并返回实体主体。 \nHEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 \nPOST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。\n数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 \nPUT 从客户端向服务器传送的数据取代指定的文档的内容。 \nDELETE 请求服务器删除指定的页面。 \nCONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 \nOPTIONS 允许客户端查看服务器的性能。 \nTRACE 回显服务器收到的请求，主要用于测试或诊断。 \nHTTP工作原理 \nHTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。\nHTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，\n请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。\n服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n\n\n例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：\n\n1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;\n\n2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;\n\n3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，\n该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;\n\n4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;\n\n5、释放 TCP连接;\n\n6、浏览器将该 html 文本并显示内容; 　　\n\n\n我们看看GET和POST的区别\n\nGET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，\n如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中.\n\nGET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.\n\nGET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。\n\nGET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，\n用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，\n就可以从历史记录获得该用户的账号和密码.","source":"_posts/http.md","raw":"---\ntitle: http协议\ndate: 2017-05-13 19:33:05\ntags:\n---\nHTTP简介 \nHTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n\nHTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n\nHTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。\n\nHTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n\n \n主要特点 \n1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n\n2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n\n3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n\n4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 \n5、支持B/S及C/S模式。\n\nHTTP之URL \nHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息\n\nURL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：\n\nhttp://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name\n\n从上面的URL可以看出，一个完整的URL包括以下几部分： \n1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符\n\n2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用\n\n3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口\n\n4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”\n\n5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名\n\n6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分\n\n7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。\n\n（原文：http://blog.csdn.net/ergouge/article/details/8185219 ）\n\nURI和URL的区别 \nURI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。\n\nWeb上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的 \nURI一般由三部组成： \n①访问资源的命名机制 \n②存放资源的主机名 \n③资源自身的名称，由路径表示，着重强调于资源。\n\nURL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。\n\nURL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。 \n采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成： \n①协议(或称为服务方式) \n②存有该资源的主机IP地址(有时也包括端口号) \n③主机资源的具体地址。如目录和文件名等\n\nURN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。\n\nURI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。\n\n在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。 \n在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。 \n相反的是，URL类可以打开一个到达资源的流。\n\nHTTP之请求消息Request \n客户端发送一个HTTP请求到服务器的请求消息包括以下格式：\n\n请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。\n\n\n\n\n请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。 \nGet请求例子，使用Charles抓取的request：\n\nGET /562f25980001b1b106000338.jpg HTTP/1.1 \nHost img.mukewang.com \nUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36 \nAccept image/webp,image/,/*;q=0.8 \nReferer http://www.imooc.com/ \nAccept-Encoding gzip, deflate, sdch \nAccept-Language zh-CN,zh;q=0.8 \n第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.\n\nGET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。\n\n第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息\n\n从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等\n\n第三部分：空行，请求头部后面的空行是必须的\n\n即使第四部分的请求数据为空，也必须有空行。\n\n第四部分：请求数据也叫主体，可以添加任意的其他数据。\n\n这个例子的请求数据为空。\n\nPOST请求例子，使用Charles抓取的request：\n\nPOST / HTTP1.1 \nHost:www.wrox.com \nUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022) \nContent-Type:application/x-www-form-urlencoded \nContent-Length:40 \nConnection: Keep-Alive\n\nname=Professional%20Ajax&publisher=Wiley \n第一部分：请求行，第一行明了是post请求，以及http1.1版本。 \n第二部分：请求头部，第二行至第六行。 \n第三部分：空行，第七行的空行。 \n第四部分：请求数据，第八行。\n\nHTTP之响应消息Response \n一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。\n\nHTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。\n\n\n\n例子\n\nHTTP/1.1 200 OK \nDate: Fri, 22 May 2009 06:07:21 GMT \nContent-Type: text/html; charset=UTF-8\n    \n    <html>\n          <head></head>\n          <body>\n                <!--body goes here-->\n          </body>\n    </html>\n第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。\n\n第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）\n\n第二部分：消息报头，用来说明客户端要使用的一些附加信息\n\n第二行和第三行为消息报头， \nDate:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8\n\n第三部分：空行，消息报头后面的空行是必须的\n\n第四部分：响应正文，服务器返回给客户端的文本信息。\n\n空行后面的html部分为响应正文。\n\nHTTP之状态码 \n状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:\n\n1xx：指示信息–表示请求已接收，继续处理\n\n2xx：成功–表示请求已被成功接收、理解、接受\n\n3xx：重定向–要完成请求必须进行更进一步的操作\n\n4xx：客户端错误–请求有语法错误或请求无法实现\n\n5xx：服务器端错误–服务器未能实现合法的请求\n\n常见状态码：\n\n200 OK //客户端请求成功 \n400 Bad Request //客户端请求有语法错误，不能被服务器所理解 \n401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 \n403 Forbidden //服务器收到请求，但是拒绝提供服务 \n404 Not Found //请求资源不存在，eg：输入了错误的URL \n500 Internal Server Error //服务器发生不可预期的错误 \n503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常 \n更多状态码http://www.runoob.com/http/http-status-codes.html\n\nHTTP请求方法 \n根据HTTP标准，HTTP请求可以使用多种请求方法。 \nHTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。 \nHTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。\n\nGET 请求指定的页面信息，并返回实体主体。 \nHEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 \nPOST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。\n数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 \nPUT 从客户端向服务器传送的数据取代指定的文档的内容。 \nDELETE 请求服务器删除指定的页面。 \nCONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 \nOPTIONS 允许客户端查看服务器的性能。 \nTRACE 回显服务器收到的请求，主要用于测试或诊断。 \nHTTP工作原理 \nHTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。\nHTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，\n请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。\n服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。\n\n\n例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：\n\n1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;\n\n2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;\n\n3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，\n该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;\n\n4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;\n\n5、释放 TCP连接;\n\n6、浏览器将该 html 文本并显示内容; 　　\n\n\n我们看看GET和POST的区别\n\nGET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连，\n如EditPosts.aspx?name=test1&id=123456. POST方法是把提交的数据放在HTTP包的Body中.\n\nGET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.\n\nGET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。\n\nGET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，\n用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，\n就可以从历史记录获得该用户的账号和密码.","slug":"http","published":1,"updated":"2017-08-13T12:32:33.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsj90006ecvjls9spuhi","content":"<p>HTTP简介<br>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>\n<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p>\n<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>\n<p>主要特点<br>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>\n<p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>\n<p>3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n<p>4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>5、支持B/S及C/S模式。</p>\n<p>HTTP之URL<br>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p>\n<p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p>\n<p><a href=\"http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name\" target=\"_blank\" rel=\"external\">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p>\n<p>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p>\n<p>2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</p>\n<p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p>\n<p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>\n<p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>\n<p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>\n<p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>\n<p>（原文：<a href=\"http://blog.csdn.net/ergouge/article/details/8185219\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</p>\n<p>URI和URL的区别<br>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</p>\n<p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p>\n<p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>\n<p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</p>\n<p>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。</p>\n<p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p>\n<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p>\n<p>HTTP之请求消息Request<br>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p>\n<p>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</p>\n<p>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。<br>Get请求例子，使用Charles抓取的request：</p>\n<p>GET /562f25980001b1b106000338.jpg HTTP/1.1<br>Host img.mukewang.com<br>User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36<br>Accept image/webp,image/,/*;q=0.8<br>Referer <a href=\"http://www.imooc.com/\" target=\"_blank\" rel=\"external\">http://www.imooc.com/</a><br>Accept-Encoding gzip, deflate, sdch<br>Accept-Language zh-CN,zh;q=0.8<br>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</p>\n<p>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p>\n<p>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</p>\n<p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p>\n<p>第三部分：空行，请求头部后面的空行是必须的</p>\n<p>即使第四部分的请求数据为空，也必须有空行。</p>\n<p>第四部分：请求数据也叫主体，可以添加任意的其他数据。</p>\n<p>这个例子的请求数据为空。</p>\n<p>POST请求例子，使用Charles抓取的request：</p>\n<p>POST / HTTP1.1<br>Host:www.wrox.com<br>User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)<br>Content-Type:application/x-www-form-urlencoded<br>Content-Length:40<br>Connection: Keep-Alive</p>\n<p>name=Professional%20Ajax&amp;publisher=Wiley<br>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p>\n<p>HTTP之响应消息Response<br>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p>\n<p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p>例子</p>\n<p>HTTP/1.1 200 OK<br>Date: Fri, 22 May 2009 06:07:21 GMT<br>Content-Type: text/html; charset=UTF-8</p>\n<pre><code>&lt;html&gt;\n      &lt;head&gt;&lt;/head&gt;\n      &lt;body&gt;\n            &lt;!--body goes here--&gt;\n      &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>\n<p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>\n<p>第二部分：消息报头，用来说明客户端要使用的一些附加信息</p>\n<p>第二行和第三行为消息报头，<br>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p>\n<p>第三部分：空行，消息报头后面的空行是必须的</p>\n<p>第四部分：响应正文，服务器返回给客户端的文本信息。</p>\n<p>空行后面的html部分为响应正文。</p>\n<p>HTTP之状态码<br>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>\n<p>1xx：指示信息–表示请求已接收，继续处理</p>\n<p>2xx：成功–表示请求已被成功接收、理解、接受</p>\n<p>3xx：重定向–要完成请求必须进行更进一步的操作</p>\n<p>4xx：客户端错误–请求有语法错误或请求无法实现</p>\n<p>5xx：服务器端错误–服务器未能实现合法的请求</p>\n<p>常见状态码：</p>\n<p>200 OK //客户端请求成功<br>400 Bad Request //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden //服务器收到请求，但是拒绝提供服务<br>404 Not Found //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br>更多状态码<a href=\"http://www.runoob.com/http/http-status-codes.html\" target=\"_blank\" rel=\"external\">http://www.runoob.com/http/http-status-codes.html</a></p>\n<p>HTTP请求方法<br>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n<p>GET 请求指定的页面信息，并返回实体主体。<br>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。<br>数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>PUT 从客户端向服务器传送的数据取代指定的文档的内容。<br>DELETE 请求服务器删除指定的页面。<br>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>OPTIONS 允许客户端查看服务器的性能。<br>TRACE 回显服务器收到的请求，主要用于测试或诊断。<br>HTTP工作原理<br>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。<br>HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，<br>请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。<br>服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>\n<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>\n<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>\n<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p>\n<p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，<br>该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p>\n<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>\n<p>5、释放 TCP连接;</p>\n<p>6、浏览器将该 html 文本并显示内容; 　　</p>\n<p>我们看看GET和POST的区别</p>\n<p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，<br>如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p>\n<p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p>\n<p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p>\n<p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，<br>用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，<br>就可以从历史记录获得该用户的账号和密码.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>HTTP简介<br>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p>\n<p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>\n<p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。</p>\n<p>HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。</p>\n<p>主要特点<br>1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</p>\n<p>2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</p>\n<p>3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p>\n<p>4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>5、支持B/S及C/S模式。</p>\n<p>HTTP之URL<br>HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息</p>\n<p>URL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：</p>\n<p><a href=\"http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name\" target=\"_blank\" rel=\"external\">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></p>\n<p>从上面的URL可以看出，一个完整的URL包括以下几部分：<br>1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符</p>\n<p>2.域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</p>\n<p>3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口</p>\n<p>4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”</p>\n<p>5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名</p>\n<p>6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分</p>\n<p>7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</p>\n<p>（原文：<a href=\"http://blog.csdn.net/ergouge/article/details/8185219\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/ergouge/article/details/8185219</a> ）</p>\n<p>URI和URL的区别<br>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。</p>\n<p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的<br>URI一般由三部组成：<br>①访问资源的命名机制<br>②存放资源的主机名<br>③资源自身的名称，由路径表示，着重强调于资源。</p>\n<p>URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</p>\n<p>URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br>采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成：<br>①协议(或称为服务方式)<br>②存有该资源的主机IP地址(有时也包括端口号)<br>③主机资源的具体地址。如目录和文件名等</p>\n<p>URN，uniform resource name，统一资源命名，是通过名字来标识资源，比如mailto:java-net@java.sun.com。</p>\n<p>URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI。笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 (URN)，它命名资源但不指定如何定位资源。上面的 mailto、news 和 isbn URI 都是 URN 的示例。</p>\n<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符合URI的语法规则。而URL类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的。<br>在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。<br>相反的是，URL类可以打开一个到达资源的流。</p>\n<p>HTTP之请求消息Request<br>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：</p>\n<p>请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。</p>\n<p>请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。<br>Get请求例子，使用Charles抓取的request：</p>\n<p>GET /562f25980001b1b106000338.jpg HTTP/1.1<br>Host img.mukewang.com<br>User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36<br>Accept image/webp,image/,/*;q=0.8<br>Referer <a href=\"http://www.imooc.com/\" target=\"_blank\" rel=\"external\">http://www.imooc.com/</a><br>Accept-Encoding gzip, deflate, sdch<br>Accept-Language zh-CN,zh;q=0.8<br>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.</p>\n<p>GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。</p>\n<p>第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息</p>\n<p>从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等</p>\n<p>第三部分：空行，请求头部后面的空行是必须的</p>\n<p>即使第四部分的请求数据为空，也必须有空行。</p>\n<p>第四部分：请求数据也叫主体，可以添加任意的其他数据。</p>\n<p>这个例子的请求数据为空。</p>\n<p>POST请求例子，使用Charles抓取的request：</p>\n<p>POST / HTTP1.1<br>Host:www.wrox.com<br>User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)<br>Content-Type:application/x-www-form-urlencoded<br>Content-Length:40<br>Connection: Keep-Alive</p>\n<p>name=Professional%20Ajax&amp;publisher=Wiley<br>第一部分：请求行，第一行明了是post请求，以及http1.1版本。<br>第二部分：请求头部，第二行至第六行。<br>第三部分：空行，第七行的空行。<br>第四部分：请求数据，第八行。</p>\n<p>HTTP之响应消息Response<br>一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。</p>\n<p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p>\n<p>例子</p>\n<p>HTTP/1.1 200 OK<br>Date: Fri, 22 May 2009 06:07:21 GMT<br>Content-Type: text/html; charset=UTF-8</p>\n<pre><code>&lt;html&gt;\n      &lt;head&gt;&lt;/head&gt;\n      &lt;body&gt;\n            &lt;!--body goes here--&gt;\n      &lt;/body&gt;\n&lt;/html&gt;\n</code></pre><p>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>\n<p>第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）</p>\n<p>第二部分：消息报头，用来说明客户端要使用的一些附加信息</p>\n<p>第二行和第三行为消息报头，<br>Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8</p>\n<p>第三部分：空行，消息报头后面的空行是必须的</p>\n<p>第四部分：响应正文，服务器返回给客户端的文本信息。</p>\n<p>空行后面的html部分为响应正文。</p>\n<p>HTTP之状态码<br>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p>\n<p>1xx：指示信息–表示请求已接收，继续处理</p>\n<p>2xx：成功–表示请求已被成功接收、理解、接受</p>\n<p>3xx：重定向–要完成请求必须进行更进一步的操作</p>\n<p>4xx：客户端错误–请求有语法错误或请求无法实现</p>\n<p>5xx：服务器端错误–服务器未能实现合法的请求</p>\n<p>常见状态码：</p>\n<p>200 OK //客户端请求成功<br>400 Bad Request //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden //服务器收到请求，但是拒绝提供服务<br>404 Not Found //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br>更多状态码<a href=\"http://www.runoob.com/http/http-status-codes.html\" target=\"_blank\" rel=\"external\">http://www.runoob.com/http/http-status-codes.html</a></p>\n<p>HTTP请求方法<br>根据HTTP标准，HTTP请求可以使用多种请求方法。<br>HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。<br>HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</p>\n<p>GET 请求指定的页面信息，并返回实体主体。<br>HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。<br>数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>PUT 从客户端向服务器传送的数据取代指定的文档的内容。<br>DELETE 请求服务器删除指定的页面。<br>CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>OPTIONS 允许客户端查看服务器的性能。<br>TRACE 回显服务器收到的请求，主要用于测试或诊断。<br>HTTP工作原理<br>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。<br>HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，<br>请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。<br>服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p>\n<p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p>\n<p>1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</p>\n<p>2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</p>\n<p>3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，<br>该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</p>\n<p>4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</p>\n<p>5、释放 TCP连接;</p>\n<p>6、浏览器将该 html 文本并显示内容; 　　</p>\n<p>我们看看GET和POST的区别</p>\n<p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，<br>如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中.</p>\n<p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p>\n<p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p>\n<p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，<br>用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，<br>就可以从历史记录获得该用户的账号和密码.</p>\n"},{"title":"10个JavaScript难点","date":"2017-03-02T11:56:30.000Z","_content":"# 10个JavaScript难点概括\n\n# 1. 立即执行函数\n\n立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：\n\n    (function() {\n         // 代码\n         // ...\n    })();\nfunction(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。\n\n# 2. 闭包\n\n对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。\n\n  \n    function f1()\n    {\n        var N = 0; // N是f1函数的局部变量\n    \n    function f2() // f2是f1函数的内部函数，是闭包\n    {\n        N += 1; // 内部函数f2中使用了外部函数f1中的变量N\n        console.log(N);\n    }\n    return f2;\n    }\n    var result = f1();\n    result(); // 输出1\n    result(); // 输出2\n    result(); // 输出3\n    \n    \n代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！\n\n# 3. 使用闭包定义私有变量\n\n通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：\n\n    function Product() {\n        var name;\n        this.setName = function(value) {\n            name = value;\n        };\n        this.getName = function() {\n            return name;\n        };\n    }\n    var p = new Product();\n    p.setName(\"Fundebug\");\n    console.log(p.name); // 输出undefined\n    console.log(p.getName()); // 输出Fundebug\n    代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。\n\n# 4. prototype\n\n每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。\n\n    function Rectangle(x, y)\n    {\n        this._length = x;\n        this._breadth = y;\n    }\n    Rectangle.prototype.getDimensions = function()\n    {\n        return {\n            length: this._length,\n            breadth: this._breadth\n        };\n    };\n    var x = new Rectangle(3, 4);\n    var y = new Rectangle(4, 3);\n    console.log(x.getDimensions()); // { length: 3, breadth: 4 }\n    console.log(y.getDimensions()); // { length: 4, breadth: 3 }\n代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。\n\n# 5. 模块化\n\nJavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery\n\n    var module = (function() {\n        var N = 5;\n        function print(x) {\n            console.log(\"The result is: \" + x);\n        }\n        function add(a) {\n            var x = a + N;\n            print(x);\n        }\n        return {\n            description: \"This is description\",\n            add: add\n        };\n    })();\n    console.log(module.description); // 输出\"this is description\" \n    module.add(5); // 输出“The result is: 10”\n所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。\n\n# 6. 变量提升\n\nJavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。\n\n但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：\n\n    console.log(y);  // 输出undefined\n    y = 2; // 初始化y\n    上面的代码等价于下面的代码：\n    \n    var y;  // 声明y\n    console.log(y);  // 输出undefined\n    y = 2; // 初始化y\n    为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。\n\n# 7. 柯里化\n\n柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n    var add = function(x) {\n        return function(y) {\n            return x + y;\n        };\n    };\n    console.log(add(1)(1)); // 输出2\n    var add1 = add(1);\n    console.log(add1(1)); // 输出2\n    var add10 = add(10);\n    console.log(add10(1)); // 输出11\n    代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。\n\n# 8. apply, call与bind方法\n\nJavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。\n\n三者之中，call方法是最简单的，它等价于指定this值调用函数：\n\n    var user = {\n        name: \"Rahul Mhatre\",\n        whatIsYourName: function() {\n            console.log(this.name);\n        }\n    };\n    user.whatIsYourName(); // 输出\"Rahul Mhatre\",\n    var user2 = {\n        name: \"Neha Sampat\"\n    };\n    user.whatIsYourName.call(user2); // 输出\"Neha Sampat\"\napply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定：\n\n    apply(thisArg, [argsArray])\n    call(thisArg, arg1, arg2, …)\n    var user = {\n        greet: \"Hello!\",\n        greetUser: function(userName) {\n            console.log(this.greet + \" \" + userName);\n        }\n    };\n    var greet1 = {\n        greet: \"Hola\"\n    };\n    user.greetUser.call(greet1, \"Rahul\"); // 输出\"Hola Rahul\"\n    user.greetUser.apply(greet1, [\"Rahul\"]); // 输出\"Hola Rahul\"\n使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：\n\n    var user = {\n         greet: \"Hello!\",\n         greetUser: function(userName) {\n         console.log(this.greet + \" \" + userName);\n         }\n    };\n    var greetHola = user.greetUser.bind({greet: \"Hola\"});\n    var greetBonjour = user.greetUser.bind({greet: \"Bonjour\"});\n    greetHola(\"Rahul\") // 输出\"Hola Rahul\"\n    greetBonjour(\"Rahul\") // 输出\"Bonjour Rahul\"\n# 9. Memoization\n\nMemoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。\n\n    function memoizeFunction(func)\n    {\n        var cache = {};\n        return function()\n        {\n            var key = arguments[0];\n            if (cache[key])\n            {\n                return cache[key];\n            }\n            else\n            {\n                var val = func.apply(this, arguments);\n                cache[key] = val;\n                return val;\n            }\n        };\n    }\n    var fibonacci = memoizeFunction(function(n)\n    {\n        return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);\n    });\n    console.log(fibonacci(100)); // 输出354224848179262000000\n    console.log(fibonacci(100)); // 输出354224848179262000000\n    代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。\n\n# 10. 函数重载\n\n所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。\n\n从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。\n\n难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。\n\n由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。\n\n根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。\n\n    function addMethod(object, name, f)\n    {　　\n        var old = object[name];　　\n        object[name] = function()\n        {\n            // f.length为函数定义时的参数个数\n            // arguments.length为函数调用时的参数个数　　　　\n            if (f.length === arguments.length)\n            {　　\n                return f.apply(this, arguments);　　　　\n            }\n            else if (typeof old === \"function\")\n            {\n                return old.apply(this, arguments);　　　　\n            }　　\n        };\n    }\n    // 不传参数时，返回所有name\n    function find0()\n    {　　\n        return this.names;\n    }\n    // 传一个参数时，返回firstName匹配的name\n    function find1(firstName)\n    {　　\n        var result = [];　　\n        for (var i = 0; i < this.names.length; i++)\n        {　　　　\n            if (this.names[i].indexOf(firstName) === 0)\n            {　　　　　　\n                result.push(this.names[i]);　　　　\n            }　　\n        }　　\n        return result;\n    }\n    // 传两个参数时，返回firstName和lastName都匹配的name\n    function find2(firstName, lastName)\n    {　\n        var result = [];　　\n        for (var i = 0; i < this.names.length; i++)\n        {　　　　\n            if (this.names[i] === (firstName + \" \" + lastName))\n            {　　　　　　\n                result.push(this.names[i]);　　　　\n            }　　\n        }　　\n        return result;\n    }\n    var people = {　　\n        names: [\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]\n    };\n    addMethod(people, \"find\", find0);\n    addMethod(people, \"find\", find1);\n    addMethod(people, \"find\", find2);\n    console.log(people.find()); // 输出[\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]\n    console.log(people.find(\"Dean\")); // 输出[\"Dean Edwards\", \"Dean Tom\"]\n    console.log(people.find(\"Dean\", \"Edwards\")); // 输出[\"Dean Edwards\"]\n","source":"_posts/js.md","raw":"---\ntitle: 10个JavaScript难点\ndate: 2017-03-02 19:56:30\ntags:\n---\n# 10个JavaScript难点概括\n\n# 1. 立即执行函数\n\n立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：\n\n    (function() {\n         // 代码\n         // ...\n    })();\nfunction(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。\n\n# 2. 闭包\n\n对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。\n\n  \n    function f1()\n    {\n        var N = 0; // N是f1函数的局部变量\n    \n    function f2() // f2是f1函数的内部函数，是闭包\n    {\n        N += 1; // 内部函数f2中使用了外部函数f1中的变量N\n        console.log(N);\n    }\n    return f2;\n    }\n    var result = f1();\n    result(); // 输出1\n    result(); // 输出2\n    result(); // 输出3\n    \n    \n代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！\n\n# 3. 使用闭包定义私有变量\n\n通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：\n\n    function Product() {\n        var name;\n        this.setName = function(value) {\n            name = value;\n        };\n        this.getName = function() {\n            return name;\n        };\n    }\n    var p = new Product();\n    p.setName(\"Fundebug\");\n    console.log(p.name); // 输出undefined\n    console.log(p.getName()); // 输出Fundebug\n    代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。\n\n# 4. prototype\n\n每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。\n\n    function Rectangle(x, y)\n    {\n        this._length = x;\n        this._breadth = y;\n    }\n    Rectangle.prototype.getDimensions = function()\n    {\n        return {\n            length: this._length,\n            breadth: this._breadth\n        };\n    };\n    var x = new Rectangle(3, 4);\n    var y = new Rectangle(4, 3);\n    console.log(x.getDimensions()); // { length: 3, breadth: 4 }\n    console.log(y.getDimensions()); // { length: 4, breadth: 3 }\n代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。\n\n# 5. 模块化\n\nJavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery\n\n    var module = (function() {\n        var N = 5;\n        function print(x) {\n            console.log(\"The result is: \" + x);\n        }\n        function add(a) {\n            var x = a + N;\n            print(x);\n        }\n        return {\n            description: \"This is description\",\n            add: add\n        };\n    })();\n    console.log(module.description); // 输出\"this is description\" \n    module.add(5); // 输出“The result is: 10”\n所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。\n\n# 6. 变量提升\n\nJavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。\n\n但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：\n\n    console.log(y);  // 输出undefined\n    y = 2; // 初始化y\n    上面的代码等价于下面的代码：\n    \n    var y;  // 声明y\n    console.log(y);  // 输出undefined\n    y = 2; // 初始化y\n    为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。\n\n# 7. 柯里化\n\n柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n    var add = function(x) {\n        return function(y) {\n            return x + y;\n        };\n    };\n    console.log(add(1)(1)); // 输出2\n    var add1 = add(1);\n    console.log(add1(1)); // 输出2\n    var add10 = add(10);\n    console.log(add10(1)); // 输出11\n    代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。\n\n# 8. apply, call与bind方法\n\nJavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。\n\n三者之中，call方法是最简单的，它等价于指定this值调用函数：\n\n    var user = {\n        name: \"Rahul Mhatre\",\n        whatIsYourName: function() {\n            console.log(this.name);\n        }\n    };\n    user.whatIsYourName(); // 输出\"Rahul Mhatre\",\n    var user2 = {\n        name: \"Neha Sampat\"\n    };\n    user.whatIsYourName.call(user2); // 输出\"Neha Sampat\"\napply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定：\n\n    apply(thisArg, [argsArray])\n    call(thisArg, arg1, arg2, …)\n    var user = {\n        greet: \"Hello!\",\n        greetUser: function(userName) {\n            console.log(this.greet + \" \" + userName);\n        }\n    };\n    var greet1 = {\n        greet: \"Hola\"\n    };\n    user.greetUser.call(greet1, \"Rahul\"); // 输出\"Hola Rahul\"\n    user.greetUser.apply(greet1, [\"Rahul\"]); // 输出\"Hola Rahul\"\n使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：\n\n    var user = {\n         greet: \"Hello!\",\n         greetUser: function(userName) {\n         console.log(this.greet + \" \" + userName);\n         }\n    };\n    var greetHola = user.greetUser.bind({greet: \"Hola\"});\n    var greetBonjour = user.greetUser.bind({greet: \"Bonjour\"});\n    greetHola(\"Rahul\") // 输出\"Hola Rahul\"\n    greetBonjour(\"Rahul\") // 输出\"Bonjour Rahul\"\n# 9. Memoization\n\nMemoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。\n\n    function memoizeFunction(func)\n    {\n        var cache = {};\n        return function()\n        {\n            var key = arguments[0];\n            if (cache[key])\n            {\n                return cache[key];\n            }\n            else\n            {\n                var val = func.apply(this, arguments);\n                cache[key] = val;\n                return val;\n            }\n        };\n    }\n    var fibonacci = memoizeFunction(function(n)\n    {\n        return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);\n    });\n    console.log(fibonacci(100)); // 输出354224848179262000000\n    console.log(fibonacci(100)); // 输出354224848179262000000\n    代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。\n\n# 10. 函数重载\n\n所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。\n\n从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。\n\n难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。\n\n由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。\n\n根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。\n\n    function addMethod(object, name, f)\n    {　　\n        var old = object[name];　　\n        object[name] = function()\n        {\n            // f.length为函数定义时的参数个数\n            // arguments.length为函数调用时的参数个数　　　　\n            if (f.length === arguments.length)\n            {　　\n                return f.apply(this, arguments);　　　　\n            }\n            else if (typeof old === \"function\")\n            {\n                return old.apply(this, arguments);　　　　\n            }　　\n        };\n    }\n    // 不传参数时，返回所有name\n    function find0()\n    {　　\n        return this.names;\n    }\n    // 传一个参数时，返回firstName匹配的name\n    function find1(firstName)\n    {　　\n        var result = [];　　\n        for (var i = 0; i < this.names.length; i++)\n        {　　　　\n            if (this.names[i].indexOf(firstName) === 0)\n            {　　　　　　\n                result.push(this.names[i]);　　　　\n            }　　\n        }　　\n        return result;\n    }\n    // 传两个参数时，返回firstName和lastName都匹配的name\n    function find2(firstName, lastName)\n    {　\n        var result = [];　　\n        for (var i = 0; i < this.names.length; i++)\n        {　　　　\n            if (this.names[i] === (firstName + \" \" + lastName))\n            {　　　　　　\n                result.push(this.names[i]);　　　　\n            }　　\n        }　　\n        return result;\n    }\n    var people = {　　\n        names: [\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]\n    };\n    addMethod(people, \"find\", find0);\n    addMethod(people, \"find\", find1);\n    addMethod(people, \"find\", find2);\n    console.log(people.find()); // 输出[\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]\n    console.log(people.find(\"Dean\")); // 输出[\"Dean Edwards\", \"Dean Tom\"]\n    console.log(people.find(\"Dean\", \"Edwards\")); // 输出[\"Dean Edwards\"]\n","slug":"js","published":1,"updated":"2017-08-12T10:42:07.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsja0007ecvjadplslu2","content":"<h1 id=\"10个JavaScript难点概括\"><a href=\"#10个JavaScript难点概括\" class=\"headerlink\" title=\"10个JavaScript难点概括\"></a>10个JavaScript难点概括</h1><h1 id=\"1-立即执行函数\"><a href=\"#1-立即执行函数\" class=\"headerlink\" title=\"1. 立即执行函数\"></a>1. 立即执行函数</h1><p>立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：</p>\n<pre><code>(function() {\n     // 代码\n     // ...\n})();\n</code></pre><p>function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。</p>\n<h1 id=\"2-闭包\"><a href=\"#2-闭包\" class=\"headerlink\" title=\"2. 闭包\"></a>2. 闭包</h1><p>对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。</p>\n<pre><code>function f1()\n{\n    var N = 0; // N是f1函数的局部变量\n\nfunction f2() // f2是f1函数的内部函数，是闭包\n{\n    N += 1; // 内部函数f2中使用了外部函数f1中的变量N\n    console.log(N);\n}\nreturn f2;\n}\nvar result = f1();\nresult(); // 输出1\nresult(); // 输出2\nresult(); // 输出3\n</code></pre><p>代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！</p>\n<h1 id=\"3-使用闭包定义私有变量\"><a href=\"#3-使用闭包定义私有变量\" class=\"headerlink\" title=\"3. 使用闭包定义私有变量\"></a>3. 使用闭包定义私有变量</h1><p>通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：</p>\n<pre><code>function Product() {\n    var name;\n    this.setName = function(value) {\n        name = value;\n    };\n    this.getName = function() {\n        return name;\n    };\n}\nvar p = new Product();\np.setName(&quot;Fundebug&quot;);\nconsole.log(p.name); // 输出undefined\nconsole.log(p.getName()); // 输出Fundebug\n代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。\n</code></pre><h1 id=\"4-prototype\"><a href=\"#4-prototype\" class=\"headerlink\" title=\"4. prototype\"></a>4. prototype</h1><p>每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。</p>\n<pre><code>function Rectangle(x, y)\n{\n    this._length = x;\n    this._breadth = y;\n}\nRectangle.prototype.getDimensions = function()\n{\n    return {\n        length: this._length,\n        breadth: this._breadth\n    };\n};\nvar x = new Rectangle(3, 4);\nvar y = new Rectangle(4, 3);\nconsole.log(x.getDimensions()); // { length: 3, breadth: 4 }\nconsole.log(y.getDimensions()); // { length: 4, breadth: 3 }\n</code></pre><p>代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。</p>\n<h1 id=\"5-模块化\"><a href=\"#5-模块化\" class=\"headerlink\" title=\"5. 模块化\"></a>5. 模块化</h1><p>JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery</p>\n<pre><code>var module = (function() {\n    var N = 5;\n    function print(x) {\n        console.log(&quot;The result is: &quot; + x);\n    }\n    function add(a) {\n        var x = a + N;\n        print(x);\n    }\n    return {\n        description: &quot;This is description&quot;,\n        add: add\n    };\n})();\nconsole.log(module.description); // 输出&quot;this is description&quot; \nmodule.add(5); // 输出“The result is: 10”\n</code></pre><p>所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。</p>\n<h1 id=\"6-变量提升\"><a href=\"#6-变量提升\" class=\"headerlink\" title=\"6. 变量提升\"></a>6. 变量提升</h1><p>JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。</p>\n<p>但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：</p>\n<pre><code>console.log(y);  // 输出undefined\ny = 2; // 初始化y\n上面的代码等价于下面的代码：\n\nvar y;  // 声明y\nconsole.log(y);  // 输出undefined\ny = 2; // 初始化y\n为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。\n</code></pre><h1 id=\"7-柯里化\"><a href=\"#7-柯里化\" class=\"headerlink\" title=\"7. 柯里化\"></a>7. 柯里化</h1><p>柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n<pre><code>var add = function(x) {\n    return function(y) {\n        return x + y;\n    };\n};\nconsole.log(add(1)(1)); // 输出2\nvar add1 = add(1);\nconsole.log(add1(1)); // 输出2\nvar add10 = add(10);\nconsole.log(add10(1)); // 输出11\n代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。\n</code></pre><h1 id=\"8-apply-call与bind方法\"><a href=\"#8-apply-call与bind方法\" class=\"headerlink\" title=\"8. apply, call与bind方法\"></a>8. apply, call与bind方法</h1><p>JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。</p>\n<p>三者之中，call方法是最简单的，它等价于指定this值调用函数：</p>\n<pre><code>var user = {\n    name: &quot;Rahul Mhatre&quot;,\n    whatIsYourName: function() {\n        console.log(this.name);\n    }\n};\nuser.whatIsYourName(); // 输出&quot;Rahul Mhatre&quot;,\nvar user2 = {\n    name: &quot;Neha Sampat&quot;\n};\nuser.whatIsYourName.call(user2); // 输出&quot;Neha Sampat&quot;\n</code></pre><p>apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定：</p>\n<pre><code>apply(thisArg, [argsArray])\ncall(thisArg, arg1, arg2, …)\nvar user = {\n    greet: &quot;Hello!&quot;,\n    greetUser: function(userName) {\n        console.log(this.greet + &quot; &quot; + userName);\n    }\n};\nvar greet1 = {\n    greet: &quot;Hola&quot;\n};\nuser.greetUser.call(greet1, &quot;Rahul&quot;); // 输出&quot;Hola Rahul&quot;\nuser.greetUser.apply(greet1, [&quot;Rahul&quot;]); // 输出&quot;Hola Rahul&quot;\n</code></pre><p>使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：</p>\n<pre><code>var user = {\n     greet: &quot;Hello!&quot;,\n     greetUser: function(userName) {\n     console.log(this.greet + &quot; &quot; + userName);\n     }\n};\nvar greetHola = user.greetUser.bind({greet: &quot;Hola&quot;});\nvar greetBonjour = user.greetUser.bind({greet: &quot;Bonjour&quot;});\ngreetHola(&quot;Rahul&quot;) // 输出&quot;Hola Rahul&quot;\ngreetBonjour(&quot;Rahul&quot;) // 输出&quot;Bonjour Rahul&quot;\n</code></pre><h1 id=\"9-Memoization\"><a href=\"#9-Memoization\" class=\"headerlink\" title=\"9. Memoization\"></a>9. Memoization</h1><p>Memoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。</p>\n<pre><code>function memoizeFunction(func)\n{\n    var cache = {};\n    return function()\n    {\n        var key = arguments[0];\n        if (cache[key])\n        {\n            return cache[key];\n        }\n        else\n        {\n            var val = func.apply(this, arguments);\n            cache[key] = val;\n            return val;\n        }\n    };\n}\nvar fibonacci = memoizeFunction(function(n)\n{\n    return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);\n});\nconsole.log(fibonacci(100)); // 输出354224848179262000000\nconsole.log(fibonacci(100)); // 输出354224848179262000000\n代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。\n</code></pre><h1 id=\"10-函数重载\"><a href=\"#10-函数重载\" class=\"headerlink\" title=\"10. 函数重载\"></a>10. 函数重载</h1><p>所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。</p>\n<p>从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。</p>\n<p>难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。</p>\n<p>由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。</p>\n<p>根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。</p>\n<pre><code>function addMethod(object, name, f)\n{　　\n    var old = object[name];　　\n    object[name] = function()\n    {\n        // f.length为函数定义时的参数个数\n        // arguments.length为函数调用时的参数个数　　　　\n        if (f.length === arguments.length)\n        {　　\n            return f.apply(this, arguments);　　　　\n        }\n        else if (typeof old === &quot;function&quot;)\n        {\n            return old.apply(this, arguments);　　　　\n        }　　\n    };\n}\n// 不传参数时，返回所有name\nfunction find0()\n{　　\n    return this.names;\n}\n// 传一个参数时，返回firstName匹配的name\nfunction find1(firstName)\n{　　\n    var result = [];　　\n    for (var i = 0; i &lt; this.names.length; i++)\n    {　　　　\n        if (this.names[i].indexOf(firstName) === 0)\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}\n// 传两个参数时，返回firstName和lastName都匹配的name\nfunction find2(firstName, lastName)\n{　\n    var result = [];　　\n    for (var i = 0; i &lt; this.names.length; i++)\n    {　　　　\n        if (this.names[i] === (firstName + &quot; &quot; + lastName))\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}\nvar people = {　　\n    names: [&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]\n};\naddMethod(people, &quot;find&quot;, find0);\naddMethod(people, &quot;find&quot;, find1);\naddMethod(people, &quot;find&quot;, find2);\nconsole.log(people.find()); // 输出[&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]\nconsole.log(people.find(&quot;Dean&quot;)); // 输出[&quot;Dean Edwards&quot;, &quot;Dean Tom&quot;]\nconsole.log(people.find(&quot;Dean&quot;, &quot;Edwards&quot;)); // 输出[&quot;Dean Edwards&quot;]\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"10个JavaScript难点概括\"><a href=\"#10个JavaScript难点概括\" class=\"headerlink\" title=\"10个JavaScript难点概括\"></a>10个JavaScript难点概括</h1><h1 id=\"1-立即执行函数\"><a href=\"#1-立即执行函数\" class=\"headerlink\" title=\"1. 立即执行函数\"></a>1. 立即执行函数</h1><p>立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：</p>\n<pre><code>(function() {\n     // 代码\n     // ...\n})();\n</code></pre><p>function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。</p>\n<h1 id=\"2-闭包\"><a href=\"#2-闭包\" class=\"headerlink\" title=\"2. 闭包\"></a>2. 闭包</h1><p>对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。</p>\n<pre><code>function f1()\n{\n    var N = 0; // N是f1函数的局部变量\n\nfunction f2() // f2是f1函数的内部函数，是闭包\n{\n    N += 1; // 内部函数f2中使用了外部函数f1中的变量N\n    console.log(N);\n}\nreturn f2;\n}\nvar result = f1();\nresult(); // 输出1\nresult(); // 输出2\nresult(); // 输出3\n</code></pre><p>代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！</p>\n<h1 id=\"3-使用闭包定义私有变量\"><a href=\"#3-使用闭包定义私有变量\" class=\"headerlink\" title=\"3. 使用闭包定义私有变量\"></a>3. 使用闭包定义私有变量</h1><p>通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：</p>\n<pre><code>function Product() {\n    var name;\n    this.setName = function(value) {\n        name = value;\n    };\n    this.getName = function() {\n        return name;\n    };\n}\nvar p = new Product();\np.setName(&quot;Fundebug&quot;);\nconsole.log(p.name); // 输出undefined\nconsole.log(p.getName()); // 输出Fundebug\n代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。\n</code></pre><h1 id=\"4-prototype\"><a href=\"#4-prototype\" class=\"headerlink\" title=\"4. prototype\"></a>4. prototype</h1><p>每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。</p>\n<pre><code>function Rectangle(x, y)\n{\n    this._length = x;\n    this._breadth = y;\n}\nRectangle.prototype.getDimensions = function()\n{\n    return {\n        length: this._length,\n        breadth: this._breadth\n    };\n};\nvar x = new Rectangle(3, 4);\nvar y = new Rectangle(4, 3);\nconsole.log(x.getDimensions()); // { length: 3, breadth: 4 }\nconsole.log(y.getDimensions()); // { length: 4, breadth: 3 }\n</code></pre><p>代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。</p>\n<h1 id=\"5-模块化\"><a href=\"#5-模块化\" class=\"headerlink\" title=\"5. 模块化\"></a>5. 模块化</h1><p>JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery</p>\n<pre><code>var module = (function() {\n    var N = 5;\n    function print(x) {\n        console.log(&quot;The result is: &quot; + x);\n    }\n    function add(a) {\n        var x = a + N;\n        print(x);\n    }\n    return {\n        description: &quot;This is description&quot;,\n        add: add\n    };\n})();\nconsole.log(module.description); // 输出&quot;this is description&quot; \nmodule.add(5); // 输出“The result is: 10”\n</code></pre><p>所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。</p>\n<h1 id=\"6-变量提升\"><a href=\"#6-变量提升\" class=\"headerlink\" title=\"6. 变量提升\"></a>6. 变量提升</h1><p>JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。</p>\n<p>但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：</p>\n<pre><code>console.log(y);  // 输出undefined\ny = 2; // 初始化y\n上面的代码等价于下面的代码：\n\nvar y;  // 声明y\nconsole.log(y);  // 输出undefined\ny = 2; // 初始化y\n为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。\n</code></pre><h1 id=\"7-柯里化\"><a href=\"#7-柯里化\" class=\"headerlink\" title=\"7. 柯里化\"></a>7. 柯里化</h1><p>柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n<pre><code>var add = function(x) {\n    return function(y) {\n        return x + y;\n    };\n};\nconsole.log(add(1)(1)); // 输出2\nvar add1 = add(1);\nconsole.log(add1(1)); // 输出2\nvar add10 = add(10);\nconsole.log(add10(1)); // 输出11\n代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。\n</code></pre><h1 id=\"8-apply-call与bind方法\"><a href=\"#8-apply-call与bind方法\" class=\"headerlink\" title=\"8. apply, call与bind方法\"></a>8. apply, call与bind方法</h1><p>JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。</p>\n<p>三者之中，call方法是最简单的，它等价于指定this值调用函数：</p>\n<pre><code>var user = {\n    name: &quot;Rahul Mhatre&quot;,\n    whatIsYourName: function() {\n        console.log(this.name);\n    }\n};\nuser.whatIsYourName(); // 输出&quot;Rahul Mhatre&quot;,\nvar user2 = {\n    name: &quot;Neha Sampat&quot;\n};\nuser.whatIsYourName.call(user2); // 输出&quot;Neha Sampat&quot;\n</code></pre><p>apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定：</p>\n<pre><code>apply(thisArg, [argsArray])\ncall(thisArg, arg1, arg2, …)\nvar user = {\n    greet: &quot;Hello!&quot;,\n    greetUser: function(userName) {\n        console.log(this.greet + &quot; &quot; + userName);\n    }\n};\nvar greet1 = {\n    greet: &quot;Hola&quot;\n};\nuser.greetUser.call(greet1, &quot;Rahul&quot;); // 输出&quot;Hola Rahul&quot;\nuser.greetUser.apply(greet1, [&quot;Rahul&quot;]); // 输出&quot;Hola Rahul&quot;\n</code></pre><p>使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：</p>\n<pre><code>var user = {\n     greet: &quot;Hello!&quot;,\n     greetUser: function(userName) {\n     console.log(this.greet + &quot; &quot; + userName);\n     }\n};\nvar greetHola = user.greetUser.bind({greet: &quot;Hola&quot;});\nvar greetBonjour = user.greetUser.bind({greet: &quot;Bonjour&quot;});\ngreetHola(&quot;Rahul&quot;) // 输出&quot;Hola Rahul&quot;\ngreetBonjour(&quot;Rahul&quot;) // 输出&quot;Bonjour Rahul&quot;\n</code></pre><h1 id=\"9-Memoization\"><a href=\"#9-Memoization\" class=\"headerlink\" title=\"9. Memoization\"></a>9. Memoization</h1><p>Memoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。</p>\n<pre><code>function memoizeFunction(func)\n{\n    var cache = {};\n    return function()\n    {\n        var key = arguments[0];\n        if (cache[key])\n        {\n            return cache[key];\n        }\n        else\n        {\n            var val = func.apply(this, arguments);\n            cache[key] = val;\n            return val;\n        }\n    };\n}\nvar fibonacci = memoizeFunction(function(n)\n{\n    return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);\n});\nconsole.log(fibonacci(100)); // 输出354224848179262000000\nconsole.log(fibonacci(100)); // 输出354224848179262000000\n代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。\n</code></pre><h1 id=\"10-函数重载\"><a href=\"#10-函数重载\" class=\"headerlink\" title=\"10. 函数重载\"></a>10. 函数重载</h1><p>所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。</p>\n<p>从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。</p>\n<p>难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。</p>\n<p>由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。</p>\n<p>根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。</p>\n<pre><code>function addMethod(object, name, f)\n{　　\n    var old = object[name];　　\n    object[name] = function()\n    {\n        // f.length为函数定义时的参数个数\n        // arguments.length为函数调用时的参数个数　　　　\n        if (f.length === arguments.length)\n        {　　\n            return f.apply(this, arguments);　　　　\n        }\n        else if (typeof old === &quot;function&quot;)\n        {\n            return old.apply(this, arguments);　　　　\n        }　　\n    };\n}\n// 不传参数时，返回所有name\nfunction find0()\n{　　\n    return this.names;\n}\n// 传一个参数时，返回firstName匹配的name\nfunction find1(firstName)\n{　　\n    var result = [];　　\n    for (var i = 0; i &lt; this.names.length; i++)\n    {　　　　\n        if (this.names[i].indexOf(firstName) === 0)\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}\n// 传两个参数时，返回firstName和lastName都匹配的name\nfunction find2(firstName, lastName)\n{　\n    var result = [];　　\n    for (var i = 0; i &lt; this.names.length; i++)\n    {　　　　\n        if (this.names[i] === (firstName + &quot; &quot; + lastName))\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}\nvar people = {　　\n    names: [&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]\n};\naddMethod(people, &quot;find&quot;, find0);\naddMethod(people, &quot;find&quot;, find1);\naddMethod(people, &quot;find&quot;, find2);\nconsole.log(people.find()); // 输出[&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]\nconsole.log(people.find(&quot;Dean&quot;)); // 输出[&quot;Dean Edwards&quot;, &quot;Dean Tom&quot;]\nconsole.log(people.find(&quot;Dean&quot;, &quot;Edwards&quot;)); // 输出[&quot;Dean Edwards&quot;]\n</code></pre>"},{"title":"JavaScript的一些知识点","date":"2016-10-01T12:16:17.000Z","_content":"# 1.执行上下文：\n\n单线程\n\n同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待\n\n全局上下文只有唯一的一个，它在浏览器关闭时出栈\n\n函数的执行上下文的个数没有限制\n\n每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此\n\n- 创建阶段\n  在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向\n- 代码执行阶段\n  创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。\n  变量对象的创建，依次经历了以下几个过程。\n  1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n  2. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n  3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改.\n\n# 2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\n\n    demo1:\n    function test() {\n        console.log(a);\n        console.log(foo());\n\n        var a = 1;\n        function foo() {\n            return 2;\n        }\n    }\n\n    test();\n\nfunction声明会比var声明优先级更高一点，所以在执行过程中顺序就变成了：\n\n    function test() {\n        function foo() {\n            return 2;\n        }\n        var a;\n        console.log(a);\n        console.log(foo());\n        a = 1;\n    }\n\n    test();\n\n    demo2:\n    function test() {\n        console.log(foo);\n        console.log(bar);\n\n        var foo = 'Hello';\n        console.log(foo);\n        var bar = function () {\n            return 'world';\n        }\n\n        function foo() {\n            return 'hello';\n        }\n    }\n\n    test();//console.log(foo)会打印函数体，console.log(foo())才打印函数执行结果。\n\n\n# 3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\n\n# 4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。\n---\n\n\n\n# 3.闭包：\n\n闭包与作用域链息息相关；\n\n闭包是在函数执行过程中被确认。\n\n闭包的应用场景\n\n接下来，我们来总结下，闭包的常用场景。\n\n延迟函数setTimeout\n\n我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，\n\n      function fn() {\n      console.log('this is test.')\n      }\n      var timer =  setTimeout(fn, 1000);\n      console.log(timer);\n\n\n\n按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。\n\n---\n\n\n\n# 4.this的指向\n\nthis的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。\n\n    var a = 10;\n    var obj = {\n        a: 20\n    }\n\n    function fn () {\n        console.log(this.a);\n    }\n\n    fn(); // 10\n    fn.call(obj); // 20\n\n    var a = 20;\n    var foo = {\n        a: 10,\n        getA: function () {\n            return this.a;\n        }\n    }\n    console.log(foo.getA()); // 10\n\n    var test = foo.getA;\n    console.log(test());  // 20\n\nfoo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。\n\n\n      // demo03\n     var a = 20; \n     var obj = {\n     a: 10,\n     c: this.a + 20,\n\n    fn: function () {\n\n        return this.a;\n\n    }\n    } \n    console.log(obj.c);\n\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。\n\n当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。\n\n# 5.使用call，apply显示指定this\n\nJavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。\n\n如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。\n\n    function fn() {\n        console.log(this.a);\n    }\n    var obj = {\n        a: 20\n    }\n\n    fn.call(obj);\n\n而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。\n\n    function fn(num1, num2) {\n        console.log(this.a + num1 + num2);\n    }\n    var obj = {\n        a: 20\n    }\n\n    fn.call(obj, 100, 10); // 130\n    fn.apply(obj, [20, 10]); // 50\n\n# 6.http协议：\n超文本传输协议(HTTP，HyperText Transfer Protocol)\n\n是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n\n通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如\"HTTP/1.1 200 OK\"，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。\n\nHTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。\n\n通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。\n\n\n请求行和标题必须以<CR><LF> 作为结尾（也就是，回车然后换行）。空行内必须只有<CR><LF>而无其他空格。在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的。\n\n我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。\n\n　　HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以http://开头的原因。\n\n\n\n# 7.ajax:\n\n1.同步：客户端浏览器先发起请求，等待响应，服务器返回响应，客户端才会渲染内容，也就是说客户端每一次发起请求的时候都会把之前的内容删掉，等待服务器给下一次响应\n\n2.异步：客户端有部分可见，发起请求，服务器返回响应，客户端把更新后的内容追加到dom树上，此时客户端和服务器是同时运行的，浏览器在浏览网页的同时服务器会返回新的内容\n\n\t\n原生ajax:\n\t\n\n\tvar xhr = new XMLHttpRequest();\n\txhr.onreadystatechange = function(){\n\tif(xhr.readyState==4&&xhr.status==200){  //响应完成且成功\n\txhr.open（“请求方法”，url，true)\n\txhr.send（null/请求主体）//请求主体（键值对，文件上传，json格式）,get没有请求主体，post要设置头部信息\n\t）\n\t}\n\n\n\n\n\n\n\n\njquery的ajax:\n    $.ajax({\n\n  type:'请求方法'，\n\n  url:'请求地址'，\n\n  data:'请求数据'（可以是对象，或者是键值对的形式），\n\n  success:fn  (成功的回调函数)，\n\n  error:fn,\n\n  beforeSend:fn,  (请求发送之前的回调)，\n\n  complete:fn   (不管成功还是失败都要执行的回调)\n\n})\n\n# 8.跨域问题：\n\n指从一个url上的资源访问另一个url上的资源，这两个资源不在同一个域上，如协议名，域名，端口号不同，这就叫跨域\n\n浏览器哪些情况下允许跨域：\n\n带src和href属性的标签，如srcript,img,link,iframe\n\n所有浏览器都默认禁止xhr对象的跨域请求----处于“同源安全策略”，不允许放在当前的dom树上。\n\n面试题：\n\n我们公司项目项目很大，为了功能上的清晰划分，在static.tedu.cn上放置了所有的静态资源，在data.tedu.cn上放置了所有的动态数据（json格式），请问如何在static.tedu.cn上获取data.tedu.cn/newlist.json上的动态数据？如何绕过浏览器的xhr跨域限制？\n\n答案：1.CORS方案： （跨源的资源共享）cross origin  Resource  Share（适用于自己可以控制动态页面的编写）\n\n在被访问的资源响应中添加如下的头部：\n\n设置一个响应头部（访问控制允许来源）header('Access-Control-Allow-Origin:http://127.0.0.1');\n\n允许从指定的域名发起跨域请求。\n\n2.jsonp方案：JSON with padding,填充式json，是一种使用json数据的手段、方式。\n\n思路：使用动态创建的script标签代替xhr发起异步的请求，获取跨域的数据，在本地的Js中加以处理.\n\n<script async=\"true\" src=\"跨域地址/x.php\"> </script>  //async=true代表异步为真，异步请求\n\n---\n\n    <script>\n    function doResponse(data){\n    处理服务器端返回的data中的数据...\n    }\n\n    </script>\n\n服务器端返回的数据形如：\n\nContent-Type:application/javascript\n\ndoResponse({x:y, a:b});\n\n# 9.jQuery中如何发起jsonp请求？\n\n1.XHR非跨域请求  $.getJSON('xx.php')\n\n2.跨域请求: $.getJSON('跨域地址/x.php?callback=?',function(data){..处理服务器返回的数据})\n\n\n\n\t3.$.ajax({\n\turl:'',\n\n\tdatatype:'jsonp',\n\n\tsuccess:function(data){\n\n         error:function(){}\n         }\n        }) \n\n\n\n\n\n\n\n# 10.html5新特性：\n\n1.新的语义标签，2.增强型表单，3.视频和音频，4.Canvas绘图，svg绘图，5.地理定位，6拖放api,7.webWorker  8.webStorage,webSocket\n\n# 11.函数自执行与块级作用域\n\n在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。\n\n    (function() {\n       // ...\n    })();\n\n一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。\n\n    (function() {\n        // 私有变量\n        var age = 20;\n        var name = 'Tom';\n\n\n        // 私有方法\n        function getName() {\n            return `your name is ` + name;\n        }\n\n\n        // 共有方法\n        function getAge() {\n            return age;\n        }\n\n        // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收\n        window.getAge = getAge;\n    })();\n\n\n\n\n# 12.拖拽的原理\n\n当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系：\n\n    移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置\n\n如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：\n\n    移动后目标元素的位置 = dis + 目标元素的初始位置\n\n通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。\n\n","source":"_posts/post.md","raw":"---\ntitle: JavaScript的一些知识点\ndate: 2016-10-01 20:16:17\ntags:\n---\n# 1.执行上下文：\n\n单线程\n\n同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待\n\n全局上下文只有唯一的一个，它在浏览器关闭时出栈\n\n函数的执行上下文的个数没有限制\n\n每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此\n\n- 创建阶段\n  在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向\n- 代码执行阶段\n  创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。\n  变量对象的创建，依次经历了以下几个过程。\n  1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n  2. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n  3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改.\n\n# 2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\n\n    demo1:\n    function test() {\n        console.log(a);\n        console.log(foo());\n\n        var a = 1;\n        function foo() {\n            return 2;\n        }\n    }\n\n    test();\n\nfunction声明会比var声明优先级更高一点，所以在执行过程中顺序就变成了：\n\n    function test() {\n        function foo() {\n            return 2;\n        }\n        var a;\n        console.log(a);\n        console.log(foo());\n        a = 1;\n    }\n\n    test();\n\n    demo2:\n    function test() {\n        console.log(foo);\n        console.log(bar);\n\n        var foo = 'Hello';\n        console.log(foo);\n        var bar = function () {\n            return 'world';\n        }\n\n        function foo() {\n            return 'hello';\n        }\n    }\n\n    test();//console.log(foo)会打印函数体，console.log(foo())才打印函数执行结果。\n\n\n# 3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\n\n# 4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。\n---\n\n\n\n# 3.闭包：\n\n闭包与作用域链息息相关；\n\n闭包是在函数执行过程中被确认。\n\n闭包的应用场景\n\n接下来，我们来总结下，闭包的常用场景。\n\n延迟函数setTimeout\n\n我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，\n\n      function fn() {\n      console.log('this is test.')\n      }\n      var timer =  setTimeout(fn, 1000);\n      console.log(timer);\n\n\n\n按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。\n\n---\n\n\n\n# 4.this的指向\n\nthis的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。\n\n    var a = 10;\n    var obj = {\n        a: 20\n    }\n\n    function fn () {\n        console.log(this.a);\n    }\n\n    fn(); // 10\n    fn.call(obj); // 20\n\n    var a = 20;\n    var foo = {\n        a: 10,\n        getA: function () {\n            return this.a;\n        }\n    }\n    console.log(foo.getA()); // 10\n\n    var test = foo.getA;\n    console.log(test());  // 20\n\nfoo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。\n\n\n      // demo03\n     var a = 20; \n     var obj = {\n     a: 10,\n     c: this.a + 20,\n\n    fn: function () {\n\n        return this.a;\n\n    }\n    } \n    console.log(obj.c);\n\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。\n\n当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。\n\n# 5.使用call，apply显示指定this\n\nJavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。\n\n如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。\n\n    function fn() {\n        console.log(this.a);\n    }\n    var obj = {\n        a: 20\n    }\n\n    fn.call(obj);\n\n而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。\n\n    function fn(num1, num2) {\n        console.log(this.a + num1 + num2);\n    }\n    var obj = {\n        a: 20\n    }\n\n    fn.call(obj, 100, 10); // 130\n    fn.apply(obj, [20, 10]); // 50\n\n# 6.http协议：\n超文本传输协议(HTTP，HyperText Transfer Protocol)\n\n是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n\n通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如\"HTTP/1.1 200 OK\"，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。\n\nHTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。\n\n通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。\n\n\n请求行和标题必须以<CR><LF> 作为结尾（也就是，回车然后换行）。空行内必须只有<CR><LF>而无其他空格。在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的。\n\n我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。\n\n　　HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以http://开头的原因。\n\n\n\n# 7.ajax:\n\n1.同步：客户端浏览器先发起请求，等待响应，服务器返回响应，客户端才会渲染内容，也就是说客户端每一次发起请求的时候都会把之前的内容删掉，等待服务器给下一次响应\n\n2.异步：客户端有部分可见，发起请求，服务器返回响应，客户端把更新后的内容追加到dom树上，此时客户端和服务器是同时运行的，浏览器在浏览网页的同时服务器会返回新的内容\n\n\t\n原生ajax:\n\t\n\n\tvar xhr = new XMLHttpRequest();\n\txhr.onreadystatechange = function(){\n\tif(xhr.readyState==4&&xhr.status==200){  //响应完成且成功\n\txhr.open（“请求方法”，url，true)\n\txhr.send（null/请求主体）//请求主体（键值对，文件上传，json格式）,get没有请求主体，post要设置头部信息\n\t）\n\t}\n\n\n\n\n\n\n\n\njquery的ajax:\n    $.ajax({\n\n  type:'请求方法'，\n\n  url:'请求地址'，\n\n  data:'请求数据'（可以是对象，或者是键值对的形式），\n\n  success:fn  (成功的回调函数)，\n\n  error:fn,\n\n  beforeSend:fn,  (请求发送之前的回调)，\n\n  complete:fn   (不管成功还是失败都要执行的回调)\n\n})\n\n# 8.跨域问题：\n\n指从一个url上的资源访问另一个url上的资源，这两个资源不在同一个域上，如协议名，域名，端口号不同，这就叫跨域\n\n浏览器哪些情况下允许跨域：\n\n带src和href属性的标签，如srcript,img,link,iframe\n\n所有浏览器都默认禁止xhr对象的跨域请求----处于“同源安全策略”，不允许放在当前的dom树上。\n\n面试题：\n\n我们公司项目项目很大，为了功能上的清晰划分，在static.tedu.cn上放置了所有的静态资源，在data.tedu.cn上放置了所有的动态数据（json格式），请问如何在static.tedu.cn上获取data.tedu.cn/newlist.json上的动态数据？如何绕过浏览器的xhr跨域限制？\n\n答案：1.CORS方案： （跨源的资源共享）cross origin  Resource  Share（适用于自己可以控制动态页面的编写）\n\n在被访问的资源响应中添加如下的头部：\n\n设置一个响应头部（访问控制允许来源）header('Access-Control-Allow-Origin:http://127.0.0.1');\n\n允许从指定的域名发起跨域请求。\n\n2.jsonp方案：JSON with padding,填充式json，是一种使用json数据的手段、方式。\n\n思路：使用动态创建的script标签代替xhr发起异步的请求，获取跨域的数据，在本地的Js中加以处理.\n\n<script async=\"true\" src=\"跨域地址/x.php\"> </script>  //async=true代表异步为真，异步请求\n\n---\n\n    <script>\n    function doResponse(data){\n    处理服务器端返回的data中的数据...\n    }\n\n    </script>\n\n服务器端返回的数据形如：\n\nContent-Type:application/javascript\n\ndoResponse({x:y, a:b});\n\n# 9.jQuery中如何发起jsonp请求？\n\n1.XHR非跨域请求  $.getJSON('xx.php')\n\n2.跨域请求: $.getJSON('跨域地址/x.php?callback=?',function(data){..处理服务器返回的数据})\n\n\n\n\t3.$.ajax({\n\turl:'',\n\n\tdatatype:'jsonp',\n\n\tsuccess:function(data){\n\n         error:function(){}\n         }\n        }) \n\n\n\n\n\n\n\n# 10.html5新特性：\n\n1.新的语义标签，2.增强型表单，3.视频和音频，4.Canvas绘图，svg绘图，5.地理定位，6拖放api,7.webWorker  8.webStorage,webSocket\n\n# 11.函数自执行与块级作用域\n\n在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。\n\n    (function() {\n       // ...\n    })();\n\n一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。\n\n    (function() {\n        // 私有变量\n        var age = 20;\n        var name = 'Tom';\n\n\n        // 私有方法\n        function getName() {\n            return `your name is ` + name;\n        }\n\n\n        // 共有方法\n        function getAge() {\n            return age;\n        }\n\n        // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收\n        window.getAge = getAge;\n    })();\n\n\n\n\n# 12.拖拽的原理\n\n当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系：\n\n    移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置\n\n如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：\n\n    移动后目标元素的位置 = dis + 目标元素的初始位置\n\n通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。\n\n","slug":"post","published":1,"updated":"2017-08-12T10:42:07.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsjh0008ecvjyeokopib","content":"<h1 id=\"1-执行上下文：\"><a href=\"#1-执行上下文：\" class=\"headerlink\" title=\"1.执行上下文：\"></a>1.执行上下文：</h1><p>单线程</p>\n<p>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</p>\n<p>全局上下文只有唯一的一个，它在浏览器关闭时出栈</p>\n<p>函数的执行上下文的个数没有限制</p>\n<p>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此</p>\n<ul>\n<li>创建阶段<br>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向</li>\n<li>代码执行阶段<br>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。<br>变量对象的创建，依次经历了以下几个过程。<ol>\n<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>\n<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改.</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"2-变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\"><a href=\"#2-变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\" class=\"headerlink\" title=\"2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\"></a>2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期</h1><pre><code>demo1:\nfunction test() {\n    console.log(a);\n    console.log(foo());\n\n    var a = 1;\n    function foo() {\n        return 2;\n    }\n}\n\ntest();\n</code></pre><p>function声明会比var声明优先级更高一点，所以在执行过程中顺序就变成了：</p>\n<pre><code>function test() {\n    function foo() {\n        return 2;\n    }\n    var a;\n    console.log(a);\n    console.log(foo());\n    a = 1;\n}\n\ntest();\n\ndemo2:\nfunction test() {\n    console.log(foo);\n    console.log(bar);\n\n    var foo = &apos;Hello&apos;;\n    console.log(foo);\n    var bar = function () {\n        return &apos;world&apos;;\n    }\n\n    function foo() {\n        return &apos;hello&apos;;\n    }\n}\n\ntest();//console.log(foo)会打印函数体，console.log(foo())才打印函数执行结果。\n</code></pre><h1 id=\"3-JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\"><a href=\"#3-JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\" class=\"headerlink\" title=\"3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\"></a>3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建</h1><h1 id=\"4-作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符-变量名或函数名-，这样就可以访问到上一层作用域中的变量了。\"><a href=\"#4-作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符-变量名或函数名-，这样就可以访问到上一层作用域中的变量了。\" class=\"headerlink\" title=\"4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。\"></a>4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。</h1><hr>\n<h1 id=\"3-闭包：\"><a href=\"#3-闭包：\" class=\"headerlink\" title=\"3.闭包：\"></a>3.闭包：</h1><p>闭包与作用域链息息相关；</p>\n<p>闭包是在函数执行过程中被确认。</p>\n<p>闭包的应用场景</p>\n<p>接下来，我们来总结下，闭包的常用场景。</p>\n<p>延迟函数setTimeout</p>\n<p>我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，</p>\n<pre><code>function fn() {\nconsole.log(&apos;this is test.&apos;)\n}\nvar timer =  setTimeout(fn, 1000);\nconsole.log(timer);\n</code></pre><p>按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。</p>\n<hr>\n<h1 id=\"4-this的指向\"><a href=\"#4-this的指向\" class=\"headerlink\" title=\"4.this的指向\"></a>4.this的指向</h1><p>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。</p>\n<pre><code>var a = 10;\nvar obj = {\n    a: 20\n}\n\nfunction fn () {\n    console.log(this.a);\n}\n\nfn(); // 10\nfn.call(obj); // 20\n\nvar a = 20;\nvar foo = {\n    a: 10,\n    getA: function () {\n        return this.a;\n    }\n}\nconsole.log(foo.getA()); // 10\n\nvar test = foo.getA;\nconsole.log(test());  // 20\n</code></pre><p>foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。</p>\n<pre><code>  // demo03\n var a = 20; \n var obj = {\n a: 10,\n c: this.a + 20,\n\nfn: function () {\n\n    return this.a;\n\n}\n} \nconsole.log(obj.c);\n</code></pre><p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>\n<p>当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。</p>\n<h1 id=\"5-使用call，apply显示指定this\"><a href=\"#5-使用call，apply显示指定this\" class=\"headerlink\" title=\"5.使用call，apply显示指定this\"></a>5.使用call，apply显示指定this</h1><p>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。</p>\n<p>如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。</p>\n<pre><code>function fn() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj);\n</code></pre><p>而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。</p>\n<pre><code>function fn(num1, num2) {\n    console.log(this.a + num1 + num2);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj, 100, 10); // 130\nfn.apply(obj, [20, 10]); // 50\n</code></pre><h1 id=\"6-http协议：\"><a href=\"#6-http协议：\" class=\"headerlink\" title=\"6.http协议：\"></a>6.http协议：</h1><p>超文本传输协议(HTTP，HyperText Transfer Protocol)</p>\n<p>是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>\n<p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。</p>\n<p>HTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。</p>\n<p>通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p>\n<p>请求行和标题必须以<cr><lf> 作为结尾（也就是，回车然后换行）。空行内必须只有<cr><lf>而无其他空格。在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的。</lf></cr></lf></cr></p>\n<p>我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。</p>\n<p>　　HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以<a href=\"http://开头的原因。\" target=\"_blank\" rel=\"external\">http://开头的原因。</a></p>\n<h1 id=\"7-ajax\"><a href=\"#7-ajax\" class=\"headerlink\" title=\"7.ajax:\"></a>7.ajax:</h1><p>1.同步：客户端浏览器先发起请求，等待响应，服务器返回响应，客户端才会渲染内容，也就是说客户端每一次发起请求的时候都会把之前的内容删掉，等待服务器给下一次响应</p>\n<p>2.异步：客户端有部分可见，发起请求，服务器返回响应，客户端把更新后的内容追加到dom树上，此时客户端和服务器是同时运行的，浏览器在浏览网页的同时服务器会返回新的内容</p>\n<p>原生ajax:</p>\n<pre><code>var xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function(){\nif(xhr.readyState==4&amp;&amp;xhr.status==200){  //响应完成且成功\nxhr.open（“请求方法”，url，true)\nxhr.send（null/请求主体）//请求主体（键值对，文件上传，json格式）,get没有请求主体，post要设置头部信息\n）\n}\n</code></pre><p>jquery的ajax:<br>    $.ajax({</p>\n<p>  type:’请求方法’，</p>\n<p>  url:’请求地址’，</p>\n<p>  data:’请求数据’（可以是对象，或者是键值对的形式），</p>\n<p>  success:fn  (成功的回调函数)，</p>\n<p>  error:fn,</p>\n<p>  beforeSend:fn,  (请求发送之前的回调)，</p>\n<p>  complete:fn   (不管成功还是失败都要执行的回调)</p>\n<p>})</p>\n<h1 id=\"8-跨域问题：\"><a href=\"#8-跨域问题：\" class=\"headerlink\" title=\"8.跨域问题：\"></a>8.跨域问题：</h1><p>指从一个url上的资源访问另一个url上的资源，这两个资源不在同一个域上，如协议名，域名，端口号不同，这就叫跨域</p>\n<p>浏览器哪些情况下允许跨域：</p>\n<p>带src和href属性的标签，如srcript,img,link,iframe</p>\n<p>所有浏览器都默认禁止xhr对象的跨域请求—-处于“同源安全策略”，不允许放在当前的dom树上。</p>\n<p>面试题：</p>\n<p>我们公司项目项目很大，为了功能上的清晰划分，在static.tedu.cn上放置了所有的静态资源，在data.tedu.cn上放置了所有的动态数据（json格式），请问如何在static.tedu.cn上获取data.tedu.cn/newlist.json上的动态数据？如何绕过浏览器的xhr跨域限制？</p>\n<p>答案：1.CORS方案： （跨源的资源共享）cross origin  Resource  Share（适用于自己可以控制动态页面的编写）</p>\n<p>在被访问的资源响应中添加如下的头部：</p>\n<p>设置一个响应头部（访问控制允许来源）header(‘Access-Control-Allow-Origin:<a href=\"http://127.0.0.1\" target=\"_blank\" rel=\"external\">http://127.0.0.1</a>‘);</p>\n<p>允许从指定的域名发起跨域请求。</p>\n<p>2.jsonp方案：JSON with padding,填充式json，是一种使用json数据的手段、方式。</p>\n<p>思路：使用动态创建的script标签代替xhr发起异步的请求，获取跨域的数据，在本地的Js中加以处理.</p>\n<script async=\"true\" src=\"跨域地址/x.php\"> </script>  //async=true代表异步为真，异步请求\n\n---\n\n    <script>\n    function doResponse(data){\n    处理服务器端返回的data中的数据...\n    }\n\n    </script>\n\n<p>服务器端返回的数据形如：</p>\n<p>Content-Type:application/javascript</p>\n<p>doResponse({x:y, a:b});</p>\n<h1 id=\"9-jQuery中如何发起jsonp请求？\"><a href=\"#9-jQuery中如何发起jsonp请求？\" class=\"headerlink\" title=\"9.jQuery中如何发起jsonp请求？\"></a>9.jQuery中如何发起jsonp请求？</h1><p>1.XHR非跨域请求  $.getJSON(‘xx.php’)</p>\n<p>2.跨域请求: $.getJSON(‘跨域地址/x.php?callback=?’,function(data){..处理服务器返回的数据})</p>\n<pre><code>3.$.ajax({\nurl:&apos;&apos;,\n\ndatatype:&apos;jsonp&apos;,\n\nsuccess:function(data){\n\n     error:function(){}\n     }\n    }) \n</code></pre><h1 id=\"10-html5新特性：\"><a href=\"#10-html5新特性：\" class=\"headerlink\" title=\"10.html5新特性：\"></a>10.html5新特性：</h1><p>1.新的语义标签，2.增强型表单，3.视频和音频，4.Canvas绘图，svg绘图，5.地理定位，6拖放api,7.webWorker  8.webStorage,webSocket</p>\n<h1 id=\"11-函数自执行与块级作用域\"><a href=\"#11-函数自执行与块级作用域\" class=\"headerlink\" title=\"11.函数自执行与块级作用域\"></a>11.函数自执行与块级作用域</h1><p>在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。</p>\n<pre><code>(function() {\n   // ...\n})();\n</code></pre><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p>\n<pre><code>(function() {\n    // 私有变量\n    var age = 20;\n    var name = &apos;Tom&apos;;\n\n\n    // 私有方法\n    function getName() {\n        return `your name is ` + name;\n    }\n\n\n    // 共有方法\n    function getAge() {\n        return age;\n    }\n\n    // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收\n    window.getAge = getAge;\n})();\n</code></pre><h1 id=\"12-拖拽的原理\"><a href=\"#12-拖拽的原理\" class=\"headerlink\" title=\"12.拖拽的原理\"></a>12.拖拽的原理</h1><p>当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系：</p>\n<pre><code>移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置\n</code></pre><p>如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：</p>\n<pre><code>移动后目标元素的位置 = dis + 目标元素的初始位置\n</code></pre><p>通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-执行上下文：\"><a href=\"#1-执行上下文：\" class=\"headerlink\" title=\"1.执行上下文：\"></a>1.执行上下文：</h1><p>单线程</p>\n<p>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</p>\n<p>全局上下文只有唯一的一个，它在浏览器关闭时出栈</p>\n<p>函数的执行上下文的个数没有限制</p>\n<p>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此</p>\n<ul>\n<li>创建阶段<br>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向</li>\n<li>代码执行阶段<br>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。<br>变量对象的创建，依次经历了以下几个过程。<ol>\n<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>\n<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改.</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"2-变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\"><a href=\"#2-变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\" class=\"headerlink\" title=\"2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\"></a>2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期</h1><pre><code>demo1:\nfunction test() {\n    console.log(a);\n    console.log(foo());\n\n    var a = 1;\n    function foo() {\n        return 2;\n    }\n}\n\ntest();\n</code></pre><p>function声明会比var声明优先级更高一点，所以在执行过程中顺序就变成了：</p>\n<pre><code>function test() {\n    function foo() {\n        return 2;\n    }\n    var a;\n    console.log(a);\n    console.log(foo());\n    a = 1;\n}\n\ntest();\n\ndemo2:\nfunction test() {\n    console.log(foo);\n    console.log(bar);\n\n    var foo = &apos;Hello&apos;;\n    console.log(foo);\n    var bar = function () {\n        return &apos;world&apos;;\n    }\n\n    function foo() {\n        return &apos;hello&apos;;\n    }\n}\n\ntest();//console.log(foo)会打印函数体，console.log(foo())才打印函数执行结果。\n</code></pre><h1 id=\"3-JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\"><a href=\"#3-JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\" class=\"headerlink\" title=\"3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\"></a>3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建</h1><h1 id=\"4-作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符-变量名或函数名-，这样就可以访问到上一层作用域中的变量了。\"><a href=\"#4-作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符-变量名或函数名-，这样就可以访问到上一层作用域中的变量了。\" class=\"headerlink\" title=\"4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。\"></a>4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。</h1><hr>\n<h1 id=\"3-闭包：\"><a href=\"#3-闭包：\" class=\"headerlink\" title=\"3.闭包：\"></a>3.闭包：</h1><p>闭包与作用域链息息相关；</p>\n<p>闭包是在函数执行过程中被确认。</p>\n<p>闭包的应用场景</p>\n<p>接下来，我们来总结下，闭包的常用场景。</p>\n<p>延迟函数setTimeout</p>\n<p>我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，</p>\n<pre><code>function fn() {\nconsole.log(&apos;this is test.&apos;)\n}\nvar timer =  setTimeout(fn, 1000);\nconsole.log(timer);\n</code></pre><p>按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。</p>\n<hr>\n<h1 id=\"4-this的指向\"><a href=\"#4-this的指向\" class=\"headerlink\" title=\"4.this的指向\"></a>4.this的指向</h1><p>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。</p>\n<pre><code>var a = 10;\nvar obj = {\n    a: 20\n}\n\nfunction fn () {\n    console.log(this.a);\n}\n\nfn(); // 10\nfn.call(obj); // 20\n\nvar a = 20;\nvar foo = {\n    a: 10,\n    getA: function () {\n        return this.a;\n    }\n}\nconsole.log(foo.getA()); // 10\n\nvar test = foo.getA;\nconsole.log(test());  // 20\n</code></pre><p>foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。</p>\n<pre><code>  // demo03\n var a = 20; \n var obj = {\n a: 10,\n c: this.a + 20,\n\nfn: function () {\n\n    return this.a;\n\n}\n} \nconsole.log(obj.c);\n</code></pre><p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>\n<p>当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。</p>\n<h1 id=\"5-使用call，apply显示指定this\"><a href=\"#5-使用call，apply显示指定this\" class=\"headerlink\" title=\"5.使用call，apply显示指定this\"></a>5.使用call，apply显示指定this</h1><p>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。</p>\n<p>如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。</p>\n<pre><code>function fn() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj);\n</code></pre><p>而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。</p>\n<pre><code>function fn(num1, num2) {\n    console.log(this.a + num1 + num2);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj, 100, 10); // 130\nfn.apply(obj, [20, 10]); // 50\n</code></pre><h1 id=\"6-http协议：\"><a href=\"#6-http协议：\" class=\"headerlink\" title=\"6.http协议：\"></a>6.http协议：</h1><p>超文本传输协议(HTTP，HyperText Transfer Protocol)</p>\n<p>是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>\n<p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。</p>\n<p>HTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。</p>\n<p>通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p>\n<p>请求行和标题必须以<cr><lf> 作为结尾（也就是，回车然后换行）。空行内必须只有<cr><lf>而无其他空格。在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的。</lf></cr></lf></cr></p>\n<p>我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。</p>\n<p>　　HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以<a href=\"http://开头的原因。\" target=\"_blank\" rel=\"external\">http://开头的原因。</a></p>\n<h1 id=\"7-ajax\"><a href=\"#7-ajax\" class=\"headerlink\" title=\"7.ajax:\"></a>7.ajax:</h1><p>1.同步：客户端浏览器先发起请求，等待响应，服务器返回响应，客户端才会渲染内容，也就是说客户端每一次发起请求的时候都会把之前的内容删掉，等待服务器给下一次响应</p>\n<p>2.异步：客户端有部分可见，发起请求，服务器返回响应，客户端把更新后的内容追加到dom树上，此时客户端和服务器是同时运行的，浏览器在浏览网页的同时服务器会返回新的内容</p>\n<p>原生ajax:</p>\n<pre><code>var xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function(){\nif(xhr.readyState==4&amp;&amp;xhr.status==200){  //响应完成且成功\nxhr.open（“请求方法”，url，true)\nxhr.send（null/请求主体）//请求主体（键值对，文件上传，json格式）,get没有请求主体，post要设置头部信息\n）\n}\n</code></pre><p>jquery的ajax:<br>    $.ajax({</p>\n<p>  type:’请求方法’，</p>\n<p>  url:’请求地址’，</p>\n<p>  data:’请求数据’（可以是对象，或者是键值对的形式），</p>\n<p>  success:fn  (成功的回调函数)，</p>\n<p>  error:fn,</p>\n<p>  beforeSend:fn,  (请求发送之前的回调)，</p>\n<p>  complete:fn   (不管成功还是失败都要执行的回调)</p>\n<p>})</p>\n<h1 id=\"8-跨域问题：\"><a href=\"#8-跨域问题：\" class=\"headerlink\" title=\"8.跨域问题：\"></a>8.跨域问题：</h1><p>指从一个url上的资源访问另一个url上的资源，这两个资源不在同一个域上，如协议名，域名，端口号不同，这就叫跨域</p>\n<p>浏览器哪些情况下允许跨域：</p>\n<p>带src和href属性的标签，如srcript,img,link,iframe</p>\n<p>所有浏览器都默认禁止xhr对象的跨域请求—-处于“同源安全策略”，不允许放在当前的dom树上。</p>\n<p>面试题：</p>\n<p>我们公司项目项目很大，为了功能上的清晰划分，在static.tedu.cn上放置了所有的静态资源，在data.tedu.cn上放置了所有的动态数据（json格式），请问如何在static.tedu.cn上获取data.tedu.cn/newlist.json上的动态数据？如何绕过浏览器的xhr跨域限制？</p>\n<p>答案：1.CORS方案： （跨源的资源共享）cross origin  Resource  Share（适用于自己可以控制动态页面的编写）</p>\n<p>在被访问的资源响应中添加如下的头部：</p>\n<p>设置一个响应头部（访问控制允许来源）header(‘Access-Control-Allow-Origin:<a href=\"http://127.0.0.1\" target=\"_blank\" rel=\"external\">http://127.0.0.1</a>‘);</p>\n<p>允许从指定的域名发起跨域请求。</p>\n<p>2.jsonp方案：JSON with padding,填充式json，是一种使用json数据的手段、方式。</p>\n<p>思路：使用动态创建的script标签代替xhr发起异步的请求，获取跨域的数据，在本地的Js中加以处理.</p>\n<script async=\"true\" src=\"跨域地址/x.php\"> </script>  //async=true代表异步为真，异步请求\n\n---\n\n    <script>\n    function doResponse(data){\n    处理服务器端返回的data中的数据...\n    }\n\n    </script>\n\n<p>服务器端返回的数据形如：</p>\n<p>Content-Type:application/javascript</p>\n<p>doResponse({x:y, a:b});</p>\n<h1 id=\"9-jQuery中如何发起jsonp请求？\"><a href=\"#9-jQuery中如何发起jsonp请求？\" class=\"headerlink\" title=\"9.jQuery中如何发起jsonp请求？\"></a>9.jQuery中如何发起jsonp请求？</h1><p>1.XHR非跨域请求  $.getJSON(‘xx.php’)</p>\n<p>2.跨域请求: $.getJSON(‘跨域地址/x.php?callback=?’,function(data){..处理服务器返回的数据})</p>\n<pre><code>3.$.ajax({\nurl:&apos;&apos;,\n\ndatatype:&apos;jsonp&apos;,\n\nsuccess:function(data){\n\n     error:function(){}\n     }\n    }) \n</code></pre><h1 id=\"10-html5新特性：\"><a href=\"#10-html5新特性：\" class=\"headerlink\" title=\"10.html5新特性：\"></a>10.html5新特性：</h1><p>1.新的语义标签，2.增强型表单，3.视频和音频，4.Canvas绘图，svg绘图，5.地理定位，6拖放api,7.webWorker  8.webStorage,webSocket</p>\n<h1 id=\"11-函数自执行与块级作用域\"><a href=\"#11-函数自执行与块级作用域\" class=\"headerlink\" title=\"11.函数自执行与块级作用域\"></a>11.函数自执行与块级作用域</h1><p>在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。</p>\n<pre><code>(function() {\n   // ...\n})();\n</code></pre><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p>\n<pre><code>(function() {\n    // 私有变量\n    var age = 20;\n    var name = &apos;Tom&apos;;\n\n\n    // 私有方法\n    function getName() {\n        return `your name is ` + name;\n    }\n\n\n    // 共有方法\n    function getAge() {\n        return age;\n    }\n\n    // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收\n    window.getAge = getAge;\n})();\n</code></pre><h1 id=\"12-拖拽的原理\"><a href=\"#12-拖拽的原理\" class=\"headerlink\" title=\"12.拖拽的原理\"></a>12.拖拽的原理</h1><p>当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系：</p>\n<pre><code>移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置\n</code></pre><p>如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：</p>\n<pre><code>移动后目标元素的位置 = dis + 目标元素的初始位置\n</code></pre><p>通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。</p>\n"},{"title":"问题汇总","date":"2016-09-01T10:22:06.000Z","_content":"1、描述一下你只做一个网页的工作流程。\n1）根据需求，确定主题。透彻深入所做网站的核心功能和关键。\n2）收集资料。从对比相同类型的网站（惯用而熟悉的样式，用户更乐意接受），参照别人可行的实现方法。\n3）规划网站。抽离出类似的模块和可重用的部件。如果是响应式网站就需要设定断点，根据不同宽度屏幕设定样式。\n4）设计数据库。\n5）搭建基本的框架。引入重置样式表reset.css和字体样式表font.css，风格统一的图标还有后台需要用到的包。\n6）编码和调试。注意统一命名和编码规范。当多人开发时，还需要制定规范文档。\n7）上传测试。利用FTP工具，把网站发布到自己申请的主页存放服务器上。网站上传以后，你要在浏览器中打开自己的网站，逐页逐个链接的进行测试，发现问题，及时修改，然后再上传测试。\n8）推广宣传 。不断宣传，提高网站的访问率和知名度。推广的方法有很多，例如到搜索引擎上注册、与别的网站交换链接、加入广告链等。\n9）维护更新 。网站要注意经常维护更新内容，保持内容的新鲜，不要一做好就放在那儿不变了，只有不断地给它补充新的内容，才能够吸引住浏览者\n\n\n\n2、你如何对网站的文件和资源进行优化？\n\nhttps://segmentfault.com/a/1190000002956639\n\n一共18条，很详细。几乎涵盖所有网站资源优化的内容。\n\n\n\n\n\n3、如何规避JavaScript多人开发函数重名问题？\n\n    闭包，沙箱模式\n    js模块化mvc（数据层、表现层、控制层）\n    seajs（如果了解的呢，可以说）\n    变量转换成对象的属性\n    对象化\n\n\n\n4、请尽可能详尽的解释AJAX的工作原理。\n\nAjax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。\n\nAjax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。\n\n(1).XMLHTTPRequest对象\n\nAjax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。\n\n(2).JavaScript\n\nJavaScript是一在浏览器中大量使用的编程语言。\n\n(3).DOM Document Object Model\n\nDOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，document就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document Object Model）中，DOM提供了网页中各个对象的读写的支持。\n\n(4).XML\n\n可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。\n\n(5).综合\n\nAjax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。\n\nAjax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。\n\n\n\n5、你使用过哪些JavaScript库？\n\njQuery\n\nanimate\n\nBootstrap\n\nzepto\n\nartTemplate\n\nnormalize：它在默认的HTML元素样式上提供了跨浏览器的高度一致性。\n\nSwiper\n\nfullpage：jQuery全屏滚动插件。\n\n了解更多：\n\nhttps://www.evget.com/article/2013/9/22/19657.html\n","source":"_posts/question.md","raw":"---\ntitle: 问题汇总\ndate: 2016-09-01 18:22:06\ntags:\n---\n1、描述一下你只做一个网页的工作流程。\n1）根据需求，确定主题。透彻深入所做网站的核心功能和关键。\n2）收集资料。从对比相同类型的网站（惯用而熟悉的样式，用户更乐意接受），参照别人可行的实现方法。\n3）规划网站。抽离出类似的模块和可重用的部件。如果是响应式网站就需要设定断点，根据不同宽度屏幕设定样式。\n4）设计数据库。\n5）搭建基本的框架。引入重置样式表reset.css和字体样式表font.css，风格统一的图标还有后台需要用到的包。\n6）编码和调试。注意统一命名和编码规范。当多人开发时，还需要制定规范文档。\n7）上传测试。利用FTP工具，把网站发布到自己申请的主页存放服务器上。网站上传以后，你要在浏览器中打开自己的网站，逐页逐个链接的进行测试，发现问题，及时修改，然后再上传测试。\n8）推广宣传 。不断宣传，提高网站的访问率和知名度。推广的方法有很多，例如到搜索引擎上注册、与别的网站交换链接、加入广告链等。\n9）维护更新 。网站要注意经常维护更新内容，保持内容的新鲜，不要一做好就放在那儿不变了，只有不断地给它补充新的内容，才能够吸引住浏览者\n\n\n\n2、你如何对网站的文件和资源进行优化？\n\nhttps://segmentfault.com/a/1190000002956639\n\n一共18条，很详细。几乎涵盖所有网站资源优化的内容。\n\n\n\n\n\n3、如何规避JavaScript多人开发函数重名问题？\n\n    闭包，沙箱模式\n    js模块化mvc（数据层、表现层、控制层）\n    seajs（如果了解的呢，可以说）\n    变量转换成对象的属性\n    对象化\n\n\n\n4、请尽可能详尽的解释AJAX的工作原理。\n\nAjax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。\n\nAjax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。\n\n(1).XMLHTTPRequest对象\n\nAjax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。\n\n(2).JavaScript\n\nJavaScript是一在浏览器中大量使用的编程语言。\n\n(3).DOM Document Object Model\n\nDOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，document就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document Object Model）中，DOM提供了网页中各个对象的读写的支持。\n\n(4).XML\n\n可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。\n\n(5).综合\n\nAjax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。\n\nAjax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。\n\n\n\n5、你使用过哪些JavaScript库？\n\njQuery\n\nanimate\n\nBootstrap\n\nzepto\n\nartTemplate\n\nnormalize：它在默认的HTML元素样式上提供了跨浏览器的高度一致性。\n\nSwiper\n\nfullpage：jQuery全屏滚动插件。\n\n了解更多：\n\nhttps://www.evget.com/article/2013/9/22/19657.html\n","slug":"question","published":1,"updated":"2017-08-12T10:42:07.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsji0009ecvjmdq0kfiu","content":"<p>1、描述一下你只做一个网页的工作流程。<br>1）根据需求，确定主题。透彻深入所做网站的核心功能和关键。<br>2）收集资料。从对比相同类型的网站（惯用而熟悉的样式，用户更乐意接受），参照别人可行的实现方法。<br>3）规划网站。抽离出类似的模块和可重用的部件。如果是响应式网站就需要设定断点，根据不同宽度屏幕设定样式。<br>4）设计数据库。<br>5）搭建基本的框架。引入重置样式表reset.css和字体样式表font.css，风格统一的图标还有后台需要用到的包。<br>6）编码和调试。注意统一命名和编码规范。当多人开发时，还需要制定规范文档。<br>7）上传测试。利用FTP工具，把网站发布到自己申请的主页存放服务器上。网站上传以后，你要在浏览器中打开自己的网站，逐页逐个链接的进行测试，发现问题，及时修改，然后再上传测试。<br>8）推广宣传 。不断宣传，提高网站的访问率和知名度。推广的方法有很多，例如到搜索引擎上注册、与别的网站交换链接、加入广告链等。<br>9）维护更新 。网站要注意经常维护更新内容，保持内容的新鲜，不要一做好就放在那儿不变了，只有不断地给它补充新的内容，才能够吸引住浏览者</p>\n<p>2、你如何对网站的文件和资源进行优化？</p>\n<p><a href=\"https://segmentfault.com/a/1190000002956639\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000002956639</a></p>\n<p>一共18条，很详细。几乎涵盖所有网站资源优化的内容。</p>\n<p>3、如何规避JavaScript多人开发函数重名问题？</p>\n<pre><code>闭包，沙箱模式\njs模块化mvc（数据层、表现层、控制层）\nseajs（如果了解的呢，可以说）\n变量转换成对象的属性\n对象化\n</code></pre><p>4、请尽可能详尽的解释AJAX的工作原理。</p>\n<p>Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p>\n<p>Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。</p>\n<p>(1).XMLHTTPRequest对象</p>\n<p>Ajax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。</p>\n<p>(2).JavaScript</p>\n<p>JavaScript是一在浏览器中大量使用的编程语言。</p>\n<p>(3).DOM Document Object Model</p>\n<p>DOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，document就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document Object Model）中，DOM提供了网页中各个对象的读写的支持。</p>\n<p>(4).XML</p>\n<p>可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。</p>\n<p>(5).综合</p>\n<p>Ajax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。</p>\n<p>Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。</p>\n<p>5、你使用过哪些JavaScript库？</p>\n<p>jQuery</p>\n<p>animate</p>\n<p>Bootstrap</p>\n<p>zepto</p>\n<p>artTemplate</p>\n<p>normalize：它在默认的HTML元素样式上提供了跨浏览器的高度一致性。</p>\n<p>Swiper</p>\n<p>fullpage：jQuery全屏滚动插件。</p>\n<p>了解更多：</p>\n<p><a href=\"https://www.evget.com/article/2013/9/22/19657.html\" target=\"_blank\" rel=\"external\">https://www.evget.com/article/2013/9/22/19657.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1、描述一下你只做一个网页的工作流程。<br>1）根据需求，确定主题。透彻深入所做网站的核心功能和关键。<br>2）收集资料。从对比相同类型的网站（惯用而熟悉的样式，用户更乐意接受），参照别人可行的实现方法。<br>3）规划网站。抽离出类似的模块和可重用的部件。如果是响应式网站就需要设定断点，根据不同宽度屏幕设定样式。<br>4）设计数据库。<br>5）搭建基本的框架。引入重置样式表reset.css和字体样式表font.css，风格统一的图标还有后台需要用到的包。<br>6）编码和调试。注意统一命名和编码规范。当多人开发时，还需要制定规范文档。<br>7）上传测试。利用FTP工具，把网站发布到自己申请的主页存放服务器上。网站上传以后，你要在浏览器中打开自己的网站，逐页逐个链接的进行测试，发现问题，及时修改，然后再上传测试。<br>8）推广宣传 。不断宣传，提高网站的访问率和知名度。推广的方法有很多，例如到搜索引擎上注册、与别的网站交换链接、加入广告链等。<br>9）维护更新 。网站要注意经常维护更新内容，保持内容的新鲜，不要一做好就放在那儿不变了，只有不断地给它补充新的内容，才能够吸引住浏览者</p>\n<p>2、你如何对网站的文件和资源进行优化？</p>\n<p><a href=\"https://segmentfault.com/a/1190000002956639\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000002956639</a></p>\n<p>一共18条，很详细。几乎涵盖所有网站资源优化的内容。</p>\n<p>3、如何规避JavaScript多人开发函数重名问题？</p>\n<pre><code>闭包，沙箱模式\njs模块化mvc（数据层、表现层、控制层）\nseajs（如果了解的呢，可以说）\n变量转换成对象的属性\n对象化\n</code></pre><p>4、请尽可能详尽的解释AJAX的工作原理。</p>\n<p>Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p>\n<p>Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。</p>\n<p>(1).XMLHTTPRequest对象</p>\n<p>Ajax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。</p>\n<p>(2).JavaScript</p>\n<p>JavaScript是一在浏览器中大量使用的编程语言。</p>\n<p>(3).DOM Document Object Model</p>\n<p>DOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，document就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document Object Model）中，DOM提供了网页中各个对象的读写的支持。</p>\n<p>(4).XML</p>\n<p>可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。</p>\n<p>(5).综合</p>\n<p>Ajax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。</p>\n<p>Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。</p>\n<p>5、你使用过哪些JavaScript库？</p>\n<p>jQuery</p>\n<p>animate</p>\n<p>Bootstrap</p>\n<p>zepto</p>\n<p>artTemplate</p>\n<p>normalize：它在默认的HTML元素样式上提供了跨浏览器的高度一致性。</p>\n<p>Swiper</p>\n<p>fullpage：jQuery全屏滚动插件。</p>\n<p>了解更多：</p>\n<p><a href=\"https://www.evget.com/article/2013/9/22/19657.html\" target=\"_blank\" rel=\"external\">https://www.evget.com/article/2013/9/22/19657.html</a></p>\n"},{"title":"JS当中的数组去重、冒泡、快速排序","date":"2016-11-12T09:28:36.000Z","_content":"\n\t## 数组去重：\n\t\n\n\t\t\tvar arr = [1,1,1,2,2,2,3,3,3];\n\t\t\tfunction Array(arr){\n\t\t\t\tvar res= [];\n\t\t\t\tfor(var i=0;i<arr.length;i++){\n\t\t\t\t\tif(res.indexOf(arr[i])==-1){\n\t\t\t\t\t\tres.push(arr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(res);\n\t\t\t}\n\t\t\tArray(arr);\n\n\t\n\t\n\n\t  ## 快速排序 ：\n\t　　（1）在数据集之中，找一个基准点  \n\t　　（2）建立两个数组，分别存储左边和右边的数组  \n\t　　（3）利用递归进行下次比较 \n\n\t \n\t\t      \n\t\tfunction quickSort(arr){\n\t\t\tif(arr.length<=1){return arr;}如果数组只有一个数，就直接返回；\n\t\t\tvar num = Math.floor(arr.length/2);找到中间数的索引值，如果是浮点数，则向下取整\n\t\t\tvar newValue = arr.splice(num,1);找到中间数的值 \n\t\t\tvar left=[],right=[];\n\t\t\tfor(var i=0;i<arr.length;i++){\n\t\t\t\tif(arr[i]<newValue){\n\t\t\t\t\tleft.push(arr[i]);\t基准点的左边的数传到左边数组\n\t\t\t\t}else{\n\t\t\t\t\tright.push(arr[i]);基准点的右边的数传到右边数组\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn quickSort(left).concat(newValue,quickSort(right));递归不断重复比较\n\t\t\n\t\t}\n\t\tconsole.log(quickSort([1,3,4,5,6,2]));\n\n\t\n\t\n\t## 冒泡排序：\n\t\n\t　　随便从数组中拿一位数和后一位比较，如果是想从小到大排序，那么就把小的那一位放到前面，大的放在后面，简单来说就是交换它们的位置，如此反复的交换位置就可以得到排序的效果。\n\t \n\t \n\tvar arr = [3,1,4,2,5,21,6,15,63];\n\t\n\tfunction sortA(arr){\n\t    for(var i=0;i<arr.length-1;i++){\n\t    \t因为一次循环只能交换一个最大的值，所以需要再套一层for循环。\n\t        for(var j=i+1;j<arr.length;j++){\n\t                      获取第一个值和后一个值比较\n\t            var cur = arr[i];\n\t            if(cur>arr[j]){\n\t                       因为需要交换值，所以会把后一个值替换，我们要先保存下来\n\t                var index = arr[j];\n\t                        交换值\n\t                arr[j] = cur;\n\t                arr[i] = index;\n\t            }\n\t        }\n\t    }\n\t    return arr;\n\t}\n\tconsole.log(sortA(arr));\n\t\n","source":"_posts/sort.md","raw":"---\ntitle: JS当中的数组去重、冒泡、快速排序\ndate: 2016-11-12 17:28:36\ntags:\n---\n\n\t## 数组去重：\n\t\n\n\t\t\tvar arr = [1,1,1,2,2,2,3,3,3];\n\t\t\tfunction Array(arr){\n\t\t\t\tvar res= [];\n\t\t\t\tfor(var i=0;i<arr.length;i++){\n\t\t\t\t\tif(res.indexOf(arr[i])==-1){\n\t\t\t\t\t\tres.push(arr[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconsole.log(res);\n\t\t\t}\n\t\t\tArray(arr);\n\n\t\n\t\n\n\t  ## 快速排序 ：\n\t　　（1）在数据集之中，找一个基准点  \n\t　　（2）建立两个数组，分别存储左边和右边的数组  \n\t　　（3）利用递归进行下次比较 \n\n\t \n\t\t      \n\t\tfunction quickSort(arr){\n\t\t\tif(arr.length<=1){return arr;}如果数组只有一个数，就直接返回；\n\t\t\tvar num = Math.floor(arr.length/2);找到中间数的索引值，如果是浮点数，则向下取整\n\t\t\tvar newValue = arr.splice(num,1);找到中间数的值 \n\t\t\tvar left=[],right=[];\n\t\t\tfor(var i=0;i<arr.length;i++){\n\t\t\t\tif(arr[i]<newValue){\n\t\t\t\t\tleft.push(arr[i]);\t基准点的左边的数传到左边数组\n\t\t\t\t}else{\n\t\t\t\t\tright.push(arr[i]);基准点的右边的数传到右边数组\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn quickSort(left).concat(newValue,quickSort(right));递归不断重复比较\n\t\t\n\t\t}\n\t\tconsole.log(quickSort([1,3,4,5,6,2]));\n\n\t\n\t\n\t## 冒泡排序：\n\t\n\t　　随便从数组中拿一位数和后一位比较，如果是想从小到大排序，那么就把小的那一位放到前面，大的放在后面，简单来说就是交换它们的位置，如此反复的交换位置就可以得到排序的效果。\n\t \n\t \n\tvar arr = [3,1,4,2,5,21,6,15,63];\n\t\n\tfunction sortA(arr){\n\t    for(var i=0;i<arr.length-1;i++){\n\t    \t因为一次循环只能交换一个最大的值，所以需要再套一层for循环。\n\t        for(var j=i+1;j<arr.length;j++){\n\t                      获取第一个值和后一个值比较\n\t            var cur = arr[i];\n\t            if(cur>arr[j]){\n\t                       因为需要交换值，所以会把后一个值替换，我们要先保存下来\n\t                var index = arr[j];\n\t                        交换值\n\t                arr[j] = cur;\n\t                arr[i] = index;\n\t            }\n\t        }\n\t    }\n\t    return arr;\n\t}\n\tconsole.log(sortA(arr));\n\t\n","slug":"sort","published":1,"updated":"2017-08-12T09:54:50.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsjp000aecvjs7w1vzmh","content":"<pre><code>## 数组去重：\n\n\n        var arr = [1,1,1,2,2,2,3,3,3];\n        function Array(arr){\n            var res= [];\n            for(var i=0;i&lt;arr.length;i++){\n                if(res.indexOf(arr[i])==-1){\n                    res.push(arr[i]);\n                }\n            }\n            console.log(res);\n        }\n        Array(arr);\n\n\n\n\n  ## 快速排序 ：\n　　（1）在数据集之中，找一个基准点  \n　　（2）建立两个数组，分别存储左边和右边的数组  \n　　（3）利用递归进行下次比较 \n\n\n\n    function quickSort(arr){\n        if(arr.length&lt;=1){return arr;}如果数组只有一个数，就直接返回；\n        var num = Math.floor(arr.length/2);找到中间数的索引值，如果是浮点数，则向下取整\n        var newValue = arr.splice(num,1);找到中间数的值 \n        var left=[],right=[];\n        for(var i=0;i&lt;arr.length;i++){\n            if(arr[i]&lt;newValue){\n                left.push(arr[i]);    基准点的左边的数传到左边数组\n            }else{\n                right.push(arr[i]);基准点的右边的数传到右边数组\n            }\n        }\n        return quickSort(left).concat(newValue,quickSort(right));递归不断重复比较\n\n    }\n    console.log(quickSort([1,3,4,5,6,2]));\n\n\n\n## 冒泡排序：\n\n　　随便从数组中拿一位数和后一位比较，如果是想从小到大排序，那么就把小的那一位放到前面，大的放在后面，简单来说就是交换它们的位置，如此反复的交换位置就可以得到排序的效果。\n\n\nvar arr = [3,1,4,2,5,21,6,15,63];\n\nfunction sortA(arr){\n    for(var i=0;i&lt;arr.length-1;i++){\n        因为一次循环只能交换一个最大的值，所以需要再套一层for循环。\n        for(var j=i+1;j&lt;arr.length;j++){\n                      获取第一个值和后一个值比较\n            var cur = arr[i];\n            if(cur&gt;arr[j]){\n                       因为需要交换值，所以会把后一个值替换，我们要先保存下来\n                var index = arr[j];\n                        交换值\n                arr[j] = cur;\n                arr[i] = index;\n            }\n        }\n    }\n    return arr;\n}\nconsole.log(sortA(arr));\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>## 数组去重：\n\n\n        var arr = [1,1,1,2,2,2,3,3,3];\n        function Array(arr){\n            var res= [];\n            for(var i=0;i&lt;arr.length;i++){\n                if(res.indexOf(arr[i])==-1){\n                    res.push(arr[i]);\n                }\n            }\n            console.log(res);\n        }\n        Array(arr);\n\n\n\n\n  ## 快速排序 ：\n　　（1）在数据集之中，找一个基准点  \n　　（2）建立两个数组，分别存储左边和右边的数组  \n　　（3）利用递归进行下次比较 \n\n\n\n    function quickSort(arr){\n        if(arr.length&lt;=1){return arr;}如果数组只有一个数，就直接返回；\n        var num = Math.floor(arr.length/2);找到中间数的索引值，如果是浮点数，则向下取整\n        var newValue = arr.splice(num,1);找到中间数的值 \n        var left=[],right=[];\n        for(var i=0;i&lt;arr.length;i++){\n            if(arr[i]&lt;newValue){\n                left.push(arr[i]);    基准点的左边的数传到左边数组\n            }else{\n                right.push(arr[i]);基准点的右边的数传到右边数组\n            }\n        }\n        return quickSort(left).concat(newValue,quickSort(right));递归不断重复比较\n\n    }\n    console.log(quickSort([1,3,4,5,6,2]));\n\n\n\n## 冒泡排序：\n\n　　随便从数组中拿一位数和后一位比较，如果是想从小到大排序，那么就把小的那一位放到前面，大的放在后面，简单来说就是交换它们的位置，如此反复的交换位置就可以得到排序的效果。\n\n\nvar arr = [3,1,4,2,5,21,6,15,63];\n\nfunction sortA(arr){\n    for(var i=0;i&lt;arr.length-1;i++){\n        因为一次循环只能交换一个最大的值，所以需要再套一层for循环。\n        for(var j=i+1;j&lt;arr.length;j++){\n                      获取第一个值和后一个值比较\n            var cur = arr[i];\n            if(cur&gt;arr[j]){\n                       因为需要交换值，所以会把后一个值替换，我们要先保存下来\n                var index = arr[j];\n                        交换值\n                arr[j] = cur;\n                arr[i] = index;\n            }\n        }\n    }\n    return arr;\n}\nconsole.log(sortA(arr));\n</code></pre>"},{"title":"js的几种跨越实现","date":"2017-05-13T14:01:51.000Z","_content":"# js中几种实用的跨域方法原理详解\n这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，\n比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。\n只要协议、域名、端口有任何一个不同，都被当作是不同的域。\n\n\n跨域资源共享（CORS）\n\nCORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。\n\n<script type=\"text/javascript\">\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"￼GET\", \"/trigkit4\",true);\n    xhr.send();\n</script>\n以上的trigkit4是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：\n\n<script type=\"text/javascript\">\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"￼GET\", \"http://segmentfault.com/u/trigkit4/\",true);\n    xhr.send();\n</script>\n代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。\n\n服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。\n\n要解决跨域的问题，我们可以使用以下几种方法：\n\n# 通过jsonp跨域\n\n现在问题来了？什么是jsonp？维基百科的定义是：JSONP（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。\n\nJSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如：\n\ncallback({\"name\",\"trigkit4\"});\nJSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。\n\n在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：\n\n<script type=\"text/javascript\">\n    function dosomething(jsondata){\n        //处理获得的json数据\n    }\n</script>\n<script src=\"http://example.com/data.php?callback=dosomething\"></script>\njs文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。\n\n    <?php\n    $callback = $_GET['callback'];//得到回调函数名\n    $data = array('a','b','c');//要返回的数据\n    echo $callback.'('.json_encode($data).')';//输出\n    ?>\n最终，输出结果为：dosomething(['a','b','c']);\n\n如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。\n\n<script type=\"text/javascript\">\n    $.getJSON('http://example.com/data.php?callback=?,function(jsondata)'){\n        //处理获得的json数据\n    });\n</script>\njquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。\n\n# JSONP的优缺点\n\nJSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。\n\nJSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。\n\nCORS和JSONP对比\n\nCORS与JSONP相比，无疑更为先进、方便和可靠。\n\n    1、 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。\n\n    2、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。\n\n    3、 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。\n# 通过修改document.domain来跨子域\n\n浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。\n不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是http://www.example.com/a.html ， 在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：\n\n<script type=\"text/javascript\">\n    function test(){\n        var iframe = document.getElementById('￼ifame');\n        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的\n        var doc = win.document;//这里获取不到iframe里的document对象\n        var name = win.name;//这里同样获取不到window对象的name属性\n    }\n</script>\n<iframe id = \"iframe\" src=\"http://example.com/b.html\" onload = \"test()\"></iframe>\n这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\n\n1.在页面 http://www.example.com/a.html 中设置document.domain:\n\n<iframe id = \"iframe\" src=\"http://example.com/b.html\" onload = \"test()\"></iframe>\n<script type=\"text/javascript\">\n    document.domain = 'example.com';//设置成主域\n    function test(){\n        alert(document.getElementById('￼iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象\n    }\n</script>\n2.在页面 http://example.com/b.html 中也设置document.domain:\n\n<script type=\"text/javascript\">\n    document.domain = 'example.com';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同\n</script>\n修改document.domain的方法只适用于不同子域的框架间的交互。\n\n# 使用window.name来进行跨域\n\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,\n窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，\nwindow.name是持久存在一个窗口载入过的所有页面中的\n\n# 使用HTML5的window.postMessage方法跨域\n\nwindow.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。\n\n结语：\n\n除了以上几种方法外，还有flash、在服务器上设置代理页面等跨域方式，这里就不做介绍了。\n\n以上四种方法，可以根据项目的实际情况来进行选择应用，个人认为window.name的方法既不复杂，\n也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。","source":"_posts/yu.md","raw":"---\ntitle: js的几种跨越实现\ndate: 2017-05-13 22:01:51\ntags:\n---\n# js中几种实用的跨域方法原理详解\n这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，\n比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。\n只要协议、域名、端口有任何一个不同，都被当作是不同的域。\n\n\n跨域资源共享（CORS）\n\nCORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。\n\n<script type=\"text/javascript\">\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"￼GET\", \"/trigkit4\",true);\n    xhr.send();\n</script>\n以上的trigkit4是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：\n\n<script type=\"text/javascript\">\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"￼GET\", \"http://segmentfault.com/u/trigkit4/\",true);\n    xhr.send();\n</script>\n代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。\n\n服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。\n\n要解决跨域的问题，我们可以使用以下几种方法：\n\n# 通过jsonp跨域\n\n现在问题来了？什么是jsonp？维基百科的定义是：JSONP（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。\n\nJSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如：\n\ncallback({\"name\",\"trigkit4\"});\nJSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。\n\n在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：\n\n<script type=\"text/javascript\">\n    function dosomething(jsondata){\n        //处理获得的json数据\n    }\n</script>\n<script src=\"http://example.com/data.php?callback=dosomething\"></script>\njs文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。\n\n    <?php\n    $callback = $_GET['callback'];//得到回调函数名\n    $data = array('a','b','c');//要返回的数据\n    echo $callback.'('.json_encode($data).')';//输出\n    ?>\n最终，输出结果为：dosomething(['a','b','c']);\n\n如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。\n\n<script type=\"text/javascript\">\n    $.getJSON('http://example.com/data.php?callback=?,function(jsondata)'){\n        //处理获得的json数据\n    });\n</script>\njquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。\n\n# JSONP的优缺点\n\nJSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。\n\nJSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。\n\nCORS和JSONP对比\n\nCORS与JSONP相比，无疑更为先进、方便和可靠。\n\n    1、 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。\n\n    2、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。\n\n    3、 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。\n# 通过修改document.domain来跨子域\n\n浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。\n不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是http://www.example.com/a.html ， 在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：\n\n<script type=\"text/javascript\">\n    function test(){\n        var iframe = document.getElementById('￼ifame');\n        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的\n        var doc = win.document;//这里获取不到iframe里的document对象\n        var name = win.name;//这里同样获取不到window对象的name属性\n    }\n</script>\n<iframe id = \"iframe\" src=\"http://example.com/b.html\" onload = \"test()\"></iframe>\n这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\n\n1.在页面 http://www.example.com/a.html 中设置document.domain:\n\n<iframe id = \"iframe\" src=\"http://example.com/b.html\" onload = \"test()\"></iframe>\n<script type=\"text/javascript\">\n    document.domain = 'example.com';//设置成主域\n    function test(){\n        alert(document.getElementById('￼iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象\n    }\n</script>\n2.在页面 http://example.com/b.html 中也设置document.domain:\n\n<script type=\"text/javascript\">\n    document.domain = 'example.com';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同\n</script>\n修改document.domain的方法只适用于不同子域的框架间的交互。\n\n# 使用window.name来进行跨域\n\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,\n窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，\nwindow.name是持久存在一个窗口载入过的所有页面中的\n\n# 使用HTML5的window.postMessage方法跨域\n\nwindow.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。\n\n结语：\n\n除了以上几种方法外，还有flash、在服务器上设置代理页面等跨域方式，这里就不做介绍了。\n\n以上四种方法，可以根据项目的实际情况来进行选择应用，个人认为window.name的方法既不复杂，\n也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。","slug":"yu","published":1,"updated":"2017-08-13T14:17:24.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsjq000becvjsxm1jifl","content":"<h1 id=\"js中几种实用的跨域方法原理详解\"><a href=\"#js中几种实用的跨域方法原理详解\" class=\"headerlink\" title=\"js中几种实用的跨域方法原理详解\"></a>js中几种实用的跨域方法原理详解</h1><p>这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，<br>比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。<br>只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p>\n<p>跨域资源共享（CORS）</p>\n<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>\n<p><script type=\"text/javascript\"><br>    var xhr = new XMLHttpRequest();<br>    xhr.open(“￼GET”, “/trigkit4”,true);<br>    xhr.send();<br></script><br>以上的trigkit4是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>\n<p><script type=\"text/javascript\"><br>    var xhr = new XMLHttpRequest();<br>    xhr.open(“￼GET”, “<a href=\"http://segmentfault.com/u/trigkit4/&quot;,true\">http://segmentfault.com/u/trigkit4/&quot;,true</a>);<br>    xhr.send();<br></script><br>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>\n<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>\n<p>要解决跨域的问题，我们可以使用以下几种方法：</p>\n<h1 id=\"通过jsonp跨域\"><a href=\"#通过jsonp跨域\" class=\"headerlink\" title=\"通过jsonp跨域\"></a>通过jsonp跨域</h1><p>现在问题来了？什么是jsonp？维基百科的定义是：JSONP（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。</p>\n<p>JSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如：</p>\n<p>callback({“name”,”trigkit4”});<br>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>\n<p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：</p>\n<p><script type=\"text/javascript\"><br>    function dosomething(jsondata){<br>        //处理获得的json数据<br>    }<br></script></p>\n<p><script src=\"http://example.com/data.php?callback=dosomething\"></script><br>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。</p>\n<pre><code>&lt;?php\n$callback = $_GET[&apos;callback&apos;];//得到回调函数名\n$data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);//要返回的数据\necho $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;;//输出\n?&gt;\n</code></pre><p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);</p>\n<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。</p>\n<p><script type=\"text/javascript\"><br>    $.getJSON(‘<a href=\"http://example.com/data.php?callback=?,function(jsondata)&#39;){\">http://example.com/data.php?callback=?,function(jsondata)&#39;){</a><br>        //处理获得的json数据<br>    });<br></script><br>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>\n<h1 id=\"JSONP的优缺点\"><a href=\"#JSONP的优缺点\" class=\"headerlink\" title=\"JSONP的优缺点\"></a>JSONP的优缺点</h1><p>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</p>\n<p>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</p>\n<p>CORS和JSONP对比</p>\n<p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p>\n<pre><code>1、 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。\n\n2、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。\n\n3、 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。\n</code></pre><h1 id=\"通过修改document-domain来跨子域\"><a href=\"#通过修改document-domain来跨子域\" class=\"headerlink\" title=\"通过修改document.domain来跨子域\"></a>通过修改document.domain来跨子域</h1><p>浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。<br>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"external\">http://www.example.com/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href=\"http://example.com/b.html\" target=\"_blank\" rel=\"external\">http://example.com/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>\n<p><script type=\"text/javascript\"><br>    function test(){<br>        var iframe = document.getElementById(‘￼ifame’);<br>        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的<br>        var doc = win.document;//这里获取不到iframe里的document对象<br>        var name = win.name;//这里同样获取不到window对象的name属性<br>    }<br></script></p>\n<p><iframe id=\"iframe\" src=\"http://example.com/b.html\" onload=\"test()\"></iframe><br>这个时候，document.domain就可以派上用场了，我们只要把<a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"external\">http://www.example.com/a.html</a> 和<a href=\"http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\" target=\"_blank\" rel=\"external\">http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</a></p>\n<p>1.在页面 <a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"external\">http://www.example.com/a.html</a> 中设置document.domain:</p>\n<p><iframe id=\"iframe\" src=\"http://example.com/b.html\" onload=\"test()\"></iframe></p>\n<p><script type=\"text/javascript\"><br>    document.domain = ‘example.com’;//设置成主域<br>    function test(){<br>        alert(document.getElementById(‘￼iframe’).contentWindow);//contentWindow 可取得子窗口的 window 对象<br>    }<br></script><br>2.在页面 <a href=\"http://example.com/b.html\" target=\"_blank\" rel=\"external\">http://example.com/b.html</a> 中也设置document.domain:</p>\n<p><script type=\"text/javascript\"><br>    document.domain = ‘example.com’;//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同<br></script><br>修改document.domain的方法只适用于不同子域的框架间的交互。</p>\n<h1 id=\"使用window-name来进行跨域\"><a href=\"#使用window-name来进行跨域\" class=\"headerlink\" title=\"使用window.name来进行跨域\"></a>使用window.name来进行跨域</h1><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,<br>窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，<br>window.name是持久存在一个窗口载入过的所有页面中的</p>\n<h1 id=\"使用HTML5的window-postMessage方法跨域\"><a href=\"#使用HTML5的window-postMessage方法跨域\" class=\"headerlink\" title=\"使用HTML5的window.postMessage方法跨域\"></a>使用HTML5的window.postMessage方法跨域</h1><p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p>\n<p>结语：</p>\n<p>除了以上几种方法外，还有flash、在服务器上设置代理页面等跨域方式，这里就不做介绍了。</p>\n<p>以上四种方法，可以根据项目的实际情况来进行选择应用，个人认为window.name的方法既不复杂，<br>也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"js中几种实用的跨域方法原理详解\"><a href=\"#js中几种实用的跨域方法原理详解\" class=\"headerlink\" title=\"js中几种实用的跨域方法原理详解\"></a>js中几种实用的跨域方法原理详解</h1><p>这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，<br>比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。<br>只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p>\n<p>跨域资源共享（CORS）</p>\n<p>CORS（Cross-Origin Resource Sharing）跨域资源共享，定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>\n<p><script type=\"text/javascript\"><br>    var xhr = new XMLHttpRequest();<br>    xhr.open(“￼GET”, “/trigkit4”,true);<br>    xhr.send();<br></script><br>以上的trigkit4是相对路径，如果我们要使用CORS，相关Ajax代码可能如下所示：</p>\n<p><script type=\"text/javascript\"><br>    var xhr = new XMLHttpRequest();<br>    xhr.open(“￼GET”, “<a href=\"http://segmentfault.com/u/trigkit4/&quot;,true\">http://segmentfault.com/u/trigkit4/&quot;,true</a>);<br>    xhr.send();<br></script><br>代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址。</p>\n<p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>\n<p>要解决跨域的问题，我们可以使用以下几种方法：</p>\n<h1 id=\"通过jsonp跨域\"><a href=\"#通过jsonp跨域\" class=\"headerlink\" title=\"通过jsonp跨域\"></a>通过jsonp跨域</h1><p>现在问题来了？什么是jsonp？维基百科的定义是：JSONP（JSON with Padding）是资料格式 JSON 的一种“使用模式”，可以让网页从别的网域要资料。</p>\n<p>JSONP也叫填充式JSON，是应用JSON的一种新方法，只不过是被包含在函数调用中的JSON，例如：</p>\n<p>callback({“name”,”trigkit4”});<br>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>\n<p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 例如：</p>\n<p><script type=\"text/javascript\"><br>    function dosomething(jsondata){<br>        //处理获得的json数据<br>    }<br></script></p>\n<p><script src=\"http://example.com/data.php?callback=dosomething\"></script><br>js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。</p>\n<pre><code>&lt;?php\n$callback = $_GET[&apos;callback&apos;];//得到回调函数名\n$data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);//要返回的数据\necho $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;;//输出\n?&gt;\n</code></pre><p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);</p>\n<p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。</p>\n<p><script type=\"text/javascript\"><br>    $.getJSON(‘<a href=\"http://example.com/data.php?callback=?,function(jsondata)&#39;){\">http://example.com/data.php?callback=?,function(jsondata)&#39;){</a><br>        //处理获得的json数据<br>    });<br></script><br>jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p>\n<h1 id=\"JSONP的优缺点\"><a href=\"#JSONP的优缺点\" class=\"headerlink\" title=\"JSONP的优缺点\"></a>JSONP的优缺点</h1><p>JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。</p>\n<p>JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</p>\n<p>CORS和JSONP对比</p>\n<p>CORS与JSONP相比，无疑更为先进、方便和可靠。</p>\n<pre><code>1、 JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求。\n\n2、 使用CORS，开发者可以使用普通的XMLHttpRequest发起请求和获得数据，比起JSONP有更好的错误处理。\n\n3、 JSONP主要被老的浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS）。\n</code></pre><h1 id=\"通过修改document-domain来跨子域\"><a href=\"#通过修改document-domain来跨子域\" class=\"headerlink\" title=\"通过修改document.domain来跨子域\"></a>通过修改document.domain来跨子域</h1><p>浏览器都有一个同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。<br>不同的框架之间是可以获取window对象的，但却无法获取相应的属性和方法。比如，有一个页面，它的地址是<a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"external\">http://www.example.com/a.html</a> ， 在这个页面里面有一个iframe，它的src是<a href=\"http://example.com/b.html\" target=\"_blank\" rel=\"external\">http://example.com/b.html</a>, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的：</p>\n<p><script type=\"text/javascript\"><br>    function test(){<br>        var iframe = document.getElementById(‘￼ifame’);<br>        var win = document.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的<br>        var doc = win.document;//这里获取不到iframe里的document对象<br>        var name = win.name;//这里同样获取不到window对象的name属性<br>    }<br></script></p>\n<p><iframe id=\"iframe\" src=\"http://example.com/b.html\" onload=\"test()\"></iframe><br>这个时候，document.domain就可以派上用场了，我们只要把<a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"external\">http://www.example.com/a.html</a> 和<a href=\"http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\" target=\"_blank\" rel=\"external\">http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</a></p>\n<p>1.在页面 <a href=\"http://www.example.com/a.html\" target=\"_blank\" rel=\"external\">http://www.example.com/a.html</a> 中设置document.domain:</p>\n<p><iframe id=\"iframe\" src=\"http://example.com/b.html\" onload=\"test()\"></iframe></p>\n<p><script type=\"text/javascript\"><br>    document.domain = ‘example.com’;//设置成主域<br>    function test(){<br>        alert(document.getElementById(‘￼iframe’).contentWindow);//contentWindow 可取得子窗口的 window 对象<br>    }<br></script><br>2.在页面 <a href=\"http://example.com/b.html\" target=\"_blank\" rel=\"external\">http://example.com/b.html</a> 中也设置document.domain:</p>\n<p><script type=\"text/javascript\"><br>    document.domain = ‘example.com’;//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同<br></script><br>修改document.domain的方法只适用于不同子域的框架间的交互。</p>\n<h1 id=\"使用window-name来进行跨域\"><a href=\"#使用window-name来进行跨域\" class=\"headerlink\" title=\"使用window.name来进行跨域\"></a>使用window.name来进行跨域</h1><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,<br>窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，<br>window.name是持久存在一个窗口载入过的所有页面中的</p>\n<h1 id=\"使用HTML5的window-postMessage方法跨域\"><a href=\"#使用HTML5的window-postMessage方法跨域\" class=\"headerlink\" title=\"使用HTML5的window.postMessage方法跨域\"></a>使用HTML5的window.postMessage方法跨域</h1><p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。</p>\n<p>结语：</p>\n<p>除了以上几种方法外，还有flash、在服务器上设置代理页面等跨域方式，这里就不做介绍了。</p>\n<p>以上四种方法，可以根据项目的实际情况来进行选择应用，个人认为window.name的方法既不复杂，<br>也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p>\n"},{"title":"立志：有志者，事竟成","date":"2016-08-02T11:03:11.000Z","_content":"立志：有志者，事竟成\n\n阳明说，“志不立，天下无可成之事。”朱熹也说，“为学须先立志。志既立，则学问可次第着力。立志不定，终不济事。”\n\n立志就是《大学》上讲的“知止”。所谓“知止而后有定”，立志就是知道你人生的终极目的是什么，用以终为始的思维开始你的奋斗历程。王阳明自己，从少年之时便立下志向，要像朱子那样成为圣人。 来贵州龙场前，王阳明已经年近不惑，刻苦求学了将近三十年。对于立志这件事，近三十年来王阳明自己深有体会，一个人如果没有确立自己的志向，就好像船没有了舵、马没有了缰绳，于是只能随波飘荡、四处奔逸，人生不知所终。\n\n立志者，为学之心也；为学者，立志之事也。\n\n在阳明这里，立志是学习的动力，学习是实现志向的过程。然而，人的志向有高有低，有善也有恶。阳明这里讲的立志，其实是在导人向善，要大家立一个真切为善之志，为君子之志。\n\n也就是说，在确立自己的志向之时，你要清楚自己所立的志向是君子之志还是小人之志。王阳明说，“立志成为圣人，就会成为圣人；立志成为贤人，就会成为贤人。”因此，无论你做什么，立志是首要的事情。\n\n另外，阳明讲“立志贵专一”。今日立一志，明日立一志，不会有任何成就。正所谓，有志者立长志，无志者常立志。王阳明打了一个比喻，立志就像种树，立下志向后，犹如在心中种下了一颗根苗，只管去浇灌它，总有一天这颗根苗会长成参天大树，而不要去想什么时候才能开花结果，多想无益。只要你坚定不移地朝着自己的志向奋斗，就一定会见到自己浇灌出来的丰富果实。\n\n\n\n\n\n作者：未晓研心\n\n链接：http://www.jianshu.com/p/d10a1821c479\n\n來源：简书\n\n\n\n\n","source":"_posts/zhixiang.md","raw":"---\ntitle: 立志：有志者，事竟成\ndate: 2016-08-02 19:03:11\ntags:\n---\n立志：有志者，事竟成\n\n阳明说，“志不立，天下无可成之事。”朱熹也说，“为学须先立志。志既立，则学问可次第着力。立志不定，终不济事。”\n\n立志就是《大学》上讲的“知止”。所谓“知止而后有定”，立志就是知道你人生的终极目的是什么，用以终为始的思维开始你的奋斗历程。王阳明自己，从少年之时便立下志向，要像朱子那样成为圣人。 来贵州龙场前，王阳明已经年近不惑，刻苦求学了将近三十年。对于立志这件事，近三十年来王阳明自己深有体会，一个人如果没有确立自己的志向，就好像船没有了舵、马没有了缰绳，于是只能随波飘荡、四处奔逸，人生不知所终。\n\n立志者，为学之心也；为学者，立志之事也。\n\n在阳明这里，立志是学习的动力，学习是实现志向的过程。然而，人的志向有高有低，有善也有恶。阳明这里讲的立志，其实是在导人向善，要大家立一个真切为善之志，为君子之志。\n\n也就是说，在确立自己的志向之时，你要清楚自己所立的志向是君子之志还是小人之志。王阳明说，“立志成为圣人，就会成为圣人；立志成为贤人，就会成为贤人。”因此，无论你做什么，立志是首要的事情。\n\n另外，阳明讲“立志贵专一”。今日立一志，明日立一志，不会有任何成就。正所谓，有志者立长志，无志者常立志。王阳明打了一个比喻，立志就像种树，立下志向后，犹如在心中种下了一颗根苗，只管去浇灌它，总有一天这颗根苗会长成参天大树，而不要去想什么时候才能开花结果，多想无益。只要你坚定不移地朝着自己的志向奋斗，就一定会见到自己浇灌出来的丰富果实。\n\n\n\n\n\n作者：未晓研心\n\n链接：http://www.jianshu.com/p/d10a1821c479\n\n來源：简书\n\n\n\n\n","slug":"zhixiang","published":1,"updated":"2017-08-12T10:42:07.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6atmsjr000cecvj3xb2qjiu","content":"<p>立志：有志者，事竟成</p>\n<p>阳明说，“志不立，天下无可成之事。”朱熹也说，“为学须先立志。志既立，则学问可次第着力。立志不定，终不济事。”</p>\n<p>立志就是《大学》上讲的“知止”。所谓“知止而后有定”，立志就是知道你人生的终极目的是什么，用以终为始的思维开始你的奋斗历程。王阳明自己，从少年之时便立下志向，要像朱子那样成为圣人。 来贵州龙场前，王阳明已经年近不惑，刻苦求学了将近三十年。对于立志这件事，近三十年来王阳明自己深有体会，一个人如果没有确立自己的志向，就好像船没有了舵、马没有了缰绳，于是只能随波飘荡、四处奔逸，人生不知所终。</p>\n<p>立志者，为学之心也；为学者，立志之事也。</p>\n<p>在阳明这里，立志是学习的动力，学习是实现志向的过程。然而，人的志向有高有低，有善也有恶。阳明这里讲的立志，其实是在导人向善，要大家立一个真切为善之志，为君子之志。</p>\n<p>也就是说，在确立自己的志向之时，你要清楚自己所立的志向是君子之志还是小人之志。王阳明说，“立志成为圣人，就会成为圣人；立志成为贤人，就会成为贤人。”因此，无论你做什么，立志是首要的事情。</p>\n<p>另外，阳明讲“立志贵专一”。今日立一志，明日立一志，不会有任何成就。正所谓，有志者立长志，无志者常立志。王阳明打了一个比喻，立志就像种树，立下志向后，犹如在心中种下了一颗根苗，只管去浇灌它，总有一天这颗根苗会长成参天大树，而不要去想什么时候才能开花结果，多想无益。只要你坚定不移地朝着自己的志向奋斗，就一定会见到自己浇灌出来的丰富果实。</p>\n<p>作者：未晓研心</p>\n<p>链接：<a href=\"http://www.jianshu.com/p/d10a1821c479\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/d10a1821c479</a></p>\n<p>來源：简书</p>\n","site":{"data":{}},"excerpt":"","more":"<p>立志：有志者，事竟成</p>\n<p>阳明说，“志不立，天下无可成之事。”朱熹也说，“为学须先立志。志既立，则学问可次第着力。立志不定，终不济事。”</p>\n<p>立志就是《大学》上讲的“知止”。所谓“知止而后有定”，立志就是知道你人生的终极目的是什么，用以终为始的思维开始你的奋斗历程。王阳明自己，从少年之时便立下志向，要像朱子那样成为圣人。 来贵州龙场前，王阳明已经年近不惑，刻苦求学了将近三十年。对于立志这件事，近三十年来王阳明自己深有体会，一个人如果没有确立自己的志向，就好像船没有了舵、马没有了缰绳，于是只能随波飘荡、四处奔逸，人生不知所终。</p>\n<p>立志者，为学之心也；为学者，立志之事也。</p>\n<p>在阳明这里，立志是学习的动力，学习是实现志向的过程。然而，人的志向有高有低，有善也有恶。阳明这里讲的立志，其实是在导人向善，要大家立一个真切为善之志，为君子之志。</p>\n<p>也就是说，在确立自己的志向之时，你要清楚自己所立的志向是君子之志还是小人之志。王阳明说，“立志成为圣人，就会成为圣人；立志成为贤人，就会成为贤人。”因此，无论你做什么，立志是首要的事情。</p>\n<p>另外，阳明讲“立志贵专一”。今日立一志，明日立一志，不会有任何成就。正所谓，有志者立长志，无志者常立志。王阳明打了一个比喻，立志就像种树，立下志向后，犹如在心中种下了一颗根苗，只管去浇灌它，总有一天这颗根苗会长成参天大树，而不要去想什么时候才能开花结果，多想无益。只要你坚定不移地朝着自己的志向奋斗，就一定会见到自己浇灌出来的丰富果实。</p>\n<p>作者：未晓研心</p>\n<p>链接：<a href=\"http://www.jianshu.com/p/d10a1821c479\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/d10a1821c479</a></p>\n<p>來源：简书</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}