{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/card/source/css/style.less","path":"css/style.less","modified":1,"renderable":1},{"_id":"themes/card/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/card/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/card/source/img/brand.jpg","path":"img/brand.jpg","modified":1,"renderable":1},{"_id":"themes/card/source/img/cc.png","path":"img/cc.png","modified":1,"renderable":1},{"_id":"themes/card/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/card/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/card/source/img/wechat.jpg","path":"img/wechat.jpg","modified":1,"renderable":1},{"_id":"themes/card/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/main.min.js","path":"js/main.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/search.min.js","path":"js/search.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/css/cloudTie/mobile.less","path":"css/cloudTie/mobile.less","modified":1,"renderable":1},{"_id":"themes/card/source/css/cloudTie/pc.less","path":"css/cloudTie/pc.less","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/loader.js","path":"js/cloudTie/loader.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/loader.min.js","path":"js/cloudTie/loader.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/mobile.min.js","path":"js/cloudTie/mobile.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/mobile.js","path":"js/cloudTie/mobile.js","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/pc.min.js","path":"js/cloudTie/pc.min.js","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/js/cloudTie/pc.js","path":"js/cloudTie/pc.js","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"5d81ce2dcb3d8aac68600c9c1ec8b028c6da0b2c","modified":1501491923543},{"_id":"themes/card/.editorconfig","hash":"9b0445427777519defe360ea38c61729d847b3d3","modified":1501290351000},{"_id":"themes/card/LICENSE","hash":"24944bf7920108f5a4790e6071c32e9102760c37","modified":1501290351000},{"_id":"themes/card/README.md","hash":"b188fb95a9c16eb188eeffa6caa0895a14676338","modified":1501290351000},{"_id":"themes/card/_config.yml","hash":"5bb350f4336e4903ba427fec46dc2069b1b14369","modified":1501673188954},{"_id":"themes/card/package.json","hash":"62482f4b9d8122d2d1577f8190dd27c84a702445","modified":1501290351000},{"_id":"source/_posts/DOM-BOM.md","hash":"25874c5eb3f3de7ee0690ab0a3fef034acdba114","modified":1501672156916},{"_id":"source/_posts/css3.md","hash":"5ac5d3f7dbdbcea048dd45311ce83280700ff0e3","modified":1501672156868},{"_id":"source/_posts/js.md","hash":"1108c31f35407f6296a131d5f7088ebac7d8356b","modified":1501677758571},{"_id":"source/_posts/post.md","hash":"a900c0073c50c4de91cc8dcd0e83a590569390b3","modified":1501677639096},{"_id":"source/_posts/question.md","hash":"52d2b08260c1c80057ac2da11850fbb37980e95f","modified":1501672156909},{"_id":"source/_posts/zhixiang.md","hash":"38e97d09a0311c32a9c6499154ef3225c7b6b7b4","modified":1501672156923},{"_id":"source/about/index.md","hash":"871ec1e2872014401e20aa4229d7888e66752ca6","modified":1501664691509},{"_id":"source/share/index.md","hash":"bd871caeca804423c7b02426954e5f15173d47dd","modified":1501493992951},{"_id":"themes/card/languages/en.yml","hash":"1957d2bfc3a4cef299f4f169b431e9b1128ba162","modified":1501290351000},{"_id":"themes/card/languages/zh-CN.yml","hash":"7dc6ae434dde390b6768d244132e23cc78c33817","modified":1501290351000},{"_id":"themes/card/languages/zh-TW.yml","hash":"6a9e820be66eb12ae746f2527e0dc1adf927c685","modified":1501290351000},{"_id":"themes/card/layout/archive.ejs","hash":"d039719e21f6a6fa2925b00aaa623a180a78c818","modified":1501290351000},{"_id":"themes/card/layout/categories.ejs","hash":"41783d2069d5080566a99e6312aa2113105f8b41","modified":1501290351000},{"_id":"themes/card/layout/category.ejs","hash":"7ea26a8a935886963eda82f41c7bd5270cf780d9","modified":1501290351000},{"_id":"themes/card/layout/index.ejs","hash":"39477807b98b2d2df78f3b82498a11e90be8222c","modified":1501290351000},{"_id":"themes/card/layout/layout.ejs","hash":"d52f43fa9572d70cae834e4887c8897b43744805","modified":1501290351000},{"_id":"themes/card/layout/page.ejs","hash":"afb98face24d39a21ebbbde6592a9afc98572aa4","modified":1501290351000},{"_id":"themes/card/layout/post.ejs","hash":"afbf8532dc8d148ca4dff2ca127a3382907cf2f5","modified":1501290351000},{"_id":"themes/card/layout/tag.ejs","hash":"36786a3de7f6cad58209603f7d84ba23addea174","modified":1501290351000},{"_id":"themes/card/layout/tags.ejs","hash":"20466446c41409d14a3d42ccaec24a65a045efef","modified":1501290351000},{"_id":"themes/card/scripts/plugins.js","hash":"e439d717513616bedeed37ba9b05117470809b21","modified":1501290351000},{"_id":"themes/card/layout/_partial/after-footer.ejs","hash":"9ac30b9439fab69973cf4722dbf2945a18fd3804","modified":1501290351000},{"_id":"themes/card/layout/_partial/archive.ejs","hash":"55cd81ef9183426d6d99fd91550fce0a9cc92aa0","modified":1501290351000},{"_id":"themes/card/layout/_partial/footer.ejs","hash":"e1a71a30a1c7a664ddf3ba3e7eb3a5b90bc4b33c","modified":1501290351000},{"_id":"themes/card/layout/_partial/head.ejs","hash":"e01d1987f1016c521a19355d38d35dc78d20f3da","modified":1501290351000},{"_id":"themes/card/layout/_partial/header.ejs","hash":"6156bf20791e46fc1c5872113276c1c1f5c13773","modified":1501290351000},{"_id":"themes/card/layout/_partial/index-item.ejs","hash":"ec7b3ec79bbbead9c7e43e2e6c6b5c8bef509410","modified":1501290351000},{"_id":"themes/card/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1501290351000},{"_id":"themes/card/layout/_partial/menu.ejs","hash":"d39afaad6b0dd2a3ae27e6db3e9a6cd6014622fa","modified":1501290351000},{"_id":"themes/card/layout/_partial/paginator.ejs","hash":"dc27242927890f130a64400596b9b7ad5fca8972","modified":1501290351000},{"_id":"themes/card/layout/_partial/post.ejs","hash":"a87d9b0485b3bf4cdfdad890e5974c43dbaa8240","modified":1501290351000},{"_id":"themes/card/layout/_partial/script.ejs","hash":"439d6315a1b16e32b77a68c3f0cb2961d581086a","modified":1501290351000},{"_id":"themes/card/layout/_partial/search.ejs","hash":"c2091c621b5480ef1e69d72027028cec8e929892","modified":1501290351000},{"_id":"themes/card/layout/_partial/tags-bar.ejs","hash":"19eff4876d31080a427644f7a43fe172d0c008c6","modified":1501290351000},{"_id":"themes/card/source/css/style.less","hash":"3e151cd162e8af87d7ca90e3067f7bd99a25f823","modified":1501290351000},{"_id":"themes/card/source/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1501290351000},{"_id":"themes/card/source/img/avatar.jpg","hash":"62a4893b1a32e997dcdb6e467b10559df75221e2","modified":1501290351000},{"_id":"themes/card/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1501290351000},{"_id":"themes/card/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1501290351000},{"_id":"themes/card/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1501290351000},{"_id":"themes/card/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1501290351000},{"_id":"themes/card/source/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1501290351000},{"_id":"themes/card/source/js/main.js","hash":"26688338ac55bed772e630099d2ce1ed69ef1431","modified":1501290351000},{"_id":"themes/card/source/js/main.min.js","hash":"dcec14830cf056fbbab82313ecd5886a03cdf580","modified":1501290351000},{"_id":"themes/card/source/js/search.js","hash":"c3f80dee3bab6bd4895b55b849085c8af7d1e647","modified":1501290351000},{"_id":"themes/card/source/js/search.min.js","hash":"c0c3d048af0d6b840f6f1dfda08911c7bfdb5dc1","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/baidu.ejs","hash":"e44d526029f122e9c2c74f3a647c35002c818cbe","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/disqus.ejs","hash":"4a0c01e4195f685f9825fcd016d01249dbdd52ca","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/dynamic-title.ejs","hash":"23c101d45911eb0846533aaa2d409c43aa5e899a","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/gitment.ejs","hash":"5723d507eca4390e8e5d18c0770e7953b8c22f5a","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/google-analytics.ejs","hash":"a947f4076b54b48d4df5baf2d5b3c39b632c7576","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/mathjax.ejs","hash":"ea603a057196de53bd6afab1fddb93d11f27eb81","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/page-visit.ejs","hash":"2decb77bf3c1a064ea6ce1d4e78892c434d9c884","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/site-visit.ejs","hash":"8fbd0910828f1ab6eba728bdecc9811d623baae2","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/tajs.ejs","hash":"97b48fe10be1c71d4ff25ccec3bd92d97466c9c5","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/uyan.ejs","hash":"e370bd04ea5cf1c83e0c20516aff7ba3ca8b2d0b","modified":1501290351000},{"_id":"themes/card/layout/_partial/plugins/wangyi-ygt.ejs","hash":"0540808912afbbd8dddbdd15b8d1b54426d8b221","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/category.ejs","hash":"c7476165721a3a5e34d00d8c5c07e1e5474cd800","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/comment.ejs","hash":"298e3ad59b358620b49dc933d39e5f26388d43be","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/copyright.ejs","hash":"968b27ca952d01b066cfe49fb670faf177d6b67e","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/date.ejs","hash":"ea85b46e12d3b9c3612eef7aa76289a663fbc096","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/head-meta.ejs","hash":"b0c680ce5b8aaf461a6731b1ff1287bd140c168a","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/nav.ejs","hash":"11e7d504f7c7a3c4c052da13cfa8ea4862c9383e","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/reward-btn.ejs","hash":"41c242fe3159dc68cec8dd00ab6d2663f5a51179","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/reward.ejs","hash":"801d786ed00ba615a3e3b9f19b238de81225a32e","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/share-fab.ejs","hash":"93482ad7d1e01b966f5ee1c5d12b88564e02b349","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/share.ejs","hash":"8df0d7bf6f8e106cdbdac2dd10a97367aa0695f8","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/tag.ejs","hash":"b3dc38652c4a018a37418136478dcd522fc49f79","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/title.ejs","hash":"062d56cb88ae2be3a6616b911d4ebeffcbfe3cff","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/toc.ejs","hash":"b6123e895c16ace651f1832281ff655776d4068c","modified":1501290351000},{"_id":"themes/card/layout/_partial/post/updated.ejs","hash":"5caa71745aa340ce57938a930f3b898ee7518d74","modified":1501290351000},{"_id":"themes/card/source/css/_partial/archives.less","hash":"7d2a6886265386c640e94ffca3f042675f701a35","modified":1501290351000},{"_id":"themes/card/source/css/_partial/article.less","hash":"4ea7ef6dc47a3df8d31bac4bdf83c17d4161f593","modified":1501290351000},{"_id":"themes/card/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1501290351000},{"_id":"themes/card/source/css/_partial/header.less","hash":"90f0948a9182c14b1dac1e9dbed3c883543266f9","modified":1501290351000},{"_id":"themes/card/source/css/_partial/highlight.less","hash":"58492b7cdb45fe09b026b2f34e8ae69c2ddb8228","modified":1501290351000},{"_id":"themes/card/source/css/_partial/layout.less","hash":"d648da036a12470009f852902946b6c3521ad49b","modified":1501290351000},{"_id":"themes/card/source/css/_partial/lightbox.less","hash":"9b961eb1d70e7658f42cf2ca895fa5e35a6b6541","modified":1501290351000},{"_id":"themes/card/source/css/_partial/loading.less","hash":"f9d06a1e24fb4857fd18d7a0bfbb3a0ab2d1c742","modified":1501290351000},{"_id":"themes/card/source/css/_partial/page.less","hash":"e92ccb53e6ac73a51498c6a9672db9d0d2bc7f1a","modified":1501290351000},{"_id":"themes/card/source/css/_partial/postlist.less","hash":"1c041bf91106808e5480c60d9ece45431bb503b3","modified":1501290351000},{"_id":"themes/card/source/css/_partial/reward.less","hash":"4857f90bb57fc22ca3f942d8934d86d5e9e82c1e","modified":1501290351000},{"_id":"themes/card/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1501290351000},{"_id":"themes/card/source/css/_partial/search.less","hash":"1d6641ae7568a0153d24beba9fd9704d2b155f6c","modified":1501290351000},{"_id":"themes/card/source/css/_partial/share.less","hash":"27d80bcc96a53dd1e7eaa9a7d746e4b212357302","modified":1501290351000},{"_id":"themes/card/source/css/cloudTie/_inputBox.less","hash":"3156898bbbbe0d897f475c03e1e6245e97399613","modified":1501290351000},{"_id":"themes/card/source/css/_partial/tags.less","hash":"959f4373fda6e45f6a4041a995ed3ea8a05a5170","modified":1501290351000},{"_id":"themes/card/source/css/_partial/variable.less","hash":"082896b966ed25b39c74e7b007b4f54c235685a4","modified":1501290351000},{"_id":"themes/card/source/css/_partial/waves.less","hash":"77bfd0b373b0469eb0176167fb076ccda4edf2a7","modified":1501290351000},{"_id":"themes/card/source/css/cloudTie/_joinCount.less","hash":"c1e5821189d17419869249cbd556d8da992fbfd3","modified":1501290351000},{"_id":"themes/card/source/css/cloudTie/_reset.less","hash":"9228ab9e7d92a3cd8cda340ae67f5b172863c835","modified":1501290351000},{"_id":"themes/card/source/css/cloudTie/_share.less","hash":"9c95ca439e85fadbca00778463a9375fbeba9ad2","modified":1501290351000},{"_id":"themes/card/source/css/cloudTie/mobile.less","hash":"0d68b7606a1b3c14a18a03ae3c80e4602f13c75b","modified":1501290351000},{"_id":"themes/card/source/css/cloudTie/pc.less","hash":"8038abcea49d6f74a6ff155cc565b4a675107ae6","modified":1501290351000},{"_id":"themes/card/source/js/cloudTie/loader.js","hash":"299d58e74946a2aeb8db74d3e4b6b5adfe694e15","modified":1501290351000},{"_id":"themes/card/source/js/cloudTie/loader.min.js","hash":"e73fcd885be2c4585f154861c9969e3c955d03e3","modified":1501290351000},{"_id":"themes/card/source/js/cloudTie/mobile.min.js","hash":"859e3efb15db88cedfd18f8523ecfd21f3a22324","modified":1501290351000},{"_id":"themes/card/source/css/_partial/fontawesome.less","hash":"c19f5e28365c7ba6fa938591a8021da7d603253d","modified":1501290351000},{"_id":"themes/card/source/js/cloudTie/mobile.js","hash":"67a0a31ee1e491635369b0401d629e97fccd4d94","modified":1501290351000},{"_id":"themes/card/source/js/cloudTie/pc.min.js","hash":"aea28510192fb36a36bf174716a39afd1ca20240","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1501290351000},{"_id":"themes/card/source/js/cloudTie/pc.js","hash":"25d4ae345f8122f8c7e8e48959d37523dd1e4abb","modified":1501290351000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1501290351000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1501290351000},{"_id":"themes/card/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1501290351000},{"_id":"themes/card/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1501290351000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1501290351000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1501290351000},{"_id":"themes/card/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1501290351000},{"_id":"public/atom.xml","hash":"0c7f0840e15fc4dfedfd701b22c8be39aebf51ec","modified":1501677826973},{"_id":"public/sitemap.xml","hash":"76c3a74dc0985f587cbac43836a077fe76eeb2f8","modified":1501677827172},{"_id":"public/about/index.html","hash":"b305d8ad01bb45c3b225d12b006d1ba6e3b2ccda","modified":1501677827230},{"_id":"public/share/index.html","hash":"544248221b61025788fecd14467b0707d6ae2b51","modified":1501677827242},{"_id":"public/archives/index.html","hash":"8d1cb5239a057cf819070a2df5512512d2dafae7","modified":1501677827243},{"_id":"public/archives/2016/index.html","hash":"71a709f816eb2cc77565bcfee41a7b080c8faa7b","modified":1501677827243},{"_id":"public/archives/2016/06/index.html","hash":"47d5777e26aa8b645cae34c1bd871c3cbbaf5847","modified":1501677827243},{"_id":"public/archives/2016/07/index.html","hash":"613a18a2101a73bcb5629238a8575ddbf9dc6324","modified":1501677827243},{"_id":"public/archives/2016/08/index.html","hash":"1fff53e14ec844c0e9c6ce709d0b7d869bb7bb87","modified":1501677827243},{"_id":"public/archives/2016/09/index.html","hash":"d07ce5a6c331b3e9a615545fcec8f71e40db1bf3","modified":1501677827243},{"_id":"public/archives/2016/10/index.html","hash":"2466851f9f77bce59a81beb4829412519fa016ed","modified":1501677827243},{"_id":"public/archives/2017/index.html","hash":"f9f74792631e834b547c1954d0c1f63cc7738931","modified":1501677827243},{"_id":"public/archives/2017/03/index.html","hash":"deeb86de9d0d76d956be350bcb78c31fe36451b8","modified":1501677827243},{"_id":"public/2017/03/02/js/index.html","hash":"04ec78f121601277532ef315fa594acc97d274b0","modified":1501677827243},{"_id":"public/2016/10/01/post/index.html","hash":"ed6e59a3ef8cbfdebd727d037614967a135c6c6e","modified":1501677827243},{"_id":"public/2016/09/01/question/index.html","hash":"ff0013c047b268173d1ff616f575ed1f52bcd32a","modified":1501677827243},{"_id":"public/2016/08/02/zhixiang/index.html","hash":"f55b6723e3c7a9e01b3aa04a065c7d01c464e94d","modified":1501677827243},{"_id":"public/2016/07/01/css3/index.html","hash":"695e468f000acc95126d5d05b8dfc35640abf48a","modified":1501677827243},{"_id":"public/2016/06/06/DOM-BOM/index.html","hash":"e7216af4ab26f63b3216d60f9147b238437746ce","modified":1501677827244},{"_id":"public/index.html","hash":"810b19381c7cf804f38adb897275b65698e5b333","modified":1501677827265},{"_id":"public/CNAME","hash":"5d81ce2dcb3d8aac68600c9c1ec8b028c6da0b2c","modified":1501677827265},{"_id":"public/css/style.less","hash":"3e151cd162e8af87d7ca90e3067f7bd99a25f823","modified":1501677827265},{"_id":"public/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1501677827265},{"_id":"public/img/avatar.jpg","hash":"62a4893b1a32e997dcdb6e467b10559df75221e2","modified":1501677827266},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1501677827266},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1501677827266},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1501677827266},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1501677827266},{"_id":"public/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1501677827266},{"_id":"public/css/cloudTie/mobile.less","hash":"0d68b7606a1b3c14a18a03ae3c80e4602f13c75b","modified":1501677827266},{"_id":"public/css/cloudTie/pc.less","hash":"8038abcea49d6f74a6ff155cc565b4a675107ae6","modified":1501677827266},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1501677827266},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1501677827266},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1501677827266},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1501677827266},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1501677827267},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1501677827267},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1501677827275},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1501677827278},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1501677827278},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1501677827278},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1501677827278},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1501677827278},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1501677827279},{"_id":"public/js/main.min.js","hash":"dcec14830cf056fbbab82313ecd5886a03cdf580","modified":1501677827292},{"_id":"public/js/search.js","hash":"c3f80dee3bab6bd4895b55b849085c8af7d1e647","modified":1501677827292},{"_id":"public/js/search.min.js","hash":"c0c3d048af0d6b840f6f1dfda08911c7bfdb5dc1","modified":1501677827292},{"_id":"public/js/cloudTie/loader.js","hash":"299d58e74946a2aeb8db74d3e4b6b5adfe694e15","modified":1501677827292},{"_id":"public/js/cloudTie/loader.min.js","hash":"e73fcd885be2c4585f154861c9969e3c955d03e3","modified":1501677827292},{"_id":"public/js/main.js","hash":"26688338ac55bed772e630099d2ce1ed69ef1431","modified":1501677827292},{"_id":"public/js/cloudTie/mobile.min.js","hash":"859e3efb15db88cedfd18f8523ecfd21f3a22324","modified":1501677827292},{"_id":"public/js/cloudTie/mobile.js","hash":"67a0a31ee1e491635369b0401d629e97fccd4d94","modified":1501677827292},{"_id":"public/js/cloudTie/pc.min.js","hash":"aea28510192fb36a36bf174716a39afd1ca20240","modified":1501677827292},{"_id":"public/js/cloudTie/pc.js","hash":"25d4ae345f8122f8c7e8e48959d37523dd1e4abb","modified":1501677827292},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1501677827292},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1501677827292},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1501677827293},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1501677827310}],"Category":[],"Data":[],"Page":[{"title":"关于我","date":"2017-08-02T08:50:08.000Z","tags":null,"_content":"# 本人三观端正，无不良嗜好\n# 个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\n# 爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\n# 犯我中华者，虽远必诛\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2017-08-02 16:50:08\ntags:\n---\n# 本人三观端正，无不良嗜好\n# 个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\n# 爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\n# 犯我中华者，虽远必诛\n","updated":"2017-08-02T09:04:51.509Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj5v07ehf0001cwuv2629y73z","content":"<h1 id=\"本人三观端正，无不良嗜好\"><a href=\"#本人三观端正，无不良嗜好\" class=\"headerlink\" title=\"本人三观端正，无不良嗜好\"></a>本人三观端正，无不良嗜好</h1><h1 id=\"个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\"><a href=\"#个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\" class=\"headerlink\" title=\"个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\"></a>个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇</h1><h1 id=\"爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\"><a href=\"#爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\" class=\"headerlink\" title=\"爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\"></a>爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛</h1><h1 id=\"犯我中华者，虽远必诛\"><a href=\"#犯我中华者，虽远必诛\" class=\"headerlink\" title=\"犯我中华者，虽远必诛\"></a>犯我中华者，虽远必诛</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"本人三观端正，无不良嗜好\"><a href=\"#本人三观端正，无不良嗜好\" class=\"headerlink\" title=\"本人三观端正，无不良嗜好\"></a>本人三观端正，无不良嗜好</h1><h1 id=\"个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\"><a href=\"#个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\" class=\"headerlink\" title=\"个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇\"></a>个人行事准则：认为应该做的事情就要坚定不移的去做，绝无半点动摇</h1><h1 id=\"爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\"><a href=\"#爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\" class=\"headerlink\" title=\"爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛\"></a>爱好和平，喜欢战争，内心充满着一股强烈的爱国热情，希望祖国繁荣昌盛</h1><h1 id=\"犯我中华者，虽远必诛\"><a href=\"#犯我中华者，虽远必诛\" class=\"headerlink\" title=\"犯我中华者，虽远必诛\"></a>犯我中华者，虽远必诛</h1>"},{"title":"share","date":"2017-07-31T09:39:52.000Z","_content":"","source":"share/index.md","raw":"---\ntitle: share\ndate: 2017-07-31 17:39:52\n---\n","updated":"2017-07-31T09:39:52.951Z","path":"share/index.html","comments":1,"layout":"page","_id":"cj5v07ehi0003cwuv9ev2n9on","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"DOM，BOM笔记要点","date":"2016-06-06T01:01:30.000Z","_content":"DOM: Document Object Model\n\n# DOM是专门操作网页内容的API标准\n    为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题\n    所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。\n    结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器\n    何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.\n    DOM Tree:\n    \n    什么是: 网页中一切内容在内存中都是以树形结构存储的\n           网页中每一项内容都是树上的一个节点对象\n           包括: 元素, 文字, 属性...\n           树只有一个根节点: document, 包含了所有网页内容\n    Node: 每个节点都是一个node类型的对象\n          node是所有节点的父类型\n# 三大公共: nodeType nodeName nodeValue\n\n    nodeType: 节点的类型\n      值: document   9\n         element     1\n         attribute     2\n         text         3\n      何时: 只要判断节点类型，就用nodeType\n            因为不同类型的节点，能执行的操作是不一样的\n      问题: 不能进一步区分元素的名称\n      解决:\n    nodeName: 节点的名称\n      值: document   #document\n         element    全大写的标签名\n         attribute    属性名\n         text        #text\n      何时: 只要细致鉴别元素的标签名时\n        强调: nodeName返回的是全大写的标签名\n    nodeValue: 节点值:\n      值: document   null\n         element     null\n         attribute     属性值\n         text         文本内容\n# 2、查找: 4种:\n\n      a. 不需要查找，可直接获得的元素\n            html   document.documentElement\n            head   document.head\n            body   document.body\n      b. 按节点间关系查找:\n    节点树: 包含所有节点: 元素和文本\n      1. 父子: elem.parentNode  找elem的父节点\n            elem.childNodes  找elem的所有*直接*子节点\n                返回，所有直接子节点组成的集合(类数组)\n            elem.firstChild   找elem的第一个*直接*子节点\n            elem.lastChild   找elem的最后一个*直接*子节点\n      2. 兄弟: elem.previousSibling 找elem的前一个兄弟\n            elem.nextSibling   找elem的下一个兄弟\n     何时: 前提: 已经获得了一个节点\n          要找周围临近的节点时\n     问题: 连看不见的空字符，也算文本节点——干扰\n     解决:\n    元素树: 仅包含元素节点的树结构\n           不是一棵新树，仅是节点树的子集\n     1. 父子: elem.parentElement  找elem的父元素\n            elem.children  找elem的所有*直接*子元素\n                返回，所有直接子元素组成的集合(类数组)\n            elem.firstElementChild   第一个*直接*子元素\n            elem.lastElementChild   最后一个*直接*子元素\n     2. 兄弟:\n       elem.previousElementSibling 找elem的前一个兄弟元素\n       elem.nextElementSibling   找elem的下一个兄弟元素\n     何时: 只要仅关心元素节点，不关心文本节点时\n     问题: IE9+\n     强调: childNodes和children返回的都是动态集合！\n       凡是遍历动态集合，都要先缓存元素个数，再遍历\n       for(var i=0,len= childNodes.length;i<len;i++)\n         不会导致反复查找DOM树\n# 3、 按HTML查找:\n\n        优: 范围可大可小,可设置条件\n    a、按id查找: var elem=document.getElementById(\"id\")\n      强调: 1. 只能在document对象上调用\n           2. 返回一个元素对象\n    b、按标签名查找:\n        var elems=parent.getElementsByTagName(\"标签名\");\n      强调: 1. 可在任意父元素上\n           2. 返回多个元素组成的集合\n           3. 不但查找直接子元素，还查找所有后代元素\n    c、按name属性查找: 了解\n       专门找表单中有name属性的表单元素\n        var elems=document.getElementsByName(\"name\")\n        强调: 1. 只能在document上调用\n             2. 返回多个元素组成的集合\n    d、按class属性查找:\n        var elems=parent.getElementsByClassName(\"class\")\n        强调: 1. 可在任意父元素上调用\n             2. 返回多个元素组成的集合\n             3. 不要求完整匹配，只要包含即可！\n    缺: 每次只能按一个条件查找\n       如果条件复杂，就无法一句话获得想要的元素\n# 4、 按选择器查找:\n\n    a. 只找一个元素:\n      var elem=parent.querySelector(\"selector\");\n    b. 找多个元素\n      var elems=parent.querySelectorAll(\"selector\");\n# 5、 总结:\n\n     A首次查找:\n        1. 如果条件简单: 按HTML查找: id, 标签, className\n        2. 如果条件复杂: 按选择器查找:\n     B已经获得一个元素，找周围相邻: 按节点间关系\n    鄙视: 按HTML查找 vs 按选择器查找\n     1.使用的难易程度: 当条件复杂时:\n        按选择器查找——简单, 按HTML查找——繁琐\n     2.返回值:\n        getElementsByTagName() 返回多个元素的*动态*集合\n          什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树\n        querySelectorAll()  返回多个元素的*非动态*集合\n          什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树\n     3.单次效率:\n        按HTML查找——效率高!\n        按选择器查找——效率低\n# 6、 修改: (内容, 属性, 样式)\n\n    1. 修改:\n    标准属性: 2种:\n      1. 核心DOM: 操作一切结构化文档的API(HTML，XML)\n        elem.attributes集合: 保存了当前元素的所有属性节点\n        获取属性值: elem.getAttribute(\"属性名\")\n        修改属性值: elem.setAttribute(\"属性名\",\"值\")\n        判断是否包含属性: elem.hasAttribute(\"属性名\")\n        移除属性: elem.removeAttribute(\"属性名\")\n      2. HTML DOM: 对部分常用DOM API的简化版本\n         HTML DOM将标准属性都预定义在元素对象中\n        获取属性值: elem.属性名\n        修改属性值: elem.属性名=\"值\";\n        判断是否包含属性: elem.属性名===\"\" 不包含\n        移除属性: elem.属性名=\"\"\n        特例: class属性和ES标准中的class重名\n              -> DOM -> className\n        自定义属性: 比如: data-toggle=\"dropdown\"\n          HTML DOM不能操作自定义属性\n          暂时只能用核心DOM操作:\n        三大状态: disabled  selected   checked\n          核心DOM无法操作三大状态属性\n          HTMLDOM: elem.disabled elem.selected  elem.checked\n                值都是bool类型true/false\n# 6.1、修改css样式:\n\n    1. 仅获取/修改内联样式:  elem.style.css属性名\n      问题1: css属性名有的带-\n      解决: 所有css属性名都要去横线变驼峰\n         比如: background-color: backgroundColor\n              list-style-type: listStyleType\n      问题2: 所有数值类型的属性值都是带单位的字符串\n      解决: 获取时: 都要去单位，转数值\n            修改时: 将单位拼回数值\n      问题3: 仅能获得内联样式, 无法获得样式表中的样式\n      解决: 计算后的样式: 最终应用到元素上的完整样式\n        何时: 只要希望获得元素完整的样式时\n        如何: 2步:\n          1. 获得完整样式对象style\n            var style=getComputedStyle(elem)\n          2. 获得style对象中的css属性\n            style.css属性名\n         强调: style对象中的样式都是只读\n    结论: 1. 获取样式: getComputedStyle\n         2. 修改样式: elem.style.css属性名\n    2. 运行时修改样式表中的样式:\n      Step1: 获得样式表对象:\n       var sheet=document.styleSheets[i]\n      Step2: 获得样式表对象中某个CSSRule(一个选择器{})\n       var rule=sheet.cssRules[i]\n      Step3: 修改rule.style.css属性名=值\n# 7、 添加和删除:\n\n    添加: 3步:\n     Step1: 创建空元素:\n      var a=document.createElement(\"a\");\n      <a></a>\n     Step2: 设置关键属性:\n         a.href=\"http://tmooc.cn\"\n         a.innerHTML=\"go to tmooc\";\n      <a href=\"http://tmooc.cn\">go to tmooc</a>\n     Step3: 将元素添加到DOM树: 3种:\n       1. 末尾追加: parent.appendChild(child)\n       2. 中间插入: parent.insertBefore(child, oldChild)\n       3. 替换: parent.replaceChild(child, oldChild)\n# 优化: 尽量少的修改DOM树\n\n    原因: 页面加载过程:\n      html -> DOM Tree(松树)\n               ↓\n            render Tree(圣诞树)-> layout(计算绝对布局)->paint\n               ↑                 最耗时\n      css  -> cssRules(装饰品)\n      每次修改DOM树，都会导致重新layout，耗时。\n    如何: 2种:\n     1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树\n        结果: 只触发一次layout\n# 1、 HTML DOM 常用对象: 对常用HTML元素操作的简化\n\n    Select: 代表页面上的一个select元素\n     属性: select.value 当前选中项的value\n                     没有value，就返回选中项的内容\n          select.options 保存select下所有option元素对象\n            相当于: select.getElementsByTagName(\"option\")\n            select.options.length 保存select下option的个数\n            清空select下所有option: select.options.length=0;\n          select.length 等效于select.options.length\n            清空select下所有option: select.length=0;\n                                   select.innerHTML=\"\";\n          select.selectedIndex 当前选中项的下标\n      事件: onchange 当选中项发生改变时\n      方法: select.add(option) 向select中添加一个option\n             相当于: select.appendChild(option)\n             不支持文档片段\n           select.remove(i) 移除select中i位置的一个option\n    Option: 代表页面上的一个option元素\n      创建: var opt=new Option(text,value);\n         创建一个option对象，同时设置opt的内容为text，设置opt的值为value\n         相当于: var opt=document.createElement(\"option\");\n                opt.innerHTML=text;\n                opt.value=value;\n      属性: .text 代替.innerHTML\n           .index  表示当前option在select下的下标位置\n# Table: 代表网页中一个table元素\n\n     管着行分组：\n       添加行分组: var 行分组=table.createTHead|TBody|TFoot();\n           强调: 即创建，同时又将行分组添加到table\n       删除行分组: table.deleteTHead|TFoot()\n       获取行分组: table.tHead|tFoot\n                  table.tBodies[i]\n    行分组: THead TBody TFoot\n      管着行:\n       添加行: var tr=行分组.insertRow(i)\n           在行分组中i位置插入一个新行\n           强调: 中间插入行，原i位置的行向后顺移\n           固定套路: 1. 末尾追加一个新行: 行分组.insertRow()\n                    2. 开头插入: 行分组.insertRow(0)\n       删除行: 行分组.deleteRow(i)\n           删除行分组中第i行\n           强调: i是当前行在行分组内的相对下标位置\n       获取行: 行分组.rows\n    \n    行: tr\n      管着td:\n        添加td: var td=tr.insertCell(i);\n            省略i表示右侧末尾追加\n            insertCell不支持添加th，只能添加td\n        删除td: tr.deleteCell(i);\n        获取td: tr.cells\n    \n    删除行:\n     tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标\n     问题：行分组，无法使用tr.rowIndex删除行。\n     解决: table.deleteRow(tr.rowIndex)\n     总结: 今后，删除行都用table.deleteRow(tr.rowIndex)\n# form: 代表页面上一个表单元素\n\n     获取: var form=document.forms[i/id]\n     属性: form.elements 保存了表单中所有表单元素的数组\n            包括: input   select   textarea  button\n          form.elements.length 获得表单中表单元素的个数\n          form.length => form.elements.length\n     方法: form.submit();  用于手动提交表单\n     事件: form.onsubmit  以任何方式提交表单之前自动触发\n              常用于在提交之前，验证所有表单元素的内容\n    表单元素:\n     获取: var elem=form.elements[i/id/name]\n            简写: 如果表单元素有name属性: form.name\n     方法: elem.focus() 让elem获得焦点\n          elem.blur()  让elem失去焦点\n    \n    Image: 代表页面上一个img元素\n      创建: var img=new Image();\n# DOM总结: 查找->绑定事件->查找->修改/添加/删除\n\n    查找: 4种:\n      1. 不需要查找可直接获得: html  head  body  form\n      2. 节点间关系: 节点树/元素树\n          鄙视: 递归遍历\n      3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName\n      4. 按选择器: 2种:\n          只找一个: querySelector()\n          找多个: querySelectorAll()\n    修改:\n      内容: .innerHTML  .textContent/.innerText  .value\n      属性:\n        1. 标准属性: 1. 核心DOM; 2. HTML DOM\n        2. 自定义属性: 核心DOM\n        3. 状态属性: HTML DOM\n      样式:\n        修改: elem.style.css属性=值\n        获取: var style=getComputedStyle(elem)\n             style.css属性 ——只读\n        可通过修改class属性批量应用修改多个css属性\n    添加: 3步:\n       1. createElement,\n       2.设置关键属性,\n       3. appendChild/insertBefore/replaceChild\n      优化: 尽量少的操作DOM树\n      如何: 2种:\n       1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面\n       2. 同时添加多个平级子元素: fragment\n    删除: parent.removeChild(child)\n    HTML DOM: Select/Option  Table/...  From/Element  Image\n    过渡动画: 2步:\n      css中: 添加transition\n      js中: 修改css属性值\n       不支持transition: display  zIndex\n       支持: width  height  opacity   bottom/top/left/right ...\n# 2、BOM: Browser Object Model\n\n    什么是: 专门操作浏览器窗口的API\n    比如: alert prompt confirm\n    问题: 1. 没有标准——兼容性问题;\n         2. 不可定制\n    window对象: 2个角色:\n      1. 代替ES中的Global充当全局作用域对象\n      2. 封装所有BOM和DOM的API\n    \n    打开超链接: 4种:\n      1. 在当前窗口打开，可后退\n        html: <a href=\"url\" target=\"_self\"></a>\n        js: /*window.*/open(\"url\",\"_self\")\n      2. 在当前窗口打开，不可后退\n        js: location.replace(\"url\");\n           用新url代替history中当前url，结果: 无法后退\n      3. 在新窗口打开，可打开多个\n        html: <a href=\"url\" target=\"_blank\"></a>\n        js: open(\"url\",\"_blank\")\n      4. 在新窗口打开，只能打开一个\n        html: <a href=\"url\" target=\"自定义name属性值\"></a>\n        js: open(\"url\",\"自定义name属性值\")\n        原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口\n          浏览器规定，相同name属性的窗口只能打开一个\n        其实: html中的target属性就是在设置新窗口的name属性值。\n        如果target中使用自定义的窗口名，则只能打开一个\n        预定义:\n          _self: 默认使用当前窗口自己的name属性\n               结果，新窗口覆盖当前窗口\n          _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。\n               结果: 每次打开新窗口都随机生成不同的name\n                     结果: 可打开任意多个\n# 定时器: 2种:\n\n    1. 周期性定时器:\n      什么是: 让程序按照指定时间间隔，反复执行一项任务\n      何时: 只要让程序按照指定时间间隔，反复执行一项任务\n      如何: 3件事:\n        1. 任务函数: 让定时器反复调用的函数\n        2. 启动定时器:\n         var timer=setInterval(任务函数, 间隔的毫秒数)\n        3. 停止定时器: clearInterval(timer)\n            问题: timer中的序号会残留在timer变量中\n            解决: 停止定时器后，主动清空timer\n                 timer=null\n      停止定时器: 2种:\n        1. 用户手动停止定时器: 用按钮调用clearInterval\n        2. 自动停止定时器: 在任务函数中:\n           1. 设定临界条件\n           2. 如果达到临界条件就自动调用clearInterval\n    \n    2. 一次性定时器:\n     什么是: 让程序先等待一段时间，再自动执行一次任务\n             执行一次后，定时器自动停止\n     何时: 只要先等待，再执行一次任务\n     如何: 三件事\n       1. 任务函数\n       2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)\n       3. 停止: clearTimeout(timer)\n    鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行\n    \n    for(var i=0;i<3;i++){\n      setTimeout(function(){\n        console.log(i);\n      },0);\n    }//结果: 3 3 3\n    //alert(\"Hello\") 如果不点确定，则永远不输出333\n# window:\n# history，location，document，navigator，screen，event \n\n    history: 保存当前窗口打开后，成功访问过的历史记录的栈\n      history封装的非常严密\n      只能前进，后退，刷新: history.go(n)\n       前进: go(1)  后退:go(-1)  刷新:go(0)\n    \n    location: 专门保存当前窗口正在打开的url的对象\n     属性: location.href 保存了完整的url\n            在当前窗口打开: location.href=新url\n          location.protocol: 协议\n                .host: 主机名+端口号\n                .hostname: 主机名\n                .port: 端口号\n          location.pathname: 相对路径\n                .hash: 锚点地址#xxx\n                .search: 表单提交后地址栏中的查询字符串\n                       ?变量名=值&变量名=值&...\n     方法:\n       1. 替换history中当前url,实现进制后退:\n         location.replace(\"新url\")\n       2. 在当前页面打开，可后退:\n         location.assign(\"新url\")\n           => location.href=\"新url\"\n            => location=\"新url\"\n       3. 刷新页面:  location.reload(false/true);\n         鄙视: false/true的差别\n           浏览器本地是有缓存的\n             浏览器的缓存中会保存css，图片等静态资源\n           每次请求时，首先查看缓存中是否有想要文件\n             没有想要文件，或文件过期，才去服务器下载新文件\n           reload(false) 优先使用本地缓存的文件\n           reload(true) 强制去服务器下载新文件\n         查 浏览器缓存的原理！\n# 1、event\n\n    绑定事件: 2种:\n     1. 在HTML中绑定: <ANY on事件名=\"js语句\"\n        问题: 不符合内容与行为分离的原则——不便于维护\n     2. 在js中动态绑定: 2种:\n        1. 一个事件只绑定一个处理函数:\n           elem.on事件名=function(){\n             //this->elem\n           }\n           解除绑定: elem.on事件名=null;\n           问题: 每个事件只能绑定一个处理函数\n           解决:\n        2. 一个事件可同时绑定多个处理函数:\n           elem.addEventListener(\"事件名\",function(){\n             //this->elem\n           })\n           解除绑定:\n            elem.removeEventListener(\"事件名\",\"函数名\");\n            强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数\n    \n        事件模型: DOM标准: 3个阶段\n          1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数\n          2. 目标触发: 首先执行目标元素上的事件处理函数\n          3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数\n    \n        事件对象: 事件发生时自动创建的\n                 封装事件信息\n                 提供操作事件的API 的对象\n          何时: 只要希望获得事件信息或修改事件的默认行为\n          如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！\n              .on事件名=function(e){\n                 //e会自动获得事件对象\n              }\n        阻止蔓延/冒泡: e.stopPropagation();\n        利用冒泡:\n          优化: 尽量少的添加事件监听\n          原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢\n          如何: 如果多个子元素都要绑定相同的事件\n              只要在父元素绑定一次，所有子元素即可共用\n          难题:\n             1. 获得目标元素:\n                不能用this, 因为this指父元素\n                应该用e.target，保存实际点击的目标元素\n             2. 鉴别目标元素:\n                先判断目标元素的nodeName或className...\n                只有目标元素符合要求时，才执行事件操作\n        取消事件/阻止默认行为: e.preventDefault();\n        事件坐标: 3对儿:\n          1. 相对于整个屏幕左上角的坐标: e.screenX|screenY\n          2. 相对于文档显示区左上角的坐标: e.clientX|clientY\n          3. 相对于当前元素左上角的坐标: e.offsetX|offsetY\n    \n        页面滚动:\n          事件: window.onscroll\n          获得页面滚动位置: document.body.scrollTop\n              页面超出文档显示区顶部的距离","source":"_posts/DOM-BOM.md","raw":"---\ntitle: DOM，BOM笔记要点\ndate: 2016-06-06 09:01:30\ntags:\n---\nDOM: Document Object Model\n\n# DOM是专门操作网页内容的API标准\n    为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题\n    所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。\n    结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器\n    何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.\n    DOM Tree:\n    \n    什么是: 网页中一切内容在内存中都是以树形结构存储的\n           网页中每一项内容都是树上的一个节点对象\n           包括: 元素, 文字, 属性...\n           树只有一个根节点: document, 包含了所有网页内容\n    Node: 每个节点都是一个node类型的对象\n          node是所有节点的父类型\n# 三大公共: nodeType nodeName nodeValue\n\n    nodeType: 节点的类型\n      值: document   9\n         element     1\n         attribute     2\n         text         3\n      何时: 只要判断节点类型，就用nodeType\n            因为不同类型的节点，能执行的操作是不一样的\n      问题: 不能进一步区分元素的名称\n      解决:\n    nodeName: 节点的名称\n      值: document   #document\n         element    全大写的标签名\n         attribute    属性名\n         text        #text\n      何时: 只要细致鉴别元素的标签名时\n        强调: nodeName返回的是全大写的标签名\n    nodeValue: 节点值:\n      值: document   null\n         element     null\n         attribute     属性值\n         text         文本内容\n# 2、查找: 4种:\n\n      a. 不需要查找，可直接获得的元素\n            html   document.documentElement\n            head   document.head\n            body   document.body\n      b. 按节点间关系查找:\n    节点树: 包含所有节点: 元素和文本\n      1. 父子: elem.parentNode  找elem的父节点\n            elem.childNodes  找elem的所有*直接*子节点\n                返回，所有直接子节点组成的集合(类数组)\n            elem.firstChild   找elem的第一个*直接*子节点\n            elem.lastChild   找elem的最后一个*直接*子节点\n      2. 兄弟: elem.previousSibling 找elem的前一个兄弟\n            elem.nextSibling   找elem的下一个兄弟\n     何时: 前提: 已经获得了一个节点\n          要找周围临近的节点时\n     问题: 连看不见的空字符，也算文本节点——干扰\n     解决:\n    元素树: 仅包含元素节点的树结构\n           不是一棵新树，仅是节点树的子集\n     1. 父子: elem.parentElement  找elem的父元素\n            elem.children  找elem的所有*直接*子元素\n                返回，所有直接子元素组成的集合(类数组)\n            elem.firstElementChild   第一个*直接*子元素\n            elem.lastElementChild   最后一个*直接*子元素\n     2. 兄弟:\n       elem.previousElementSibling 找elem的前一个兄弟元素\n       elem.nextElementSibling   找elem的下一个兄弟元素\n     何时: 只要仅关心元素节点，不关心文本节点时\n     问题: IE9+\n     强调: childNodes和children返回的都是动态集合！\n       凡是遍历动态集合，都要先缓存元素个数，再遍历\n       for(var i=0,len= childNodes.length;i<len;i++)\n         不会导致反复查找DOM树\n# 3、 按HTML查找:\n\n        优: 范围可大可小,可设置条件\n    a、按id查找: var elem=document.getElementById(\"id\")\n      强调: 1. 只能在document对象上调用\n           2. 返回一个元素对象\n    b、按标签名查找:\n        var elems=parent.getElementsByTagName(\"标签名\");\n      强调: 1. 可在任意父元素上\n           2. 返回多个元素组成的集合\n           3. 不但查找直接子元素，还查找所有后代元素\n    c、按name属性查找: 了解\n       专门找表单中有name属性的表单元素\n        var elems=document.getElementsByName(\"name\")\n        强调: 1. 只能在document上调用\n             2. 返回多个元素组成的集合\n    d、按class属性查找:\n        var elems=parent.getElementsByClassName(\"class\")\n        强调: 1. 可在任意父元素上调用\n             2. 返回多个元素组成的集合\n             3. 不要求完整匹配，只要包含即可！\n    缺: 每次只能按一个条件查找\n       如果条件复杂，就无法一句话获得想要的元素\n# 4、 按选择器查找:\n\n    a. 只找一个元素:\n      var elem=parent.querySelector(\"selector\");\n    b. 找多个元素\n      var elems=parent.querySelectorAll(\"selector\");\n# 5、 总结:\n\n     A首次查找:\n        1. 如果条件简单: 按HTML查找: id, 标签, className\n        2. 如果条件复杂: 按选择器查找:\n     B已经获得一个元素，找周围相邻: 按节点间关系\n    鄙视: 按HTML查找 vs 按选择器查找\n     1.使用的难易程度: 当条件复杂时:\n        按选择器查找——简单, 按HTML查找——繁琐\n     2.返回值:\n        getElementsByTagName() 返回多个元素的*动态*集合\n          什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树\n        querySelectorAll()  返回多个元素的*非动态*集合\n          什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树\n     3.单次效率:\n        按HTML查找——效率高!\n        按选择器查找——效率低\n# 6、 修改: (内容, 属性, 样式)\n\n    1. 修改:\n    标准属性: 2种:\n      1. 核心DOM: 操作一切结构化文档的API(HTML，XML)\n        elem.attributes集合: 保存了当前元素的所有属性节点\n        获取属性值: elem.getAttribute(\"属性名\")\n        修改属性值: elem.setAttribute(\"属性名\",\"值\")\n        判断是否包含属性: elem.hasAttribute(\"属性名\")\n        移除属性: elem.removeAttribute(\"属性名\")\n      2. HTML DOM: 对部分常用DOM API的简化版本\n         HTML DOM将标准属性都预定义在元素对象中\n        获取属性值: elem.属性名\n        修改属性值: elem.属性名=\"值\";\n        判断是否包含属性: elem.属性名===\"\" 不包含\n        移除属性: elem.属性名=\"\"\n        特例: class属性和ES标准中的class重名\n              -> DOM -> className\n        自定义属性: 比如: data-toggle=\"dropdown\"\n          HTML DOM不能操作自定义属性\n          暂时只能用核心DOM操作:\n        三大状态: disabled  selected   checked\n          核心DOM无法操作三大状态属性\n          HTMLDOM: elem.disabled elem.selected  elem.checked\n                值都是bool类型true/false\n# 6.1、修改css样式:\n\n    1. 仅获取/修改内联样式:  elem.style.css属性名\n      问题1: css属性名有的带-\n      解决: 所有css属性名都要去横线变驼峰\n         比如: background-color: backgroundColor\n              list-style-type: listStyleType\n      问题2: 所有数值类型的属性值都是带单位的字符串\n      解决: 获取时: 都要去单位，转数值\n            修改时: 将单位拼回数值\n      问题3: 仅能获得内联样式, 无法获得样式表中的样式\n      解决: 计算后的样式: 最终应用到元素上的完整样式\n        何时: 只要希望获得元素完整的样式时\n        如何: 2步:\n          1. 获得完整样式对象style\n            var style=getComputedStyle(elem)\n          2. 获得style对象中的css属性\n            style.css属性名\n         强调: style对象中的样式都是只读\n    结论: 1. 获取样式: getComputedStyle\n         2. 修改样式: elem.style.css属性名\n    2. 运行时修改样式表中的样式:\n      Step1: 获得样式表对象:\n       var sheet=document.styleSheets[i]\n      Step2: 获得样式表对象中某个CSSRule(一个选择器{})\n       var rule=sheet.cssRules[i]\n      Step3: 修改rule.style.css属性名=值\n# 7、 添加和删除:\n\n    添加: 3步:\n     Step1: 创建空元素:\n      var a=document.createElement(\"a\");\n      <a></a>\n     Step2: 设置关键属性:\n         a.href=\"http://tmooc.cn\"\n         a.innerHTML=\"go to tmooc\";\n      <a href=\"http://tmooc.cn\">go to tmooc</a>\n     Step3: 将元素添加到DOM树: 3种:\n       1. 末尾追加: parent.appendChild(child)\n       2. 中间插入: parent.insertBefore(child, oldChild)\n       3. 替换: parent.replaceChild(child, oldChild)\n# 优化: 尽量少的修改DOM树\n\n    原因: 页面加载过程:\n      html -> DOM Tree(松树)\n               ↓\n            render Tree(圣诞树)-> layout(计算绝对布局)->paint\n               ↑                 最耗时\n      css  -> cssRules(装饰品)\n      每次修改DOM树，都会导致重新layout，耗时。\n    如何: 2种:\n     1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树\n        结果: 只触发一次layout\n# 1、 HTML DOM 常用对象: 对常用HTML元素操作的简化\n\n    Select: 代表页面上的一个select元素\n     属性: select.value 当前选中项的value\n                     没有value，就返回选中项的内容\n          select.options 保存select下所有option元素对象\n            相当于: select.getElementsByTagName(\"option\")\n            select.options.length 保存select下option的个数\n            清空select下所有option: select.options.length=0;\n          select.length 等效于select.options.length\n            清空select下所有option: select.length=0;\n                                   select.innerHTML=\"\";\n          select.selectedIndex 当前选中项的下标\n      事件: onchange 当选中项发生改变时\n      方法: select.add(option) 向select中添加一个option\n             相当于: select.appendChild(option)\n             不支持文档片段\n           select.remove(i) 移除select中i位置的一个option\n    Option: 代表页面上的一个option元素\n      创建: var opt=new Option(text,value);\n         创建一个option对象，同时设置opt的内容为text，设置opt的值为value\n         相当于: var opt=document.createElement(\"option\");\n                opt.innerHTML=text;\n                opt.value=value;\n      属性: .text 代替.innerHTML\n           .index  表示当前option在select下的下标位置\n# Table: 代表网页中一个table元素\n\n     管着行分组：\n       添加行分组: var 行分组=table.createTHead|TBody|TFoot();\n           强调: 即创建，同时又将行分组添加到table\n       删除行分组: table.deleteTHead|TFoot()\n       获取行分组: table.tHead|tFoot\n                  table.tBodies[i]\n    行分组: THead TBody TFoot\n      管着行:\n       添加行: var tr=行分组.insertRow(i)\n           在行分组中i位置插入一个新行\n           强调: 中间插入行，原i位置的行向后顺移\n           固定套路: 1. 末尾追加一个新行: 行分组.insertRow()\n                    2. 开头插入: 行分组.insertRow(0)\n       删除行: 行分组.deleteRow(i)\n           删除行分组中第i行\n           强调: i是当前行在行分组内的相对下标位置\n       获取行: 行分组.rows\n    \n    行: tr\n      管着td:\n        添加td: var td=tr.insertCell(i);\n            省略i表示右侧末尾追加\n            insertCell不支持添加th，只能添加td\n        删除td: tr.deleteCell(i);\n        获取td: tr.cells\n    \n    删除行:\n     tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标\n     问题：行分组，无法使用tr.rowIndex删除行。\n     解决: table.deleteRow(tr.rowIndex)\n     总结: 今后，删除行都用table.deleteRow(tr.rowIndex)\n# form: 代表页面上一个表单元素\n\n     获取: var form=document.forms[i/id]\n     属性: form.elements 保存了表单中所有表单元素的数组\n            包括: input   select   textarea  button\n          form.elements.length 获得表单中表单元素的个数\n          form.length => form.elements.length\n     方法: form.submit();  用于手动提交表单\n     事件: form.onsubmit  以任何方式提交表单之前自动触发\n              常用于在提交之前，验证所有表单元素的内容\n    表单元素:\n     获取: var elem=form.elements[i/id/name]\n            简写: 如果表单元素有name属性: form.name\n     方法: elem.focus() 让elem获得焦点\n          elem.blur()  让elem失去焦点\n    \n    Image: 代表页面上一个img元素\n      创建: var img=new Image();\n# DOM总结: 查找->绑定事件->查找->修改/添加/删除\n\n    查找: 4种:\n      1. 不需要查找可直接获得: html  head  body  form\n      2. 节点间关系: 节点树/元素树\n          鄙视: 递归遍历\n      3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName\n      4. 按选择器: 2种:\n          只找一个: querySelector()\n          找多个: querySelectorAll()\n    修改:\n      内容: .innerHTML  .textContent/.innerText  .value\n      属性:\n        1. 标准属性: 1. 核心DOM; 2. HTML DOM\n        2. 自定义属性: 核心DOM\n        3. 状态属性: HTML DOM\n      样式:\n        修改: elem.style.css属性=值\n        获取: var style=getComputedStyle(elem)\n             style.css属性 ——只读\n        可通过修改class属性批量应用修改多个css属性\n    添加: 3步:\n       1. createElement,\n       2.设置关键属性,\n       3. appendChild/insertBefore/replaceChild\n      优化: 尽量少的操作DOM树\n      如何: 2种:\n       1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面\n       2. 同时添加多个平级子元素: fragment\n    删除: parent.removeChild(child)\n    HTML DOM: Select/Option  Table/...  From/Element  Image\n    过渡动画: 2步:\n      css中: 添加transition\n      js中: 修改css属性值\n       不支持transition: display  zIndex\n       支持: width  height  opacity   bottom/top/left/right ...\n# 2、BOM: Browser Object Model\n\n    什么是: 专门操作浏览器窗口的API\n    比如: alert prompt confirm\n    问题: 1. 没有标准——兼容性问题;\n         2. 不可定制\n    window对象: 2个角色:\n      1. 代替ES中的Global充当全局作用域对象\n      2. 封装所有BOM和DOM的API\n    \n    打开超链接: 4种:\n      1. 在当前窗口打开，可后退\n        html: <a href=\"url\" target=\"_self\"></a>\n        js: /*window.*/open(\"url\",\"_self\")\n      2. 在当前窗口打开，不可后退\n        js: location.replace(\"url\");\n           用新url代替history中当前url，结果: 无法后退\n      3. 在新窗口打开，可打开多个\n        html: <a href=\"url\" target=\"_blank\"></a>\n        js: open(\"url\",\"_blank\")\n      4. 在新窗口打开，只能打开一个\n        html: <a href=\"url\" target=\"自定义name属性值\"></a>\n        js: open(\"url\",\"自定义name属性值\")\n        原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口\n          浏览器规定，相同name属性的窗口只能打开一个\n        其实: html中的target属性就是在设置新窗口的name属性值。\n        如果target中使用自定义的窗口名，则只能打开一个\n        预定义:\n          _self: 默认使用当前窗口自己的name属性\n               结果，新窗口覆盖当前窗口\n          _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。\n               结果: 每次打开新窗口都随机生成不同的name\n                     结果: 可打开任意多个\n# 定时器: 2种:\n\n    1. 周期性定时器:\n      什么是: 让程序按照指定时间间隔，反复执行一项任务\n      何时: 只要让程序按照指定时间间隔，反复执行一项任务\n      如何: 3件事:\n        1. 任务函数: 让定时器反复调用的函数\n        2. 启动定时器:\n         var timer=setInterval(任务函数, 间隔的毫秒数)\n        3. 停止定时器: clearInterval(timer)\n            问题: timer中的序号会残留在timer变量中\n            解决: 停止定时器后，主动清空timer\n                 timer=null\n      停止定时器: 2种:\n        1. 用户手动停止定时器: 用按钮调用clearInterval\n        2. 自动停止定时器: 在任务函数中:\n           1. 设定临界条件\n           2. 如果达到临界条件就自动调用clearInterval\n    \n    2. 一次性定时器:\n     什么是: 让程序先等待一段时间，再自动执行一次任务\n             执行一次后，定时器自动停止\n     何时: 只要先等待，再执行一次任务\n     如何: 三件事\n       1. 任务函数\n       2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)\n       3. 停止: clearTimeout(timer)\n    鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行\n    \n    for(var i=0;i<3;i++){\n      setTimeout(function(){\n        console.log(i);\n      },0);\n    }//结果: 3 3 3\n    //alert(\"Hello\") 如果不点确定，则永远不输出333\n# window:\n# history，location，document，navigator，screen，event \n\n    history: 保存当前窗口打开后，成功访问过的历史记录的栈\n      history封装的非常严密\n      只能前进，后退，刷新: history.go(n)\n       前进: go(1)  后退:go(-1)  刷新:go(0)\n    \n    location: 专门保存当前窗口正在打开的url的对象\n     属性: location.href 保存了完整的url\n            在当前窗口打开: location.href=新url\n          location.protocol: 协议\n                .host: 主机名+端口号\n                .hostname: 主机名\n                .port: 端口号\n          location.pathname: 相对路径\n                .hash: 锚点地址#xxx\n                .search: 表单提交后地址栏中的查询字符串\n                       ?变量名=值&变量名=值&...\n     方法:\n       1. 替换history中当前url,实现进制后退:\n         location.replace(\"新url\")\n       2. 在当前页面打开，可后退:\n         location.assign(\"新url\")\n           => location.href=\"新url\"\n            => location=\"新url\"\n       3. 刷新页面:  location.reload(false/true);\n         鄙视: false/true的差别\n           浏览器本地是有缓存的\n             浏览器的缓存中会保存css，图片等静态资源\n           每次请求时，首先查看缓存中是否有想要文件\n             没有想要文件，或文件过期，才去服务器下载新文件\n           reload(false) 优先使用本地缓存的文件\n           reload(true) 强制去服务器下载新文件\n         查 浏览器缓存的原理！\n# 1、event\n\n    绑定事件: 2种:\n     1. 在HTML中绑定: <ANY on事件名=\"js语句\"\n        问题: 不符合内容与行为分离的原则——不便于维护\n     2. 在js中动态绑定: 2种:\n        1. 一个事件只绑定一个处理函数:\n           elem.on事件名=function(){\n             //this->elem\n           }\n           解除绑定: elem.on事件名=null;\n           问题: 每个事件只能绑定一个处理函数\n           解决:\n        2. 一个事件可同时绑定多个处理函数:\n           elem.addEventListener(\"事件名\",function(){\n             //this->elem\n           })\n           解除绑定:\n            elem.removeEventListener(\"事件名\",\"函数名\");\n            强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数\n    \n        事件模型: DOM标准: 3个阶段\n          1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数\n          2. 目标触发: 首先执行目标元素上的事件处理函数\n          3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数\n    \n        事件对象: 事件发生时自动创建的\n                 封装事件信息\n                 提供操作事件的API 的对象\n          何时: 只要希望获得事件信息或修改事件的默认行为\n          如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！\n              .on事件名=function(e){\n                 //e会自动获得事件对象\n              }\n        阻止蔓延/冒泡: e.stopPropagation();\n        利用冒泡:\n          优化: 尽量少的添加事件监听\n          原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢\n          如何: 如果多个子元素都要绑定相同的事件\n              只要在父元素绑定一次，所有子元素即可共用\n          难题:\n             1. 获得目标元素:\n                不能用this, 因为this指父元素\n                应该用e.target，保存实际点击的目标元素\n             2. 鉴别目标元素:\n                先判断目标元素的nodeName或className...\n                只有目标元素符合要求时，才执行事件操作\n        取消事件/阻止默认行为: e.preventDefault();\n        事件坐标: 3对儿:\n          1. 相对于整个屏幕左上角的坐标: e.screenX|screenY\n          2. 相对于文档显示区左上角的坐标: e.clientX|clientY\n          3. 相对于当前元素左上角的坐标: e.offsetX|offsetY\n    \n        页面滚动:\n          事件: window.onscroll\n          获得页面滚动位置: document.body.scrollTop\n              页面超出文档显示区顶部的距离","slug":"DOM-BOM","published":1,"updated":"2017-08-02T11:09:16.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5v07eh90000cwuv6j1o0qok","content":"<p>DOM: Document Object Model</p>\n<h1 id=\"DOM是专门操作网页内容的API标准\"><a href=\"#DOM是专门操作网页内容的API标准\" class=\"headerlink\" title=\"DOM是专门操作网页内容的API标准\"></a>DOM是专门操作网页内容的API标准</h1><pre><code>为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题\n所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。\n结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器\n何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.\nDOM Tree:\n\n什么是: 网页中一切内容在内存中都是以树形结构存储的\n       网页中每一项内容都是树上的一个节点对象\n       包括: 元素, 文字, 属性...\n       树只有一个根节点: document, 包含了所有网页内容\nNode: 每个节点都是一个node类型的对象\n      node是所有节点的父类型\n</code></pre><h1 id=\"三大公共-nodeType-nodeName-nodeValue\"><a href=\"#三大公共-nodeType-nodeName-nodeValue\" class=\"headerlink\" title=\"三大公共: nodeType nodeName nodeValue\"></a>三大公共: nodeType nodeName nodeValue</h1><pre><code>nodeType: 节点的类型\n  值: document   9\n     element     1\n     attribute     2\n     text         3\n  何时: 只要判断节点类型，就用nodeType\n        因为不同类型的节点，能执行的操作是不一样的\n  问题: 不能进一步区分元素的名称\n  解决:\nnodeName: 节点的名称\n  值: document   #document\n     element    全大写的标签名\n     attribute    属性名\n     text        #text\n  何时: 只要细致鉴别元素的标签名时\n    强调: nodeName返回的是全大写的标签名\nnodeValue: 节点值:\n  值: document   null\n     element     null\n     attribute     属性值\n     text         文本内容\n</code></pre><h1 id=\"2、查找-4种\"><a href=\"#2、查找-4种\" class=\"headerlink\" title=\"2、查找: 4种:\"></a>2、查找: 4种:</h1><pre><code>  a. 不需要查找，可直接获得的元素\n        html   document.documentElement\n        head   document.head\n        body   document.body\n  b. 按节点间关系查找:\n节点树: 包含所有节点: 元素和文本\n  1. 父子: elem.parentNode  找elem的父节点\n        elem.childNodes  找elem的所有*直接*子节点\n            返回，所有直接子节点组成的集合(类数组)\n        elem.firstChild   找elem的第一个*直接*子节点\n        elem.lastChild   找elem的最后一个*直接*子节点\n  2. 兄弟: elem.previousSibling 找elem的前一个兄弟\n        elem.nextSibling   找elem的下一个兄弟\n 何时: 前提: 已经获得了一个节点\n      要找周围临近的节点时\n 问题: 连看不见的空字符，也算文本节点——干扰\n 解决:\n元素树: 仅包含元素节点的树结构\n       不是一棵新树，仅是节点树的子集\n 1. 父子: elem.parentElement  找elem的父元素\n        elem.children  找elem的所有*直接*子元素\n            返回，所有直接子元素组成的集合(类数组)\n        elem.firstElementChild   第一个*直接*子元素\n        elem.lastElementChild   最后一个*直接*子元素\n 2. 兄弟:\n   elem.previousElementSibling 找elem的前一个兄弟元素\n   elem.nextElementSibling   找elem的下一个兄弟元素\n 何时: 只要仅关心元素节点，不关心文本节点时\n 问题: IE9+\n 强调: childNodes和children返回的都是动态集合！\n   凡是遍历动态集合，都要先缓存元素个数，再遍历\n   for(var i=0,len= childNodes.length;i&lt;len;i++)\n     不会导致反复查找DOM树\n</code></pre><h1 id=\"3、-按HTML查找\"><a href=\"#3、-按HTML查找\" class=\"headerlink\" title=\"3、 按HTML查找:\"></a>3、 按HTML查找:</h1><pre><code>    优: 范围可大可小,可设置条件\na、按id查找: var elem=document.getElementById(&quot;id&quot;)\n  强调: 1. 只能在document对象上调用\n       2. 返回一个元素对象\nb、按标签名查找:\n    var elems=parent.getElementsByTagName(&quot;标签名&quot;);\n  强调: 1. 可在任意父元素上\n       2. 返回多个元素组成的集合\n       3. 不但查找直接子元素，还查找所有后代元素\nc、按name属性查找: 了解\n   专门找表单中有name属性的表单元素\n    var elems=document.getElementsByName(&quot;name&quot;)\n    强调: 1. 只能在document上调用\n         2. 返回多个元素组成的集合\nd、按class属性查找:\n    var elems=parent.getElementsByClassName(&quot;class&quot;)\n    强调: 1. 可在任意父元素上调用\n         2. 返回多个元素组成的集合\n         3. 不要求完整匹配，只要包含即可！\n缺: 每次只能按一个条件查找\n   如果条件复杂，就无法一句话获得想要的元素\n</code></pre><h1 id=\"4、-按选择器查找\"><a href=\"#4、-按选择器查找\" class=\"headerlink\" title=\"4、 按选择器查找:\"></a>4、 按选择器查找:</h1><pre><code>a. 只找一个元素:\n  var elem=parent.querySelector(&quot;selector&quot;);\nb. 找多个元素\n  var elems=parent.querySelectorAll(&quot;selector&quot;);\n</code></pre><h1 id=\"5、-总结\"><a href=\"#5、-总结\" class=\"headerlink\" title=\"5、 总结:\"></a>5、 总结:</h1><pre><code> A首次查找:\n    1. 如果条件简单: 按HTML查找: id, 标签, className\n    2. 如果条件复杂: 按选择器查找:\n B已经获得一个元素，找周围相邻: 按节点间关系\n鄙视: 按HTML查找 vs 按选择器查找\n 1.使用的难易程度: 当条件复杂时:\n    按选择器查找——简单, 按HTML查找——繁琐\n 2.返回值:\n    getElementsByTagName() 返回多个元素的*动态*集合\n      什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树\n    querySelectorAll()  返回多个元素的*非动态*集合\n      什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树\n 3.单次效率:\n    按HTML查找——效率高!\n    按选择器查找——效率低\n</code></pre><h1 id=\"6、-修改-内容-属性-样式\"><a href=\"#6、-修改-内容-属性-样式\" class=\"headerlink\" title=\"6、 修改: (内容, 属性, 样式)\"></a>6、 修改: (内容, 属性, 样式)</h1><pre><code>1. 修改:\n标准属性: 2种:\n  1. 核心DOM: 操作一切结构化文档的API(HTML，XML)\n    elem.attributes集合: 保存了当前元素的所有属性节点\n    获取属性值: elem.getAttribute(&quot;属性名&quot;)\n    修改属性值: elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;)\n    判断是否包含属性: elem.hasAttribute(&quot;属性名&quot;)\n    移除属性: elem.removeAttribute(&quot;属性名&quot;)\n  2. HTML DOM: 对部分常用DOM API的简化版本\n     HTML DOM将标准属性都预定义在元素对象中\n    获取属性值: elem.属性名\n    修改属性值: elem.属性名=&quot;值&quot;;\n    判断是否包含属性: elem.属性名===&quot;&quot; 不包含\n    移除属性: elem.属性名=&quot;&quot;\n    特例: class属性和ES标准中的class重名\n          -&gt; DOM -&gt; className\n    自定义属性: 比如: data-toggle=&quot;dropdown&quot;\n      HTML DOM不能操作自定义属性\n      暂时只能用核心DOM操作:\n    三大状态: disabled  selected   checked\n      核心DOM无法操作三大状态属性\n      HTMLDOM: elem.disabled elem.selected  elem.checked\n            值都是bool类型true/false\n</code></pre><h1 id=\"6-1、修改css样式\"><a href=\"#6-1、修改css样式\" class=\"headerlink\" title=\"6.1、修改css样式:\"></a>6.1、修改css样式:</h1><pre><code>1. 仅获取/修改内联样式:  elem.style.css属性名\n  问题1: css属性名有的带-\n  解决: 所有css属性名都要去横线变驼峰\n     比如: background-color: backgroundColor\n          list-style-type: listStyleType\n  问题2: 所有数值类型的属性值都是带单位的字符串\n  解决: 获取时: 都要去单位，转数值\n        修改时: 将单位拼回数值\n  问题3: 仅能获得内联样式, 无法获得样式表中的样式\n  解决: 计算后的样式: 最终应用到元素上的完整样式\n    何时: 只要希望获得元素完整的样式时\n    如何: 2步:\n      1. 获得完整样式对象style\n        var style=getComputedStyle(elem)\n      2. 获得style对象中的css属性\n        style.css属性名\n     强调: style对象中的样式都是只读\n结论: 1. 获取样式: getComputedStyle\n     2. 修改样式: elem.style.css属性名\n2. 运行时修改样式表中的样式:\n  Step1: 获得样式表对象:\n   var sheet=document.styleSheets[i]\n  Step2: 获得样式表对象中某个CSSRule(一个选择器{})\n   var rule=sheet.cssRules[i]\n  Step3: 修改rule.style.css属性名=值\n</code></pre><h1 id=\"7、-添加和删除\"><a href=\"#7、-添加和删除\" class=\"headerlink\" title=\"7、 添加和删除:\"></a>7、 添加和删除:</h1><pre><code>添加: 3步:\n Step1: 创建空元素:\n  var a=document.createElement(&quot;a&quot;);\n  &lt;a&gt;&lt;/a&gt;\n Step2: 设置关键属性:\n     a.href=&quot;http://tmooc.cn&quot;\n     a.innerHTML=&quot;go to tmooc&quot;;\n  &lt;a href=&quot;http://tmooc.cn&quot;&gt;go to tmooc&lt;/a&gt;\n Step3: 将元素添加到DOM树: 3种:\n   1. 末尾追加: parent.appendChild(child)\n   2. 中间插入: parent.insertBefore(child, oldChild)\n   3. 替换: parent.replaceChild(child, oldChild)\n</code></pre><h1 id=\"优化-尽量少的修改DOM树\"><a href=\"#优化-尽量少的修改DOM树\" class=\"headerlink\" title=\"优化: 尽量少的修改DOM树\"></a>优化: 尽量少的修改DOM树</h1><pre><code>原因: 页面加载过程:\n  html -&gt; DOM Tree(松树)\n           ↓\n        render Tree(圣诞树)-&gt; layout(计算绝对布局)-&gt;paint\n           ↑                 最耗时\n  css  -&gt; cssRules(装饰品)\n  每次修改DOM树，都会导致重新layout，耗时。\n如何: 2种:\n 1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树\n    结果: 只触发一次layout\n</code></pre><h1 id=\"1、-HTML-DOM-常用对象-对常用HTML元素操作的简化\"><a href=\"#1、-HTML-DOM-常用对象-对常用HTML元素操作的简化\" class=\"headerlink\" title=\"1、 HTML DOM 常用对象: 对常用HTML元素操作的简化\"></a>1、 HTML DOM 常用对象: 对常用HTML元素操作的简化</h1><pre><code>Select: 代表页面上的一个select元素\n 属性: select.value 当前选中项的value\n                 没有value，就返回选中项的内容\n      select.options 保存select下所有option元素对象\n        相当于: select.getElementsByTagName(&quot;option&quot;)\n        select.options.length 保存select下option的个数\n        清空select下所有option: select.options.length=0;\n      select.length 等效于select.options.length\n        清空select下所有option: select.length=0;\n                               select.innerHTML=&quot;&quot;;\n      select.selectedIndex 当前选中项的下标\n  事件: onchange 当选中项发生改变时\n  方法: select.add(option) 向select中添加一个option\n         相当于: select.appendChild(option)\n         不支持文档片段\n       select.remove(i) 移除select中i位置的一个option\nOption: 代表页面上的一个option元素\n  创建: var opt=new Option(text,value);\n     创建一个option对象，同时设置opt的内容为text，设置opt的值为value\n     相当于: var opt=document.createElement(&quot;option&quot;);\n            opt.innerHTML=text;\n            opt.value=value;\n  属性: .text 代替.innerHTML\n       .index  表示当前option在select下的下标位置\n</code></pre><h1 id=\"Table-代表网页中一个table元素\"><a href=\"#Table-代表网页中一个table元素\" class=\"headerlink\" title=\"Table: 代表网页中一个table元素\"></a>Table: 代表网页中一个table元素</h1><pre><code> 管着行分组：\n   添加行分组: var 行分组=table.createTHead|TBody|TFoot();\n       强调: 即创建，同时又将行分组添加到table\n   删除行分组: table.deleteTHead|TFoot()\n   获取行分组: table.tHead|tFoot\n              table.tBodies[i]\n行分组: THead TBody TFoot\n  管着行:\n   添加行: var tr=行分组.insertRow(i)\n       在行分组中i位置插入一个新行\n       强调: 中间插入行，原i位置的行向后顺移\n       固定套路: 1. 末尾追加一个新行: 行分组.insertRow()\n                2. 开头插入: 行分组.insertRow(0)\n   删除行: 行分组.deleteRow(i)\n       删除行分组中第i行\n       强调: i是当前行在行分组内的相对下标位置\n   获取行: 行分组.rows\n\n行: tr\n  管着td:\n    添加td: var td=tr.insertCell(i);\n        省略i表示右侧末尾追加\n        insertCell不支持添加th，只能添加td\n    删除td: tr.deleteCell(i);\n    获取td: tr.cells\n\n删除行:\n tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标\n 问题：行分组，无法使用tr.rowIndex删除行。\n 解决: table.deleteRow(tr.rowIndex)\n 总结: 今后，删除行都用table.deleteRow(tr.rowIndex)\n</code></pre><h1 id=\"form-代表页面上一个表单元素\"><a href=\"#form-代表页面上一个表单元素\" class=\"headerlink\" title=\"form: 代表页面上一个表单元素\"></a>form: 代表页面上一个表单元素</h1><pre><code> 获取: var form=document.forms[i/id]\n 属性: form.elements 保存了表单中所有表单元素的数组\n        包括: input   select   textarea  button\n      form.elements.length 获得表单中表单元素的个数\n      form.length =&gt; form.elements.length\n 方法: form.submit();  用于手动提交表单\n 事件: form.onsubmit  以任何方式提交表单之前自动触发\n          常用于在提交之前，验证所有表单元素的内容\n表单元素:\n 获取: var elem=form.elements[i/id/name]\n        简写: 如果表单元素有name属性: form.name\n 方法: elem.focus() 让elem获得焦点\n      elem.blur()  让elem失去焦点\n\nImage: 代表页面上一个img元素\n  创建: var img=new Image();\n</code></pre><h1 id=\"DOM总结-查找-gt-绑定事件-gt-查找-gt-修改-添加-删除\"><a href=\"#DOM总结-查找-gt-绑定事件-gt-查找-gt-修改-添加-删除\" class=\"headerlink\" title=\"DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除\"></a>DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除</h1><pre><code>查找: 4种:\n  1. 不需要查找可直接获得: html  head  body  form\n  2. 节点间关系: 节点树/元素树\n      鄙视: 递归遍历\n  3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName\n  4. 按选择器: 2种:\n      只找一个: querySelector()\n      找多个: querySelectorAll()\n修改:\n  内容: .innerHTML  .textContent/.innerText  .value\n  属性:\n    1. 标准属性: 1. 核心DOM; 2. HTML DOM\n    2. 自定义属性: 核心DOM\n    3. 状态属性: HTML DOM\n  样式:\n    修改: elem.style.css属性=值\n    获取: var style=getComputedStyle(elem)\n         style.css属性 ——只读\n    可通过修改class属性批量应用修改多个css属性\n添加: 3步:\n   1. createElement,\n   2.设置关键属性,\n   3. appendChild/insertBefore/replaceChild\n  优化: 尽量少的操作DOM树\n  如何: 2种:\n   1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面\n   2. 同时添加多个平级子元素: fragment\n删除: parent.removeChild(child)\nHTML DOM: Select/Option  Table/...  From/Element  Image\n过渡动画: 2步:\n  css中: 添加transition\n  js中: 修改css属性值\n   不支持transition: display  zIndex\n   支持: width  height  opacity   bottom/top/left/right ...\n</code></pre><h1 id=\"2、BOM-Browser-Object-Model\"><a href=\"#2、BOM-Browser-Object-Model\" class=\"headerlink\" title=\"2、BOM: Browser Object Model\"></a>2、BOM: Browser Object Model</h1><pre><code>什么是: 专门操作浏览器窗口的API\n比如: alert prompt confirm\n问题: 1. 没有标准——兼容性问题;\n     2. 不可定制\nwindow对象: 2个角色:\n  1. 代替ES中的Global充当全局作用域对象\n  2. 封装所有BOM和DOM的API\n\n打开超链接: 4种:\n  1. 在当前窗口打开，可后退\n    html: &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;\n    js: /*window.*/open(&quot;url&quot;,&quot;_self&quot;)\n  2. 在当前窗口打开，不可后退\n    js: location.replace(&quot;url&quot;);\n       用新url代替history中当前url，结果: 无法后退\n  3. 在新窗口打开，可打开多个\n    html: &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;\n    js: open(&quot;url&quot;,&quot;_blank&quot;)\n  4. 在新窗口打开，只能打开一个\n    html: &lt;a href=&quot;url&quot; target=&quot;自定义name属性值&quot;&gt;&lt;/a&gt;\n    js: open(&quot;url&quot;,&quot;自定义name属性值&quot;)\n    原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口\n      浏览器规定，相同name属性的窗口只能打开一个\n    其实: html中的target属性就是在设置新窗口的name属性值。\n    如果target中使用自定义的窗口名，则只能打开一个\n    预定义:\n      _self: 默认使用当前窗口自己的name属性\n           结果，新窗口覆盖当前窗口\n      _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。\n           结果: 每次打开新窗口都随机生成不同的name\n                 结果: 可打开任意多个\n</code></pre><h1 id=\"定时器-2种\"><a href=\"#定时器-2种\" class=\"headerlink\" title=\"定时器: 2种:\"></a>定时器: 2种:</h1><pre><code>1. 周期性定时器:\n  什么是: 让程序按照指定时间间隔，反复执行一项任务\n  何时: 只要让程序按照指定时间间隔，反复执行一项任务\n  如何: 3件事:\n    1. 任务函数: 让定时器反复调用的函数\n    2. 启动定时器:\n     var timer=setInterval(任务函数, 间隔的毫秒数)\n    3. 停止定时器: clearInterval(timer)\n        问题: timer中的序号会残留在timer变量中\n        解决: 停止定时器后，主动清空timer\n             timer=null\n  停止定时器: 2种:\n    1. 用户手动停止定时器: 用按钮调用clearInterval\n    2. 自动停止定时器: 在任务函数中:\n       1. 设定临界条件\n       2. 如果达到临界条件就自动调用clearInterval\n\n2. 一次性定时器:\n 什么是: 让程序先等待一段时间，再自动执行一次任务\n         执行一次后，定时器自动停止\n 何时: 只要先等待，再执行一次任务\n 如何: 三件事\n   1. 任务函数\n   2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)\n   3. 停止: clearTimeout(timer)\n鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行\n\nfor(var i=0;i&lt;3;i++){\n  setTimeout(function(){\n    console.log(i);\n  },0);\n}//结果: 3 3 3\n//alert(&quot;Hello&quot;) 如果不点确定，则永远不输出333\n</code></pre><h1 id=\"window\"><a href=\"#window\" class=\"headerlink\" title=\"window:\"></a>window:</h1><h1 id=\"history，location，document，navigator，screen，event\"><a href=\"#history，location，document，navigator，screen，event\" class=\"headerlink\" title=\"history，location，document，navigator，screen，event\"></a>history，location，document，navigator，screen，event</h1><pre><code>history: 保存当前窗口打开后，成功访问过的历史记录的栈\n  history封装的非常严密\n  只能前进，后退，刷新: history.go(n)\n   前进: go(1)  后退:go(-1)  刷新:go(0)\n\nlocation: 专门保存当前窗口正在打开的url的对象\n 属性: location.href 保存了完整的url\n        在当前窗口打开: location.href=新url\n      location.protocol: 协议\n            .host: 主机名+端口号\n            .hostname: 主机名\n            .port: 端口号\n      location.pathname: 相对路径\n            .hash: 锚点地址#xxx\n            .search: 表单提交后地址栏中的查询字符串\n                   ?变量名=值&amp;变量名=值&amp;...\n 方法:\n   1. 替换history中当前url,实现进制后退:\n     location.replace(&quot;新url&quot;)\n   2. 在当前页面打开，可后退:\n     location.assign(&quot;新url&quot;)\n       =&gt; location.href=&quot;新url&quot;\n        =&gt; location=&quot;新url&quot;\n   3. 刷新页面:  location.reload(false/true);\n     鄙视: false/true的差别\n       浏览器本地是有缓存的\n         浏览器的缓存中会保存css，图片等静态资源\n       每次请求时，首先查看缓存中是否有想要文件\n         没有想要文件，或文件过期，才去服务器下载新文件\n       reload(false) 优先使用本地缓存的文件\n       reload(true) 强制去服务器下载新文件\n     查 浏览器缓存的原理！\n</code></pre><h1 id=\"1、event\"><a href=\"#1、event\" class=\"headerlink\" title=\"1、event\"></a>1、event</h1><pre><code>绑定事件: 2种:\n 1. 在HTML中绑定: &lt;ANY on事件名=&quot;js语句&quot;\n    问题: 不符合内容与行为分离的原则——不便于维护\n 2. 在js中动态绑定: 2种:\n    1. 一个事件只绑定一个处理函数:\n       elem.on事件名=function(){\n         //this-&gt;elem\n       }\n       解除绑定: elem.on事件名=null;\n       问题: 每个事件只能绑定一个处理函数\n       解决:\n    2. 一个事件可同时绑定多个处理函数:\n       elem.addEventListener(&quot;事件名&quot;,function(){\n         //this-&gt;elem\n       })\n       解除绑定:\n        elem.removeEventListener(&quot;事件名&quot;,&quot;函数名&quot;);\n        强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数\n\n    事件模型: DOM标准: 3个阶段\n      1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数\n      2. 目标触发: 首先执行目标元素上的事件处理函数\n      3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数\n\n    事件对象: 事件发生时自动创建的\n             封装事件信息\n             提供操作事件的API 的对象\n      何时: 只要希望获得事件信息或修改事件的默认行为\n      如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！\n          .on事件名=function(e){\n             //e会自动获得事件对象\n          }\n    阻止蔓延/冒泡: e.stopPropagation();\n    利用冒泡:\n      优化: 尽量少的添加事件监听\n      原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢\n      如何: 如果多个子元素都要绑定相同的事件\n          只要在父元素绑定一次，所有子元素即可共用\n      难题:\n         1. 获得目标元素:\n            不能用this, 因为this指父元素\n            应该用e.target，保存实际点击的目标元素\n         2. 鉴别目标元素:\n            先判断目标元素的nodeName或className...\n            只有目标元素符合要求时，才执行事件操作\n    取消事件/阻止默认行为: e.preventDefault();\n    事件坐标: 3对儿:\n      1. 相对于整个屏幕左上角的坐标: e.screenX|screenY\n      2. 相对于文档显示区左上角的坐标: e.clientX|clientY\n      3. 相对于当前元素左上角的坐标: e.offsetX|offsetY\n\n    页面滚动:\n      事件: window.onscroll\n      获得页面滚动位置: document.body.scrollTop\n          页面超出文档显示区顶部的距离\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>DOM: Document Object Model</p>\n<h1 id=\"DOM是专门操作网页内容的API标准\"><a href=\"#DOM是专门操作网页内容的API标准\" class=\"headerlink\" title=\"DOM是专门操作网页内容的API标准\"></a>DOM是专门操作网页内容的API标准</h1><pre><code>为什么: 早起js操作不同浏览器的API没有标准，有严重兼容性问题\n所以，W3C制定了统一的操作网页内容的API标准,所有浏览器厂商都遵照执行。\n结果，使用DOM API操作网页内容，几乎100%兼容所有浏览器\n何时: 只要操作网页内容，就用DOM API查找, 修改(内容,属性,样式), 添加, 删除.\nDOM Tree:\n\n什么是: 网页中一切内容在内存中都是以树形结构存储的\n       网页中每一项内容都是树上的一个节点对象\n       包括: 元素, 文字, 属性...\n       树只有一个根节点: document, 包含了所有网页内容\nNode: 每个节点都是一个node类型的对象\n      node是所有节点的父类型\n</code></pre><h1 id=\"三大公共-nodeType-nodeName-nodeValue\"><a href=\"#三大公共-nodeType-nodeName-nodeValue\" class=\"headerlink\" title=\"三大公共: nodeType nodeName nodeValue\"></a>三大公共: nodeType nodeName nodeValue</h1><pre><code>nodeType: 节点的类型\n  值: document   9\n     element     1\n     attribute     2\n     text         3\n  何时: 只要判断节点类型，就用nodeType\n        因为不同类型的节点，能执行的操作是不一样的\n  问题: 不能进一步区分元素的名称\n  解决:\nnodeName: 节点的名称\n  值: document   #document\n     element    全大写的标签名\n     attribute    属性名\n     text        #text\n  何时: 只要细致鉴别元素的标签名时\n    强调: nodeName返回的是全大写的标签名\nnodeValue: 节点值:\n  值: document   null\n     element     null\n     attribute     属性值\n     text         文本内容\n</code></pre><h1 id=\"2、查找-4种\"><a href=\"#2、查找-4种\" class=\"headerlink\" title=\"2、查找: 4种:\"></a>2、查找: 4种:</h1><pre><code>  a. 不需要查找，可直接获得的元素\n        html   document.documentElement\n        head   document.head\n        body   document.body\n  b. 按节点间关系查找:\n节点树: 包含所有节点: 元素和文本\n  1. 父子: elem.parentNode  找elem的父节点\n        elem.childNodes  找elem的所有*直接*子节点\n            返回，所有直接子节点组成的集合(类数组)\n        elem.firstChild   找elem的第一个*直接*子节点\n        elem.lastChild   找elem的最后一个*直接*子节点\n  2. 兄弟: elem.previousSibling 找elem的前一个兄弟\n        elem.nextSibling   找elem的下一个兄弟\n 何时: 前提: 已经获得了一个节点\n      要找周围临近的节点时\n 问题: 连看不见的空字符，也算文本节点——干扰\n 解决:\n元素树: 仅包含元素节点的树结构\n       不是一棵新树，仅是节点树的子集\n 1. 父子: elem.parentElement  找elem的父元素\n        elem.children  找elem的所有*直接*子元素\n            返回，所有直接子元素组成的集合(类数组)\n        elem.firstElementChild   第一个*直接*子元素\n        elem.lastElementChild   最后一个*直接*子元素\n 2. 兄弟:\n   elem.previousElementSibling 找elem的前一个兄弟元素\n   elem.nextElementSibling   找elem的下一个兄弟元素\n 何时: 只要仅关心元素节点，不关心文本节点时\n 问题: IE9+\n 强调: childNodes和children返回的都是动态集合！\n   凡是遍历动态集合，都要先缓存元素个数，再遍历\n   for(var i=0,len= childNodes.length;i&lt;len;i++)\n     不会导致反复查找DOM树\n</code></pre><h1 id=\"3、-按HTML查找\"><a href=\"#3、-按HTML查找\" class=\"headerlink\" title=\"3、 按HTML查找:\"></a>3、 按HTML查找:</h1><pre><code>    优: 范围可大可小,可设置条件\na、按id查找: var elem=document.getElementById(&quot;id&quot;)\n  强调: 1. 只能在document对象上调用\n       2. 返回一个元素对象\nb、按标签名查找:\n    var elems=parent.getElementsByTagName(&quot;标签名&quot;);\n  强调: 1. 可在任意父元素上\n       2. 返回多个元素组成的集合\n       3. 不但查找直接子元素，还查找所有后代元素\nc、按name属性查找: 了解\n   专门找表单中有name属性的表单元素\n    var elems=document.getElementsByName(&quot;name&quot;)\n    强调: 1. 只能在document上调用\n         2. 返回多个元素组成的集合\nd、按class属性查找:\n    var elems=parent.getElementsByClassName(&quot;class&quot;)\n    强调: 1. 可在任意父元素上调用\n         2. 返回多个元素组成的集合\n         3. 不要求完整匹配，只要包含即可！\n缺: 每次只能按一个条件查找\n   如果条件复杂，就无法一句话获得想要的元素\n</code></pre><h1 id=\"4、-按选择器查找\"><a href=\"#4、-按选择器查找\" class=\"headerlink\" title=\"4、 按选择器查找:\"></a>4、 按选择器查找:</h1><pre><code>a. 只找一个元素:\n  var elem=parent.querySelector(&quot;selector&quot;);\nb. 找多个元素\n  var elems=parent.querySelectorAll(&quot;selector&quot;);\n</code></pre><h1 id=\"5、-总结\"><a href=\"#5、-总结\" class=\"headerlink\" title=\"5、 总结:\"></a>5、 总结:</h1><pre><code> A首次查找:\n    1. 如果条件简单: 按HTML查找: id, 标签, className\n    2. 如果条件复杂: 按选择器查找:\n B已经获得一个元素，找周围相邻: 按节点间关系\n鄙视: 按HTML查找 vs 按选择器查找\n 1.使用的难易程度: 当条件复杂时:\n    按选择器查找——简单, 按HTML查找——繁琐\n 2.返回值:\n    getElementsByTagName() 返回多个元素的*动态*集合\n      什么是动态集合: 不实际存储对象的属性值，每次访问，都要重新查找DOM树\n    querySelectorAll()  返回多个元素的*非动态*集合\n      什么是非动态集合: 实际存储对象的所有属性值，即使反复访问集合，也不会导致反复查找DOM树\n 3.单次效率:\n    按HTML查找——效率高!\n    按选择器查找——效率低\n</code></pre><h1 id=\"6、-修改-内容-属性-样式\"><a href=\"#6、-修改-内容-属性-样式\" class=\"headerlink\" title=\"6、 修改: (内容, 属性, 样式)\"></a>6、 修改: (内容, 属性, 样式)</h1><pre><code>1. 修改:\n标准属性: 2种:\n  1. 核心DOM: 操作一切结构化文档的API(HTML，XML)\n    elem.attributes集合: 保存了当前元素的所有属性节点\n    获取属性值: elem.getAttribute(&quot;属性名&quot;)\n    修改属性值: elem.setAttribute(&quot;属性名&quot;,&quot;值&quot;)\n    判断是否包含属性: elem.hasAttribute(&quot;属性名&quot;)\n    移除属性: elem.removeAttribute(&quot;属性名&quot;)\n  2. HTML DOM: 对部分常用DOM API的简化版本\n     HTML DOM将标准属性都预定义在元素对象中\n    获取属性值: elem.属性名\n    修改属性值: elem.属性名=&quot;值&quot;;\n    判断是否包含属性: elem.属性名===&quot;&quot; 不包含\n    移除属性: elem.属性名=&quot;&quot;\n    特例: class属性和ES标准中的class重名\n          -&gt; DOM -&gt; className\n    自定义属性: 比如: data-toggle=&quot;dropdown&quot;\n      HTML DOM不能操作自定义属性\n      暂时只能用核心DOM操作:\n    三大状态: disabled  selected   checked\n      核心DOM无法操作三大状态属性\n      HTMLDOM: elem.disabled elem.selected  elem.checked\n            值都是bool类型true/false\n</code></pre><h1 id=\"6-1、修改css样式\"><a href=\"#6-1、修改css样式\" class=\"headerlink\" title=\"6.1、修改css样式:\"></a>6.1、修改css样式:</h1><pre><code>1. 仅获取/修改内联样式:  elem.style.css属性名\n  问题1: css属性名有的带-\n  解决: 所有css属性名都要去横线变驼峰\n     比如: background-color: backgroundColor\n          list-style-type: listStyleType\n  问题2: 所有数值类型的属性值都是带单位的字符串\n  解决: 获取时: 都要去单位，转数值\n        修改时: 将单位拼回数值\n  问题3: 仅能获得内联样式, 无法获得样式表中的样式\n  解决: 计算后的样式: 最终应用到元素上的完整样式\n    何时: 只要希望获得元素完整的样式时\n    如何: 2步:\n      1. 获得完整样式对象style\n        var style=getComputedStyle(elem)\n      2. 获得style对象中的css属性\n        style.css属性名\n     强调: style对象中的样式都是只读\n结论: 1. 获取样式: getComputedStyle\n     2. 修改样式: elem.style.css属性名\n2. 运行时修改样式表中的样式:\n  Step1: 获得样式表对象:\n   var sheet=document.styleSheets[i]\n  Step2: 获得样式表对象中某个CSSRule(一个选择器{})\n   var rule=sheet.cssRules[i]\n  Step3: 修改rule.style.css属性名=值\n</code></pre><h1 id=\"7、-添加和删除\"><a href=\"#7、-添加和删除\" class=\"headerlink\" title=\"7、 添加和删除:\"></a>7、 添加和删除:</h1><pre><code>添加: 3步:\n Step1: 创建空元素:\n  var a=document.createElement(&quot;a&quot;);\n  &lt;a&gt;&lt;/a&gt;\n Step2: 设置关键属性:\n     a.href=&quot;http://tmooc.cn&quot;\n     a.innerHTML=&quot;go to tmooc&quot;;\n  &lt;a href=&quot;http://tmooc.cn&quot;&gt;go to tmooc&lt;/a&gt;\n Step3: 将元素添加到DOM树: 3种:\n   1. 末尾追加: parent.appendChild(child)\n   2. 中间插入: parent.insertBefore(child, oldChild)\n   3. 替换: parent.replaceChild(child, oldChild)\n</code></pre><h1 id=\"优化-尽量少的修改DOM树\"><a href=\"#优化-尽量少的修改DOM树\" class=\"headerlink\" title=\"优化: 尽量少的修改DOM树\"></a>优化: 尽量少的修改DOM树</h1><pre><code>原因: 页面加载过程:\n  html -&gt; DOM Tree(松树)\n           ↓\n        render Tree(圣诞树)-&gt; layout(计算绝对布局)-&gt;paint\n           ↑                 最耗时\n  css  -&gt; cssRules(装饰品)\n  每次修改DOM树，都会导致重新layout，耗时。\n如何: 2种:\n 1. 如果同时添加父元素和子元素时，应该先在内存将子元素都添加到父元素中，再将父元素一次性整体添加到DOM树\n    结果: 只触发一次layout\n</code></pre><h1 id=\"1、-HTML-DOM-常用对象-对常用HTML元素操作的简化\"><a href=\"#1、-HTML-DOM-常用对象-对常用HTML元素操作的简化\" class=\"headerlink\" title=\"1、 HTML DOM 常用对象: 对常用HTML元素操作的简化\"></a>1、 HTML DOM 常用对象: 对常用HTML元素操作的简化</h1><pre><code>Select: 代表页面上的一个select元素\n 属性: select.value 当前选中项的value\n                 没有value，就返回选中项的内容\n      select.options 保存select下所有option元素对象\n        相当于: select.getElementsByTagName(&quot;option&quot;)\n        select.options.length 保存select下option的个数\n        清空select下所有option: select.options.length=0;\n      select.length 等效于select.options.length\n        清空select下所有option: select.length=0;\n                               select.innerHTML=&quot;&quot;;\n      select.selectedIndex 当前选中项的下标\n  事件: onchange 当选中项发生改变时\n  方法: select.add(option) 向select中添加一个option\n         相当于: select.appendChild(option)\n         不支持文档片段\n       select.remove(i) 移除select中i位置的一个option\nOption: 代表页面上的一个option元素\n  创建: var opt=new Option(text,value);\n     创建一个option对象，同时设置opt的内容为text，设置opt的值为value\n     相当于: var opt=document.createElement(&quot;option&quot;);\n            opt.innerHTML=text;\n            opt.value=value;\n  属性: .text 代替.innerHTML\n       .index  表示当前option在select下的下标位置\n</code></pre><h1 id=\"Table-代表网页中一个table元素\"><a href=\"#Table-代表网页中一个table元素\" class=\"headerlink\" title=\"Table: 代表网页中一个table元素\"></a>Table: 代表网页中一个table元素</h1><pre><code> 管着行分组：\n   添加行分组: var 行分组=table.createTHead|TBody|TFoot();\n       强调: 即创建，同时又将行分组添加到table\n   删除行分组: table.deleteTHead|TFoot()\n   获取行分组: table.tHead|tFoot\n              table.tBodies[i]\n行分组: THead TBody TFoot\n  管着行:\n   添加行: var tr=行分组.insertRow(i)\n       在行分组中i位置插入一个新行\n       强调: 中间插入行，原i位置的行向后顺移\n       固定套路: 1. 末尾追加一个新行: 行分组.insertRow()\n                2. 开头插入: 行分组.insertRow(0)\n   删除行: 行分组.deleteRow(i)\n       删除行分组中第i行\n       强调: i是当前行在行分组内的相对下标位置\n   获取行: 行分组.rows\n\n行: tr\n  管着td:\n    添加td: var td=tr.insertCell(i);\n        省略i表示右侧末尾追加\n        insertCell不支持添加th，只能添加td\n    删除td: tr.deleteCell(i);\n    获取td: tr.cells\n\n删除行:\n tr上都有一个属性: tr.rowIndex 行在整个表的绝对下标\n 问题：行分组，无法使用tr.rowIndex删除行。\n 解决: table.deleteRow(tr.rowIndex)\n 总结: 今后，删除行都用table.deleteRow(tr.rowIndex)\n</code></pre><h1 id=\"form-代表页面上一个表单元素\"><a href=\"#form-代表页面上一个表单元素\" class=\"headerlink\" title=\"form: 代表页面上一个表单元素\"></a>form: 代表页面上一个表单元素</h1><pre><code> 获取: var form=document.forms[i/id]\n 属性: form.elements 保存了表单中所有表单元素的数组\n        包括: input   select   textarea  button\n      form.elements.length 获得表单中表单元素的个数\n      form.length =&gt; form.elements.length\n 方法: form.submit();  用于手动提交表单\n 事件: form.onsubmit  以任何方式提交表单之前自动触发\n          常用于在提交之前，验证所有表单元素的内容\n表单元素:\n 获取: var elem=form.elements[i/id/name]\n        简写: 如果表单元素有name属性: form.name\n 方法: elem.focus() 让elem获得焦点\n      elem.blur()  让elem失去焦点\n\nImage: 代表页面上一个img元素\n  创建: var img=new Image();\n</code></pre><h1 id=\"DOM总结-查找-gt-绑定事件-gt-查找-gt-修改-添加-删除\"><a href=\"#DOM总结-查找-gt-绑定事件-gt-查找-gt-修改-添加-删除\" class=\"headerlink\" title=\"DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除\"></a>DOM总结: 查找-&gt;绑定事件-&gt;查找-&gt;修改/添加/删除</h1><pre><code>查找: 4种:\n  1. 不需要查找可直接获得: html  head  body  form\n  2. 节点间关系: 节点树/元素树\n      鄙视: 递归遍历\n  3. 按HTML: 4种: ById, ByTagName, ByName, ByClassName\n  4. 按选择器: 2种:\n      只找一个: querySelector()\n      找多个: querySelectorAll()\n修改:\n  内容: .innerHTML  .textContent/.innerText  .value\n  属性:\n    1. 标准属性: 1. 核心DOM; 2. HTML DOM\n    2. 自定义属性: 核心DOM\n    3. 状态属性: HTML DOM\n  样式:\n    修改: elem.style.css属性=值\n    获取: var style=getComputedStyle(elem)\n         style.css属性 ——只读\n    可通过修改class属性批量应用修改多个css属性\n添加: 3步:\n   1. createElement,\n   2.设置关键属性,\n   3. appendChild/insertBefore/replaceChild\n  优化: 尽量少的操作DOM树\n  如何: 2种:\n   1. 同时添加父子元素: 先将子元素加入父元素，再将父元素整体添加到页面\n   2. 同时添加多个平级子元素: fragment\n删除: parent.removeChild(child)\nHTML DOM: Select/Option  Table/...  From/Element  Image\n过渡动画: 2步:\n  css中: 添加transition\n  js中: 修改css属性值\n   不支持transition: display  zIndex\n   支持: width  height  opacity   bottom/top/left/right ...\n</code></pre><h1 id=\"2、BOM-Browser-Object-Model\"><a href=\"#2、BOM-Browser-Object-Model\" class=\"headerlink\" title=\"2、BOM: Browser Object Model\"></a>2、BOM: Browser Object Model</h1><pre><code>什么是: 专门操作浏览器窗口的API\n比如: alert prompt confirm\n问题: 1. 没有标准——兼容性问题;\n     2. 不可定制\nwindow对象: 2个角色:\n  1. 代替ES中的Global充当全局作用域对象\n  2. 封装所有BOM和DOM的API\n\n打开超链接: 4种:\n  1. 在当前窗口打开，可后退\n    html: &lt;a href=&quot;url&quot; target=&quot;_self&quot;&gt;&lt;/a&gt;\n    js: /*window.*/open(&quot;url&quot;,&quot;_self&quot;)\n  2. 在当前窗口打开，不可后退\n    js: location.replace(&quot;url&quot;);\n       用新url代替history中当前url，结果: 无法后退\n  3. 在新窗口打开，可打开多个\n    html: &lt;a href=&quot;url&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt;\n    js: open(&quot;url&quot;,&quot;_blank&quot;)\n  4. 在新窗口打开，只能打开一个\n    html: &lt;a href=&quot;url&quot; target=&quot;自定义name属性值&quot;&gt;&lt;/a&gt;\n    js: open(&quot;url&quot;,&quot;自定义name属性值&quot;)\n    原理: 内存中每个窗口都有一个唯一的name属性来唯一标示一个窗口\n      浏览器规定，相同name属性的窗口只能打开一个\n    其实: html中的target属性就是在设置新窗口的name属性值。\n    如果target中使用自定义的窗口名，则只能打开一个\n    预定义:\n      _self: 默认使用当前窗口自己的name属性\n           结果，新窗口覆盖当前窗口\n      _blank: 意为不指定窗口名, 浏览器会随机生成不同的窗口名。\n           结果: 每次打开新窗口都随机生成不同的name\n                 结果: 可打开任意多个\n</code></pre><h1 id=\"定时器-2种\"><a href=\"#定时器-2种\" class=\"headerlink\" title=\"定时器: 2种:\"></a>定时器: 2种:</h1><pre><code>1. 周期性定时器:\n  什么是: 让程序按照指定时间间隔，反复执行一项任务\n  何时: 只要让程序按照指定时间间隔，反复执行一项任务\n  如何: 3件事:\n    1. 任务函数: 让定时器反复调用的函数\n    2. 启动定时器:\n     var timer=setInterval(任务函数, 间隔的毫秒数)\n    3. 停止定时器: clearInterval(timer)\n        问题: timer中的序号会残留在timer变量中\n        解决: 停止定时器后，主动清空timer\n             timer=null\n  停止定时器: 2种:\n    1. 用户手动停止定时器: 用按钮调用clearInterval\n    2. 自动停止定时器: 在任务函数中:\n       1. 设定临界条件\n       2. 如果达到临界条件就自动调用clearInterval\n\n2. 一次性定时器:\n 什么是: 让程序先等待一段时间，再自动执行一次任务\n         执行一次后，定时器自动停止\n 何时: 只要先等待，再执行一次任务\n 如何: 三件事\n   1. 任务函数\n   2. 启动: var timer=setTimeout(任务函数, 等待的毫秒数)\n   3. 停止: clearTimeout(timer)\n鄙视: 定时器中的函数，只能在主程序所有程序执行后才能执行\n\nfor(var i=0;i&lt;3;i++){\n  setTimeout(function(){\n    console.log(i);\n  },0);\n}//结果: 3 3 3\n//alert(&quot;Hello&quot;) 如果不点确定，则永远不输出333\n</code></pre><h1 id=\"window\"><a href=\"#window\" class=\"headerlink\" title=\"window:\"></a>window:</h1><h1 id=\"history，location，document，navigator，screen，event\"><a href=\"#history，location，document，navigator，screen，event\" class=\"headerlink\" title=\"history，location，document，navigator，screen，event\"></a>history，location，document，navigator，screen，event</h1><pre><code>history: 保存当前窗口打开后，成功访问过的历史记录的栈\n  history封装的非常严密\n  只能前进，后退，刷新: history.go(n)\n   前进: go(1)  后退:go(-1)  刷新:go(0)\n\nlocation: 专门保存当前窗口正在打开的url的对象\n 属性: location.href 保存了完整的url\n        在当前窗口打开: location.href=新url\n      location.protocol: 协议\n            .host: 主机名+端口号\n            .hostname: 主机名\n            .port: 端口号\n      location.pathname: 相对路径\n            .hash: 锚点地址#xxx\n            .search: 表单提交后地址栏中的查询字符串\n                   ?变量名=值&amp;变量名=值&amp;...\n 方法:\n   1. 替换history中当前url,实现进制后退:\n     location.replace(&quot;新url&quot;)\n   2. 在当前页面打开，可后退:\n     location.assign(&quot;新url&quot;)\n       =&gt; location.href=&quot;新url&quot;\n        =&gt; location=&quot;新url&quot;\n   3. 刷新页面:  location.reload(false/true);\n     鄙视: false/true的差别\n       浏览器本地是有缓存的\n         浏览器的缓存中会保存css，图片等静态资源\n       每次请求时，首先查看缓存中是否有想要文件\n         没有想要文件，或文件过期，才去服务器下载新文件\n       reload(false) 优先使用本地缓存的文件\n       reload(true) 强制去服务器下载新文件\n     查 浏览器缓存的原理！\n</code></pre><h1 id=\"1、event\"><a href=\"#1、event\" class=\"headerlink\" title=\"1、event\"></a>1、event</h1><pre><code>绑定事件: 2种:\n 1. 在HTML中绑定: &lt;ANY on事件名=&quot;js语句&quot;\n    问题: 不符合内容与行为分离的原则——不便于维护\n 2. 在js中动态绑定: 2种:\n    1. 一个事件只绑定一个处理函数:\n       elem.on事件名=function(){\n         //this-&gt;elem\n       }\n       解除绑定: elem.on事件名=null;\n       问题: 每个事件只能绑定一个处理函数\n       解决:\n    2. 一个事件可同时绑定多个处理函数:\n       elem.addEventListener(&quot;事件名&quot;,function(){\n         //this-&gt;elem\n       })\n       解除绑定:\n        elem.removeEventListener(&quot;事件名&quot;,&quot;函数名&quot;);\n        强调: 如果一个事件处理函数可能被动态移除，则绑定时，不能使用匿名函数，必须使用有名称的函数\n\n    事件模型: DOM标准: 3个阶段\n      1. 捕获: 由外向内，记录各级父元素绑定的事件处理函数\n      2. 目标触发: 首先执行目标元素上的事件处理函数\n      3. 冒泡: 由内向外，反向执行捕获阶段记录的处理函数\n\n    事件对象: 事件发生时自动创建的\n             封装事件信息\n             提供操作事件的API 的对象\n      何时: 只要希望获得事件信息或修改事件的默认行为\n      如何: 事件对象，在事件发生时，通常作为事件处理函数的第一个参数，默认自动传入！\n          .on事件名=function(e){\n             //e会自动获得事件对象\n          }\n    阻止蔓延/冒泡: e.stopPropagation();\n    利用冒泡:\n      优化: 尽量少的添加事件监听\n      原理: 因为浏览器触发事件监听，是采用遍历查找的方式。添加的监听越多，遍历的速度越慢\n      如何: 如果多个子元素都要绑定相同的事件\n          只要在父元素绑定一次，所有子元素即可共用\n      难题:\n         1. 获得目标元素:\n            不能用this, 因为this指父元素\n            应该用e.target，保存实际点击的目标元素\n         2. 鉴别目标元素:\n            先判断目标元素的nodeName或className...\n            只有目标元素符合要求时，才执行事件操作\n    取消事件/阻止默认行为: e.preventDefault();\n    事件坐标: 3对儿:\n      1. 相对于整个屏幕左上角的坐标: e.screenX|screenY\n      2. 相对于文档显示区左上角的坐标: e.clientX|clientY\n      3. 相对于当前元素左上角的坐标: e.offsetX|offsetY\n\n    页面滚动:\n      事件: window.onscroll\n      获得页面滚动位置: document.body.scrollTop\n          页面超出文档显示区顶部的距离\n</code></pre>"},{"title":"css3笔记","date":"2016-07-01T07:38:52.000Z","_content":"# 1、复杂选择器 \n\n# 1、兄弟选择器 \n       通过兄弟级别的位置关系来匹配页面元素\n        注意，兄弟选择器，只能向后找，不能向前找\n        语法：\n            相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素\n            选择器1+选择器2\n            如：div+p   #top+.important\n                    通用兄弟选择器：用于匹配某元素后面所有的兄弟元素\n            选择器1~选择器2\n                如#d1~div\n# 2、属性选择器\n    通过元素所附带的属性及其值来匹配页面中的元素\n    语法：\n        基础属性选择器  [attr]\n            匹配页面中的有附带attr属性的元素\n        elem[attr]\n            elem:表示任意元素名称\n            attr:表示任意属性名称\n            匹配页面中附带attr属性的elem元素\n            如：div[id]:匹配页面中所有附带id属性的div元素\n        [attr1][attr2][attr3]\n            匹配页面中同时附带attr1和attr2属性的所有元素\n            如 input[name][hype]\n        [attr=value]\n            匹配页面中所有attr属性的值为value的元素\n            如input[type=text]\n        [class~=value]\n            主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素\n        [attr^=value]\n            匹配以value值作为开始的attr属性的元素\n        [attr$=value]\n            匹配以value值作为结束的attr属性的元素\n        [attr*=value]\n            匹配attr属性值中包含value字符的所有元素\n# 3、伪类选择器\n    目标伪类\n        突出显示活动的HTML锚元素\n        语法： ：target\n    结构伪类\n        通过元素之间的结构关系来匹配元素\n        ：first-child     获取属于其父元素中的首个子元素\n        ：last-child     获取属于其父元素中的尾（最后）子元素\n        :nth-child(N)  获取属于其父元素中的第N个子元素\n        ：empty   空的，匹配没有子元素的元素，包含文本\n        ：only-child   匹配属于其父元素中的唯一子元素\n    否定伪类\n        把匹配某选择器元素排除出去\n        ：not(选择器 )\n# 4、伪元素选择器\n    伪类与伪元素\n        伪类：匹配元素不同的状态\n        伪元素：是匹配元素中的内容\n    语法：\n        ：first-letter\n        ::first-letter  匹配某元素的首字符\n        ：first-line    匹配某元素的首行字符\n        ：：selection 匹配用户选取的内容部分\n    ：和：：区别\n        在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示\n        在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示\n# 2、内容生成\n    通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容\n    伪元素选择器\n        ：before   定位到元素内容区域之前\n        ：after    定位到元素内容区域之后\n    语法：\n        属性：content\n        取值：普通文本\n             图像，url(...)\n             计数器\n    问题处理：\n        外边距溢出问题\n            为父元素添加边框\n            使用父元素的内边距取代子元素的外边距\n            在父元素的第一个或最后一个子元素位置处增加一个空的table\n        浮动元素父元素的高度问题\n# 3、弹性布局\n    flexible box,可伸缩布局，为普通布局带来更大的灵活性\n    基本概念‘\n        flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放\n        flex项目：简称项目，存放在flex容器中的内容\n    \n    语法：\n        容器：display\n            取值：flex 将块级元素变为flex容器\n                  inline-flex  将行内元素变为flex容器\n            注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用\n        容器属性;\n            该组属性要添加在容器元素上，控制子元素的位置\n            flex-direction  决定主轴的方向（main-axsis）\n                取值：\n                    row  主轴为水平方向的轴，起点在容器左端，默认值\n                    row-reverse 主轴为水平方向的轴，起点在容器右端\n                    column  主轴为交叉轴，起点在容器的顶端\n                    column-reverse 主轴为交叉轴，起点在容器的底端\n            flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行\n                取值：\n                    nowrap     默认值，不换行\n                    wrap        换行\n                    wrap-reverse  反方向换行\n            flex-flow   dirextion和wrap的缩写方式\n                取值：\n                    row nowrap 默认值\n                    direction wrap\n            justify-content   定义项目在主轴上的对齐方式\n                取值：\n                    flex-start   主轴起点对齐\n                    flex-end   主轴终点对齐\n                    center    居中对齐\n                    space-between  两端对齐，项目之间的距离是相等的\n                    space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍\n            align-items  定义项目在交叉轴的对齐方式（单行项目有效）\n                取值：\n                    flex-start  交叉轴起点对齐\n                    flex-end   交叉轴终点对齐\n                    center     交叉轴中间对齐\n                    baseline   基线对齐，以所有项目中的第一行文本为准\n                    stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度\n            align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效\n                取值：\n                    flex-start   交叉轴顶端对齐\n                    flex-end    交叉轴底端对齐\n                    center      交叉轴中间对齐\n                    space-between  与交叉轴两端对齐\n                    space-around     项目与项目间对齐\n        项目属性：\n            该组属性主要设置于项目中\n            order  定义项目在排列顺序，值越小，越靠前，默认为0\n            flex-grow  指定项目的放大比例，默认为0，即不放大\n            flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小\n            flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小\n            flex  是flex-grow,flex-shrink,flex-basis 的简写模式\n                取值，auto  相当于1  1   auto\n                     none  相当于0 0  auto\n                     flex-grow【,flex-shrink,flex-basis】\n            align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果\n                取值： auto 默认值，使用\n                      flex-start   主轴起点对齐\n                    flex-end   主轴终点对齐\n                    center    居中对齐\n                    base-line\n                    stretch\n# 4、CSS Hack 兼容性\n    标准模式和混杂模式和准标准模式\n    IE6之前，没有兼容性说法\n    IE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式\n        混杂模式  无标准可言\n            编写代码时，不写<!doctylpe>就是混杂模式，采用的是IE5.5的内核进行渲染\n        标准模式  安全支持\n        准标准模式，即支持标准，也同时向前兼容非标准代码\n    如何根据不同的浏览器编写不同的css\n        css类内部Hack\n            在属性名称前和值添加前后缀以便识别不同的浏览器\n        选择器Hack\n            在选择器前添加特殊标识以便识别不同的浏览器\n        头部引用hack\n            通过html的条件注释来判断浏览器版本，去执行不同的CSS\n            条件注释\n                条件：\n                    gt:判断当前浏览器是否大于指定定版本\n                    gte：判断当前浏览器是否大于等于指定定版本\n                    it:   判断当前浏览器是否小于指定版本\n                    ite： 判断当前浏览器是否小于等于指定版本\n                    !：   判断当前浏览器是否为非指定版本\n                        <!--[if !IE 8]>\n                            该段内容在除IE8以外浏览器中显示\n                        <![endif]-->\n# 5、转换\n    \n    说明：改变元素在页面中的形状，角度 大小 位置的一种效果\n        允许进行2D和3D方向的转换\n        2D转换：在平面中进行的操作\n        3D转换：在空间中进行的操作\n    转换属性：\n        rtansform:为元素应用2D或3D转换效果\n            取值：none;  没有效果\n                transform-functions:一组转换函数\n                    位移转换函数：translate()\n                    改变形状函数：skew()\n                    注意：如果指定多个转换函数的话中间用空格隔开\n        转换原点：\n            属性：transform-origin\n            默认：转换原点在元素中心处\n            取值：轴线给值\n                两个轴线值：X Y\n                三个轴线值：X Y Z\n    2D转换\n        位移：改变元素在页面中的位置\n            语法：transform\n                fransform(x)  改变元素在X轴的位置\n                fransform(X ,Y)  改变元素在两轴的位置\n                fransformX(X) 只在X轴上位置移动\n                fransformY(Y)  只在Y轴上位置移动\n        缩放： 改变元素在页面中的大小】\n            语法：transform\n                scale(value)  表示两轴等比缩放\n                    取值：默认  为1\n                        放大   为大于1的数值\n                        缩小   为0~1之间小数\n                        返转   负数\n                sacle(X,Y)\n                saclex(y)\n                sacley(y)\n        旋转：改变元素在页面上的角度，要根据原点实现转换效果\n            语法：transform\n                rotate(ndeg)\n                    n 取值正，顺时针旋转\n                    n 取值负，逆时针旋转\n                    deg 为角度\n                    0~360范围\n            注意：转换原点问题\n                元素坐标轴也跟着旋转\n        倾斜：改变元素在页面中形状\n            语法：transform\n                skew(xdeg)  横向倾斜指定度数\n                    x 取值正，y轴逆时针倾斜一定角度\n                      取值负，Y轴顺时针倾斜一定角度\n                skew(xdeg,ydeg)\n                skewx(xdeg)\n                skewy(ydeg)\n    3D转换\n        感觉空间\n        属性：perspetive 假定人眼到投射平面的距离\n        注意：该属性要放在3D转换元素的父元素上\n            兼容性chrome和safari需要加前缀\n                -wedkit-perspective:500px;\n        旋转：以X轴中心轴旋转\n                rotatex(xdeg)\n              以Y轴中心轴旋转\n                rotatey(ydeg)\n              以Z轴中心轴旋转\n                rotatez(zdeg)\n            取值：正  顺时针\n                负   逆时针\n            以多个轴同时进行旋转\n                rotate3d(x ,y, z ,ndeg)\n                    x y z 取值为1，该轴参与旋转\n                    x y z  取值为0 ，该轴不参与旋转\n        位移：改变元素在Z轴上的位置\n            语法：transform\n                translatez(z)\n    \n                transform-style\n                    取值：flat  默认值，子元素不保留3D位置\n                         preserve-3D  子元素保留3D位置\n# 6、过渡\n\n    作用效果：使得css属性值在一段时间内平缓变化的效果\n    要素与属性：\n        指定过渡属性：指定哪个属性值在变化时使用过渡效果展示\n            transition-property: 属性名称（width）\n                          all   全部属性\n                          none\n            允许设置过渡效果的属性：\n                颜色属性\n                渐变属性\n                取值为数字属性\n                转换属性 transition-property:transform;\n                visibility属性\n                阴影属性\n        指定过渡时长\n            transition-duration: 以S、MS为单位数值\n        指定过渡时速曲线函数  可选\n            transition-timing-function\n                取值：ease  默认值，慢速开始，快速变快，慢速结束\n                     linear  匀速进行\n                     ease-in   慢速开始，快速结束\n                     ease-out  快速开始，慢速结束\n                     ease-in-out  慢速开始和结束，先加速后减速\n        指定过渡的延迟时间   可选\n            transition-delay\n                取值：以S或MS做为单位\n        简写属性：transition:prop duration  timing-fun delay;\n            多个过渡效果\n                transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;\n    触发过渡条件\n        将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,\n        将过渡编写在:hover,:active伪类中\n# 7、动画\n    \n    使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀\n    动画使用步骤\n        声明动画\n            指定动画名称\n            指定动画中的关键帧（keyframes）\n                时间点（以百分比描述时间）\n                元素状态（CSS样式）\n        为元素调用动画\n            指定调用动画的名称以及执行时长\n    语法：\n        声明动画     注意前缀，兼容性问题\n            <style>\n                @keyframes 名称{\n                    0%{   动画开始时，元素的状态   }\n                    。。。。\n                    100%{  动画结束时，元素的状态  }\n                }\n            </style>\n        调用动画(animation)\n            animation-name  指定调用动画名称\n            animation-duration   指定动画周期时长，以S或MS为单位\n            animation-timing-function  指定动画的速度时间出线函数\n                取值：ease  默认值，慢速开始，快速变快，慢速结束\n                     linear  匀速进行\n                     ease-in   慢速开始，快速结束\n                     ease-out  快速开始，慢速结束\n                     ease-in-out  慢速开始和结束，先加速后减速\n            animation-delay  指定动画延迟时间\n            animation-iteration-count  指定动画播放次数\n                取值：默认1次，具体数值\n                    infinite:无限次播放\n            animation-direction  指定动画的播放方向\n                取值：normal  从0%~100%\n                    reverse  从100%~0%\n                    alternate  轮流来回播放 奇数 0%~100%\n                                     偶数 100%~0%\n            animation  简写方式\n                取值：name  duration  timing-fun delay  iteration-count direction;\n            animation-fill-mode  指定动画播放之前、之后的填充模式\n                取值：none  默认值\n                     forwards  动画播放完成后，保持在最后一帧的位置\n                     backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置\n                     both 同时应用在开始和最后的位置帧上\n            animation-play-state  动画播放状态\n                取值：paused 暂停\n                     running 播放\n                     \n                        ","source":"_posts/css3.md","raw":"---\ntitle: css3笔记\ndate: 2016-07-01 15:38:52\ntags:\n---\n# 1、复杂选择器 \n\n# 1、兄弟选择器 \n       通过兄弟级别的位置关系来匹配页面元素\n        注意，兄弟选择器，只能向后找，不能向前找\n        语法：\n            相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素\n            选择器1+选择器2\n            如：div+p   #top+.important\n                    通用兄弟选择器：用于匹配某元素后面所有的兄弟元素\n            选择器1~选择器2\n                如#d1~div\n# 2、属性选择器\n    通过元素所附带的属性及其值来匹配页面中的元素\n    语法：\n        基础属性选择器  [attr]\n            匹配页面中的有附带attr属性的元素\n        elem[attr]\n            elem:表示任意元素名称\n            attr:表示任意属性名称\n            匹配页面中附带attr属性的elem元素\n            如：div[id]:匹配页面中所有附带id属性的div元素\n        [attr1][attr2][attr3]\n            匹配页面中同时附带attr1和attr2属性的所有元素\n            如 input[name][hype]\n        [attr=value]\n            匹配页面中所有attr属性的值为value的元素\n            如input[type=text]\n        [class~=value]\n            主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素\n        [attr^=value]\n            匹配以value值作为开始的attr属性的元素\n        [attr$=value]\n            匹配以value值作为结束的attr属性的元素\n        [attr*=value]\n            匹配attr属性值中包含value字符的所有元素\n# 3、伪类选择器\n    目标伪类\n        突出显示活动的HTML锚元素\n        语法： ：target\n    结构伪类\n        通过元素之间的结构关系来匹配元素\n        ：first-child     获取属于其父元素中的首个子元素\n        ：last-child     获取属于其父元素中的尾（最后）子元素\n        :nth-child(N)  获取属于其父元素中的第N个子元素\n        ：empty   空的，匹配没有子元素的元素，包含文本\n        ：only-child   匹配属于其父元素中的唯一子元素\n    否定伪类\n        把匹配某选择器元素排除出去\n        ：not(选择器 )\n# 4、伪元素选择器\n    伪类与伪元素\n        伪类：匹配元素不同的状态\n        伪元素：是匹配元素中的内容\n    语法：\n        ：first-letter\n        ::first-letter  匹配某元素的首字符\n        ：first-line    匹配某元素的首行字符\n        ：：selection 匹配用户选取的内容部分\n    ：和：：区别\n        在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示\n        在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示\n# 2、内容生成\n    通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容\n    伪元素选择器\n        ：before   定位到元素内容区域之前\n        ：after    定位到元素内容区域之后\n    语法：\n        属性：content\n        取值：普通文本\n             图像，url(...)\n             计数器\n    问题处理：\n        外边距溢出问题\n            为父元素添加边框\n            使用父元素的内边距取代子元素的外边距\n            在父元素的第一个或最后一个子元素位置处增加一个空的table\n        浮动元素父元素的高度问题\n# 3、弹性布局\n    flexible box,可伸缩布局，为普通布局带来更大的灵活性\n    基本概念‘\n        flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放\n        flex项目：简称项目，存放在flex容器中的内容\n    \n    语法：\n        容器：display\n            取值：flex 将块级元素变为flex容器\n                  inline-flex  将行内元素变为flex容器\n            注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用\n        容器属性;\n            该组属性要添加在容器元素上，控制子元素的位置\n            flex-direction  决定主轴的方向（main-axsis）\n                取值：\n                    row  主轴为水平方向的轴，起点在容器左端，默认值\n                    row-reverse 主轴为水平方向的轴，起点在容器右端\n                    column  主轴为交叉轴，起点在容器的顶端\n                    column-reverse 主轴为交叉轴，起点在容器的底端\n            flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行\n                取值：\n                    nowrap     默认值，不换行\n                    wrap        换行\n                    wrap-reverse  反方向换行\n            flex-flow   dirextion和wrap的缩写方式\n                取值：\n                    row nowrap 默认值\n                    direction wrap\n            justify-content   定义项目在主轴上的对齐方式\n                取值：\n                    flex-start   主轴起点对齐\n                    flex-end   主轴终点对齐\n                    center    居中对齐\n                    space-between  两端对齐，项目之间的距离是相等的\n                    space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍\n            align-items  定义项目在交叉轴的对齐方式（单行项目有效）\n                取值：\n                    flex-start  交叉轴起点对齐\n                    flex-end   交叉轴终点对齐\n                    center     交叉轴中间对齐\n                    baseline   基线对齐，以所有项目中的第一行文本为准\n                    stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度\n            align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效\n                取值：\n                    flex-start   交叉轴顶端对齐\n                    flex-end    交叉轴底端对齐\n                    center      交叉轴中间对齐\n                    space-between  与交叉轴两端对齐\n                    space-around     项目与项目间对齐\n        项目属性：\n            该组属性主要设置于项目中\n            order  定义项目在排列顺序，值越小，越靠前，默认为0\n            flex-grow  指定项目的放大比例，默认为0，即不放大\n            flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小\n            flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小\n            flex  是flex-grow,flex-shrink,flex-basis 的简写模式\n                取值，auto  相当于1  1   auto\n                     none  相当于0 0  auto\n                     flex-grow【,flex-shrink,flex-basis】\n            align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果\n                取值： auto 默认值，使用\n                      flex-start   主轴起点对齐\n                    flex-end   主轴终点对齐\n                    center    居中对齐\n                    base-line\n                    stretch\n# 4、CSS Hack 兼容性\n    标准模式和混杂模式和准标准模式\n    IE6之前，没有兼容性说法\n    IE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式\n        混杂模式  无标准可言\n            编写代码时，不写<!doctylpe>就是混杂模式，采用的是IE5.5的内核进行渲染\n        标准模式  安全支持\n        准标准模式，即支持标准，也同时向前兼容非标准代码\n    如何根据不同的浏览器编写不同的css\n        css类内部Hack\n            在属性名称前和值添加前后缀以便识别不同的浏览器\n        选择器Hack\n            在选择器前添加特殊标识以便识别不同的浏览器\n        头部引用hack\n            通过html的条件注释来判断浏览器版本，去执行不同的CSS\n            条件注释\n                条件：\n                    gt:判断当前浏览器是否大于指定定版本\n                    gte：判断当前浏览器是否大于等于指定定版本\n                    it:   判断当前浏览器是否小于指定版本\n                    ite： 判断当前浏览器是否小于等于指定版本\n                    !：   判断当前浏览器是否为非指定版本\n                        <!--[if !IE 8]>\n                            该段内容在除IE8以外浏览器中显示\n                        <![endif]-->\n# 5、转换\n    \n    说明：改变元素在页面中的形状，角度 大小 位置的一种效果\n        允许进行2D和3D方向的转换\n        2D转换：在平面中进行的操作\n        3D转换：在空间中进行的操作\n    转换属性：\n        rtansform:为元素应用2D或3D转换效果\n            取值：none;  没有效果\n                transform-functions:一组转换函数\n                    位移转换函数：translate()\n                    改变形状函数：skew()\n                    注意：如果指定多个转换函数的话中间用空格隔开\n        转换原点：\n            属性：transform-origin\n            默认：转换原点在元素中心处\n            取值：轴线给值\n                两个轴线值：X Y\n                三个轴线值：X Y Z\n    2D转换\n        位移：改变元素在页面中的位置\n            语法：transform\n                fransform(x)  改变元素在X轴的位置\n                fransform(X ,Y)  改变元素在两轴的位置\n                fransformX(X) 只在X轴上位置移动\n                fransformY(Y)  只在Y轴上位置移动\n        缩放： 改变元素在页面中的大小】\n            语法：transform\n                scale(value)  表示两轴等比缩放\n                    取值：默认  为1\n                        放大   为大于1的数值\n                        缩小   为0~1之间小数\n                        返转   负数\n                sacle(X,Y)\n                saclex(y)\n                sacley(y)\n        旋转：改变元素在页面上的角度，要根据原点实现转换效果\n            语法：transform\n                rotate(ndeg)\n                    n 取值正，顺时针旋转\n                    n 取值负，逆时针旋转\n                    deg 为角度\n                    0~360范围\n            注意：转换原点问题\n                元素坐标轴也跟着旋转\n        倾斜：改变元素在页面中形状\n            语法：transform\n                skew(xdeg)  横向倾斜指定度数\n                    x 取值正，y轴逆时针倾斜一定角度\n                      取值负，Y轴顺时针倾斜一定角度\n                skew(xdeg,ydeg)\n                skewx(xdeg)\n                skewy(ydeg)\n    3D转换\n        感觉空间\n        属性：perspetive 假定人眼到投射平面的距离\n        注意：该属性要放在3D转换元素的父元素上\n            兼容性chrome和safari需要加前缀\n                -wedkit-perspective:500px;\n        旋转：以X轴中心轴旋转\n                rotatex(xdeg)\n              以Y轴中心轴旋转\n                rotatey(ydeg)\n              以Z轴中心轴旋转\n                rotatez(zdeg)\n            取值：正  顺时针\n                负   逆时针\n            以多个轴同时进行旋转\n                rotate3d(x ,y, z ,ndeg)\n                    x y z 取值为1，该轴参与旋转\n                    x y z  取值为0 ，该轴不参与旋转\n        位移：改变元素在Z轴上的位置\n            语法：transform\n                translatez(z)\n    \n                transform-style\n                    取值：flat  默认值，子元素不保留3D位置\n                         preserve-3D  子元素保留3D位置\n# 6、过渡\n\n    作用效果：使得css属性值在一段时间内平缓变化的效果\n    要素与属性：\n        指定过渡属性：指定哪个属性值在变化时使用过渡效果展示\n            transition-property: 属性名称（width）\n                          all   全部属性\n                          none\n            允许设置过渡效果的属性：\n                颜色属性\n                渐变属性\n                取值为数字属性\n                转换属性 transition-property:transform;\n                visibility属性\n                阴影属性\n        指定过渡时长\n            transition-duration: 以S、MS为单位数值\n        指定过渡时速曲线函数  可选\n            transition-timing-function\n                取值：ease  默认值，慢速开始，快速变快，慢速结束\n                     linear  匀速进行\n                     ease-in   慢速开始，快速结束\n                     ease-out  快速开始，慢速结束\n                     ease-in-out  慢速开始和结束，先加速后减速\n        指定过渡的延迟时间   可选\n            transition-delay\n                取值：以S或MS做为单位\n        简写属性：transition:prop duration  timing-fun delay;\n            多个过渡效果\n                transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;\n    触发过渡条件\n        将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,\n        将过渡编写在:hover,:active伪类中\n# 7、动画\n    \n    使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀\n    动画使用步骤\n        声明动画\n            指定动画名称\n            指定动画中的关键帧（keyframes）\n                时间点（以百分比描述时间）\n                元素状态（CSS样式）\n        为元素调用动画\n            指定调用动画的名称以及执行时长\n    语法：\n        声明动画     注意前缀，兼容性问题\n            <style>\n                @keyframes 名称{\n                    0%{   动画开始时，元素的状态   }\n                    。。。。\n                    100%{  动画结束时，元素的状态  }\n                }\n            </style>\n        调用动画(animation)\n            animation-name  指定调用动画名称\n            animation-duration   指定动画周期时长，以S或MS为单位\n            animation-timing-function  指定动画的速度时间出线函数\n                取值：ease  默认值，慢速开始，快速变快，慢速结束\n                     linear  匀速进行\n                     ease-in   慢速开始，快速结束\n                     ease-out  快速开始，慢速结束\n                     ease-in-out  慢速开始和结束，先加速后减速\n            animation-delay  指定动画延迟时间\n            animation-iteration-count  指定动画播放次数\n                取值：默认1次，具体数值\n                    infinite:无限次播放\n            animation-direction  指定动画的播放方向\n                取值：normal  从0%~100%\n                    reverse  从100%~0%\n                    alternate  轮流来回播放 奇数 0%~100%\n                                     偶数 100%~0%\n            animation  简写方式\n                取值：name  duration  timing-fun delay  iteration-count direction;\n            animation-fill-mode  指定动画播放之前、之后的填充模式\n                取值：none  默认值\n                     forwards  动画播放完成后，保持在最后一帧的位置\n                     backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置\n                     both 同时应用在开始和最后的位置帧上\n            animation-play-state  动画播放状态\n                取值：paused 暂停\n                     running 播放\n                     \n                        ","slug":"css3","published":1,"updated":"2017-08-02T11:09:16.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5v07ehg0002cwuvxpphybb1","content":"<h1 id=\"1、复杂选择器\"><a href=\"#1、复杂选择器\" class=\"headerlink\" title=\"1、复杂选择器\"></a>1、复杂选择器</h1><h1 id=\"1、兄弟选择器\"><a href=\"#1、兄弟选择器\" class=\"headerlink\" title=\"1、兄弟选择器\"></a>1、兄弟选择器</h1><pre><code>通过兄弟级别的位置关系来匹配页面元素\n 注意，兄弟选择器，只能向后找，不能向前找\n 语法：\n     相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素\n     选择器1+选择器2\n     如：div+p   #top+.important\n             通用兄弟选择器：用于匹配某元素后面所有的兄弟元素\n     选择器1~选择器2\n         如#d1~div\n</code></pre><h1 id=\"2、属性选择器\"><a href=\"#2、属性选择器\" class=\"headerlink\" title=\"2、属性选择器\"></a>2、属性选择器</h1><pre><code>通过元素所附带的属性及其值来匹配页面中的元素\n语法：\n    基础属性选择器  [attr]\n        匹配页面中的有附带attr属性的元素\n    elem[attr]\n        elem:表示任意元素名称\n        attr:表示任意属性名称\n        匹配页面中附带attr属性的elem元素\n        如：div[id]:匹配页面中所有附带id属性的div元素\n    [attr1][attr2][attr3]\n        匹配页面中同时附带attr1和attr2属性的所有元素\n        如 input[name][hype]\n    [attr=value]\n        匹配页面中所有attr属性的值为value的元素\n        如input[type=text]\n    [class~=value]\n        主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素\n    [attr^=value]\n        匹配以value值作为开始的attr属性的元素\n    [attr$=value]\n        匹配以value值作为结束的attr属性的元素\n    [attr*=value]\n        匹配attr属性值中包含value字符的所有元素\n</code></pre><h1 id=\"3、伪类选择器\"><a href=\"#3、伪类选择器\" class=\"headerlink\" title=\"3、伪类选择器\"></a>3、伪类选择器</h1><pre><code>目标伪类\n    突出显示活动的HTML锚元素\n    语法： ：target\n结构伪类\n    通过元素之间的结构关系来匹配元素\n    ：first-child     获取属于其父元素中的首个子元素\n    ：last-child     获取属于其父元素中的尾（最后）子元素\n    :nth-child(N)  获取属于其父元素中的第N个子元素\n    ：empty   空的，匹配没有子元素的元素，包含文本\n    ：only-child   匹配属于其父元素中的唯一子元素\n否定伪类\n    把匹配某选择器元素排除出去\n    ：not(选择器 )\n</code></pre><h1 id=\"4、伪元素选择器\"><a href=\"#4、伪元素选择器\" class=\"headerlink\" title=\"4、伪元素选择器\"></a>4、伪元素选择器</h1><pre><code>伪类与伪元素\n    伪类：匹配元素不同的状态\n    伪元素：是匹配元素中的内容\n语法：\n    ：first-letter\n    ::first-letter  匹配某元素的首字符\n    ：first-line    匹配某元素的首行字符\n    ：：selection 匹配用户选取的内容部分\n：和：：区别\n    在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示\n    在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示\n</code></pre><h1 id=\"2、内容生成\"><a href=\"#2、内容生成\" class=\"headerlink\" title=\"2、内容生成\"></a>2、内容生成</h1><pre><code>通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容\n伪元素选择器\n    ：before   定位到元素内容区域之前\n    ：after    定位到元素内容区域之后\n语法：\n    属性：content\n    取值：普通文本\n         图像，url(...)\n         计数器\n问题处理：\n    外边距溢出问题\n        为父元素添加边框\n        使用父元素的内边距取代子元素的外边距\n        在父元素的第一个或最后一个子元素位置处增加一个空的table\n    浮动元素父元素的高度问题\n</code></pre><h1 id=\"3、弹性布局\"><a href=\"#3、弹性布局\" class=\"headerlink\" title=\"3、弹性布局\"></a>3、弹性布局</h1><pre><code>flexible box,可伸缩布局，为普通布局带来更大的灵活性\n基本概念‘\n    flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放\n    flex项目：简称项目，存放在flex容器中的内容\n\n语法：\n    容器：display\n        取值：flex 将块级元素变为flex容器\n              inline-flex  将行内元素变为flex容器\n        注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用\n    容器属性;\n        该组属性要添加在容器元素上，控制子元素的位置\n        flex-direction  决定主轴的方向（main-axsis）\n            取值：\n                row  主轴为水平方向的轴，起点在容器左端，默认值\n                row-reverse 主轴为水平方向的轴，起点在容器右端\n                column  主轴为交叉轴，起点在容器的顶端\n                column-reverse 主轴为交叉轴，起点在容器的底端\n        flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行\n            取值：\n                nowrap     默认值，不换行\n                wrap        换行\n                wrap-reverse  反方向换行\n        flex-flow   dirextion和wrap的缩写方式\n            取值：\n                row nowrap 默认值\n                direction wrap\n        justify-content   定义项目在主轴上的对齐方式\n            取值：\n                flex-start   主轴起点对齐\n                flex-end   主轴终点对齐\n                center    居中对齐\n                space-between  两端对齐，项目之间的距离是相等的\n                space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍\n        align-items  定义项目在交叉轴的对齐方式（单行项目有效）\n            取值：\n                flex-start  交叉轴起点对齐\n                flex-end   交叉轴终点对齐\n                center     交叉轴中间对齐\n                baseline   基线对齐，以所有项目中的第一行文本为准\n                stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度\n        align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效\n            取值：\n                flex-start   交叉轴顶端对齐\n                flex-end    交叉轴底端对齐\n                center      交叉轴中间对齐\n                space-between  与交叉轴两端对齐\n                space-around     项目与项目间对齐\n    项目属性：\n        该组属性主要设置于项目中\n        order  定义项目在排列顺序，值越小，越靠前，默认为0\n        flex-grow  指定项目的放大比例，默认为0，即不放大\n        flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小\n        flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小\n        flex  是flex-grow,flex-shrink,flex-basis 的简写模式\n            取值，auto  相当于1  1   auto\n                 none  相当于0 0  auto\n                 flex-grow【,flex-shrink,flex-basis】\n        align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果\n            取值： auto 默认值，使用\n                  flex-start   主轴起点对齐\n                flex-end   主轴终点对齐\n                center    居中对齐\n                base-line\n                stretch\n</code></pre><h1 id=\"4、CSS-Hack-兼容性\"><a href=\"#4、CSS-Hack-兼容性\" class=\"headerlink\" title=\"4、CSS Hack 兼容性\"></a>4、CSS Hack 兼容性</h1><pre><code>标准模式和混杂模式和准标准模式\nIE6之前，没有兼容性说法\nIE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式\n    混杂模式  无标准可言\n        编写代码时，不写&lt;!doctylpe&gt;就是混杂模式，采用的是IE5.5的内核进行渲染\n    标准模式  安全支持\n    准标准模式，即支持标准，也同时向前兼容非标准代码\n如何根据不同的浏览器编写不同的css\n    css类内部Hack\n        在属性名称前和值添加前后缀以便识别不同的浏览器\n    选择器Hack\n        在选择器前添加特殊标识以便识别不同的浏览器\n    头部引用hack\n        通过html的条件注释来判断浏览器版本，去执行不同的CSS\n        条件注释\n            条件：\n                gt:判断当前浏览器是否大于指定定版本\n                gte：判断当前浏览器是否大于等于指定定版本\n                it:   判断当前浏览器是否小于指定版本\n                ite： 判断当前浏览器是否小于等于指定版本\n                !：   判断当前浏览器是否为非指定版本\n                    &lt;!--[if !IE 8]&gt;\n                        该段内容在除IE8以外浏览器中显示\n                    &lt;![endif]--&gt;\n</code></pre><h1 id=\"5、转换\"><a href=\"#5、转换\" class=\"headerlink\" title=\"5、转换\"></a>5、转换</h1><pre><code>说明：改变元素在页面中的形状，角度 大小 位置的一种效果\n    允许进行2D和3D方向的转换\n    2D转换：在平面中进行的操作\n    3D转换：在空间中进行的操作\n转换属性：\n    rtansform:为元素应用2D或3D转换效果\n        取值：none;  没有效果\n            transform-functions:一组转换函数\n                位移转换函数：translate()\n                改变形状函数：skew()\n                注意：如果指定多个转换函数的话中间用空格隔开\n    转换原点：\n        属性：transform-origin\n        默认：转换原点在元素中心处\n        取值：轴线给值\n            两个轴线值：X Y\n            三个轴线值：X Y Z\n2D转换\n    位移：改变元素在页面中的位置\n        语法：transform\n            fransform(x)  改变元素在X轴的位置\n            fransform(X ,Y)  改变元素在两轴的位置\n            fransformX(X) 只在X轴上位置移动\n            fransformY(Y)  只在Y轴上位置移动\n    缩放： 改变元素在页面中的大小】\n        语法：transform\n            scale(value)  表示两轴等比缩放\n                取值：默认  为1\n                    放大   为大于1的数值\n                    缩小   为0~1之间小数\n                    返转   负数\n            sacle(X,Y)\n            saclex(y)\n            sacley(y)\n    旋转：改变元素在页面上的角度，要根据原点实现转换效果\n        语法：transform\n            rotate(ndeg)\n                n 取值正，顺时针旋转\n                n 取值负，逆时针旋转\n                deg 为角度\n                0~360范围\n        注意：转换原点问题\n            元素坐标轴也跟着旋转\n    倾斜：改变元素在页面中形状\n        语法：transform\n            skew(xdeg)  横向倾斜指定度数\n                x 取值正，y轴逆时针倾斜一定角度\n                  取值负，Y轴顺时针倾斜一定角度\n            skew(xdeg,ydeg)\n            skewx(xdeg)\n            skewy(ydeg)\n3D转换\n    感觉空间\n    属性：perspetive 假定人眼到投射平面的距离\n    注意：该属性要放在3D转换元素的父元素上\n        兼容性chrome和safari需要加前缀\n            -wedkit-perspective:500px;\n    旋转：以X轴中心轴旋转\n            rotatex(xdeg)\n          以Y轴中心轴旋转\n            rotatey(ydeg)\n          以Z轴中心轴旋转\n            rotatez(zdeg)\n        取值：正  顺时针\n            负   逆时针\n        以多个轴同时进行旋转\n            rotate3d(x ,y, z ,ndeg)\n                x y z 取值为1，该轴参与旋转\n                x y z  取值为0 ，该轴不参与旋转\n    位移：改变元素在Z轴上的位置\n        语法：transform\n            translatez(z)\n\n            transform-style\n                取值：flat  默认值，子元素不保留3D位置\n                     preserve-3D  子元素保留3D位置\n</code></pre><h1 id=\"6、过渡\"><a href=\"#6、过渡\" class=\"headerlink\" title=\"6、过渡\"></a>6、过渡</h1><pre><code>作用效果：使得css属性值在一段时间内平缓变化的效果\n要素与属性：\n    指定过渡属性：指定哪个属性值在变化时使用过渡效果展示\n        transition-property: 属性名称（width）\n                      all   全部属性\n                      none\n        允许设置过渡效果的属性：\n            颜色属性\n            渐变属性\n            取值为数字属性\n            转换属性 transition-property:transform;\n            visibility属性\n            阴影属性\n    指定过渡时长\n        transition-duration: 以S、MS为单位数值\n    指定过渡时速曲线函数  可选\n        transition-timing-function\n            取值：ease  默认值，慢速开始，快速变快，慢速结束\n                 linear  匀速进行\n                 ease-in   慢速开始，快速结束\n                 ease-out  快速开始，慢速结束\n                 ease-in-out  慢速开始和结束，先加速后减速\n    指定过渡的延迟时间   可选\n        transition-delay\n            取值：以S或MS做为单位\n    简写属性：transition:prop duration  timing-fun delay;\n        多个过渡效果\n            transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;\n触发过渡条件\n    将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,\n    将过渡编写在:hover,:active伪类中\n</code></pre><h1 id=\"7、动画\"><a href=\"#7、动画\" class=\"headerlink\" title=\"7、动画\"></a>7、动画</h1><pre><code>使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀\n动画使用步骤\n    声明动画\n        指定动画名称\n        指定动画中的关键帧（keyframes）\n            时间点（以百分比描述时间）\n            元素状态（CSS样式）\n    为元素调用动画\n        指定调用动画的名称以及执行时长\n语法：\n    声明动画     注意前缀，兼容性问题\n        &lt;style&gt;\n            @keyframes 名称{\n                0%{   动画开始时，元素的状态   }\n                。。。。\n                100%{  动画结束时，元素的状态  }\n            }\n        &lt;/style&gt;\n    调用动画(animation)\n        animation-name  指定调用动画名称\n        animation-duration   指定动画周期时长，以S或MS为单位\n        animation-timing-function  指定动画的速度时间出线函数\n            取值：ease  默认值，慢速开始，快速变快，慢速结束\n                 linear  匀速进行\n                 ease-in   慢速开始，快速结束\n                 ease-out  快速开始，慢速结束\n                 ease-in-out  慢速开始和结束，先加速后减速\n        animation-delay  指定动画延迟时间\n        animation-iteration-count  指定动画播放次数\n            取值：默认1次，具体数值\n                infinite:无限次播放\n        animation-direction  指定动画的播放方向\n            取值：normal  从0%~100%\n                reverse  从100%~0%\n                alternate  轮流来回播放 奇数 0%~100%\n                                 偶数 100%~0%\n        animation  简写方式\n            取值：name  duration  timing-fun delay  iteration-count direction;\n        animation-fill-mode  指定动画播放之前、之后的填充模式\n            取值：none  默认值\n                 forwards  动画播放完成后，保持在最后一帧的位置\n                 backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置\n                 both 同时应用在开始和最后的位置帧上\n        animation-play-state  动画播放状态\n            取值：paused 暂停\n                 running 播放\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、复杂选择器\"><a href=\"#1、复杂选择器\" class=\"headerlink\" title=\"1、复杂选择器\"></a>1、复杂选择器</h1><h1 id=\"1、兄弟选择器\"><a href=\"#1、兄弟选择器\" class=\"headerlink\" title=\"1、兄弟选择器\"></a>1、兄弟选择器</h1><pre><code>通过兄弟级别的位置关系来匹配页面元素\n 注意，兄弟选择器，只能向后找，不能向前找\n 语法：\n     相邻兄弟选择器：通过相邻（紧紧挨着的）位置关系匹配元素\n     选择器1+选择器2\n     如：div+p   #top+.important\n             通用兄弟选择器：用于匹配某元素后面所有的兄弟元素\n     选择器1~选择器2\n         如#d1~div\n</code></pre><h1 id=\"2、属性选择器\"><a href=\"#2、属性选择器\" class=\"headerlink\" title=\"2、属性选择器\"></a>2、属性选择器</h1><pre><code>通过元素所附带的属性及其值来匹配页面中的元素\n语法：\n    基础属性选择器  [attr]\n        匹配页面中的有附带attr属性的元素\n    elem[attr]\n        elem:表示任意元素名称\n        attr:表示任意属性名称\n        匹配页面中附带attr属性的elem元素\n        如：div[id]:匹配页面中所有附带id属性的div元素\n    [attr1][attr2][attr3]\n        匹配页面中同时附带attr1和attr2属性的所有元素\n        如 input[name][hype]\n    [attr=value]\n        匹配页面中所有attr属性的值为value的元素\n        如input[type=text]\n    [class~=value]\n        主要使用在多类选择器上，匹配页面中class属性值中包含value选择器的元素\n    [attr^=value]\n        匹配以value值作为开始的attr属性的元素\n    [attr$=value]\n        匹配以value值作为结束的attr属性的元素\n    [attr*=value]\n        匹配attr属性值中包含value字符的所有元素\n</code></pre><h1 id=\"3、伪类选择器\"><a href=\"#3、伪类选择器\" class=\"headerlink\" title=\"3、伪类选择器\"></a>3、伪类选择器</h1><pre><code>目标伪类\n    突出显示活动的HTML锚元素\n    语法： ：target\n结构伪类\n    通过元素之间的结构关系来匹配元素\n    ：first-child     获取属于其父元素中的首个子元素\n    ：last-child     获取属于其父元素中的尾（最后）子元素\n    :nth-child(N)  获取属于其父元素中的第N个子元素\n    ：empty   空的，匹配没有子元素的元素，包含文本\n    ：only-child   匹配属于其父元素中的唯一子元素\n否定伪类\n    把匹配某选择器元素排除出去\n    ：not(选择器 )\n</code></pre><h1 id=\"4、伪元素选择器\"><a href=\"#4、伪元素选择器\" class=\"headerlink\" title=\"4、伪元素选择器\"></a>4、伪元素选择器</h1><pre><code>伪类与伪元素\n    伪类：匹配元素不同的状态\n    伪元素：是匹配元素中的内容\n语法：\n    ：first-letter\n    ::first-letter  匹配某元素的首字符\n    ：first-line    匹配某元素的首行字符\n    ：：selection 匹配用户选取的内容部分\n：和：：区别\n    在CSS2.1中，伪类选择器和仿元素选择器都是用：来表示\n    在CSS3中，所有伪类选择器用：表示，所有的伪元素选择器用：：表示\n</code></pre><h1 id=\"2、内容生成\"><a href=\"#2、内容生成\" class=\"headerlink\" title=\"2、内容生成\"></a>2、内容生成</h1><pre><code>通过CSS动态的向某个元素的内容区域之前、之后增加一部分内容\n伪元素选择器\n    ：before   定位到元素内容区域之前\n    ：after    定位到元素内容区域之后\n语法：\n    属性：content\n    取值：普通文本\n         图像，url(...)\n         计数器\n问题处理：\n    外边距溢出问题\n        为父元素添加边框\n        使用父元素的内边距取代子元素的外边距\n        在父元素的第一个或最后一个子元素位置处增加一个空的table\n    浮动元素父元素的高度问题\n</code></pre><h1 id=\"3、弹性布局\"><a href=\"#3、弹性布局\" class=\"headerlink\" title=\"3、弹性布局\"></a>3、弹性布局</h1><pre><code>flexible box,可伸缩布局，为普通布局带来更大的灵活性\n基本概念‘\n    flex容器：简称容器，将元素设置为flex容器后，其子元素允许实现灵活的位置摆放\n    flex项目：简称项目，存放在flex容器中的内容\n\n语法：\n    容器：display\n        取值：flex 将块级元素变为flex容器\n              inline-flex  将行内元素变为flex容器\n        注意：将元素设置为flex布局后，子元素的float,clear,vertical-align属性将失去作用\n    容器属性;\n        该组属性要添加在容器元素上，控制子元素的位置\n        flex-direction  决定主轴的方向（main-axsis）\n            取值：\n                row  主轴为水平方向的轴，起点在容器左端，默认值\n                row-reverse 主轴为水平方向的轴，起点在容器右端\n                column  主轴为交叉轴，起点在容器的顶端\n                column-reverse 主轴为交叉轴，起点在容器的底端\n        flex-wrap   当一条轴线（一行）排列不下时，子元素将如何换行\n            取值：\n                nowrap     默认值，不换行\n                wrap        换行\n                wrap-reverse  反方向换行\n        flex-flow   dirextion和wrap的缩写方式\n            取值：\n                row nowrap 默认值\n                direction wrap\n        justify-content   定义项目在主轴上的对齐方式\n            取值：\n                flex-start   主轴起点对齐\n                flex-end   主轴终点对齐\n                center    居中对齐\n                space-between  两端对齐，项目之间的距离是相等的\n                space-around  每个项目两侧间距是相等的 项目与项目之间的间距，要比项目与父元素之间的间距大一倍\n        align-items  定义项目在交叉轴的对齐方式（单行项目有效）\n            取值：\n                flex-start  交叉轴起点对齐\n                flex-end   交叉轴终点对齐\n                center     交叉轴中间对齐\n                baseline   基线对齐，以所有项目中的第一行文本为准\n                stretch    默认值，如果项目不设置高度或为auto时，那么项目将占满整个容器的高度\n        align-content  定义了多跟轴线的对齐方式，如果项目只一根轴线，该属性无效\n            取值：\n                flex-start   交叉轴顶端对齐\n                flex-end    交叉轴底端对齐\n                center      交叉轴中间对齐\n                space-between  与交叉轴两端对齐\n                space-around     项目与项目间对齐\n    项目属性：\n        该组属性主要设置于项目中\n        order  定义项目在排列顺序，值越小，越靠前，默认为0\n        flex-grow  指定项目的放大比例，默认为0，即不放大\n        flex-shrink 指定项目的缩小比例，默认为1，即空间不足时，等比缩小，为0时不缩小\n        flex-basis  指定项目占据主轴的剩余空间大小 auto 默认值，项目本身大小\n        flex  是flex-grow,flex-shrink,flex-basis 的简写模式\n            取值，auto  相当于1  1   auto\n                 none  相当于0 0  auto\n                 flex-grow【,flex-shrink,flex-basis】\n        align-self  允许定义当个项目与其他项目不一样的交叉轴对齐方式（类似于align-items）,能够覆盖align-items的效果\n            取值： auto 默认值，使用\n                  flex-start   主轴起点对齐\n                flex-end   主轴终点对齐\n                center    居中对齐\n                base-line\n                stretch\n</code></pre><h1 id=\"4、CSS-Hack-兼容性\"><a href=\"#4、CSS-Hack-兼容性\" class=\"headerlink\" title=\"4、CSS Hack 兼容性\"></a>4、CSS Hack 兼容性</h1><pre><code>标准模式和混杂模式和准标准模式\nIE6之前，没有兼容性说法\nIE6之后，各个浏览器追求标准统一，开始支持标准，IE的其它浏览器要向前兼容，所以出现各种模式\n    混杂模式  无标准可言\n        编写代码时，不写&lt;!doctylpe&gt;就是混杂模式，采用的是IE5.5的内核进行渲染\n    标准模式  安全支持\n    准标准模式，即支持标准，也同时向前兼容非标准代码\n如何根据不同的浏览器编写不同的css\n    css类内部Hack\n        在属性名称前和值添加前后缀以便识别不同的浏览器\n    选择器Hack\n        在选择器前添加特殊标识以便识别不同的浏览器\n    头部引用hack\n        通过html的条件注释来判断浏览器版本，去执行不同的CSS\n        条件注释\n            条件：\n                gt:判断当前浏览器是否大于指定定版本\n                gte：判断当前浏览器是否大于等于指定定版本\n                it:   判断当前浏览器是否小于指定版本\n                ite： 判断当前浏览器是否小于等于指定版本\n                !：   判断当前浏览器是否为非指定版本\n                    &lt;!--[if !IE 8]&gt;\n                        该段内容在除IE8以外浏览器中显示\n                    &lt;![endif]--&gt;\n</code></pre><h1 id=\"5、转换\"><a href=\"#5、转换\" class=\"headerlink\" title=\"5、转换\"></a>5、转换</h1><pre><code>说明：改变元素在页面中的形状，角度 大小 位置的一种效果\n    允许进行2D和3D方向的转换\n    2D转换：在平面中进行的操作\n    3D转换：在空间中进行的操作\n转换属性：\n    rtansform:为元素应用2D或3D转换效果\n        取值：none;  没有效果\n            transform-functions:一组转换函数\n                位移转换函数：translate()\n                改变形状函数：skew()\n                注意：如果指定多个转换函数的话中间用空格隔开\n    转换原点：\n        属性：transform-origin\n        默认：转换原点在元素中心处\n        取值：轴线给值\n            两个轴线值：X Y\n            三个轴线值：X Y Z\n2D转换\n    位移：改变元素在页面中的位置\n        语法：transform\n            fransform(x)  改变元素在X轴的位置\n            fransform(X ,Y)  改变元素在两轴的位置\n            fransformX(X) 只在X轴上位置移动\n            fransformY(Y)  只在Y轴上位置移动\n    缩放： 改变元素在页面中的大小】\n        语法：transform\n            scale(value)  表示两轴等比缩放\n                取值：默认  为1\n                    放大   为大于1的数值\n                    缩小   为0~1之间小数\n                    返转   负数\n            sacle(X,Y)\n            saclex(y)\n            sacley(y)\n    旋转：改变元素在页面上的角度，要根据原点实现转换效果\n        语法：transform\n            rotate(ndeg)\n                n 取值正，顺时针旋转\n                n 取值负，逆时针旋转\n                deg 为角度\n                0~360范围\n        注意：转换原点问题\n            元素坐标轴也跟着旋转\n    倾斜：改变元素在页面中形状\n        语法：transform\n            skew(xdeg)  横向倾斜指定度数\n                x 取值正，y轴逆时针倾斜一定角度\n                  取值负，Y轴顺时针倾斜一定角度\n            skew(xdeg,ydeg)\n            skewx(xdeg)\n            skewy(ydeg)\n3D转换\n    感觉空间\n    属性：perspetive 假定人眼到投射平面的距离\n    注意：该属性要放在3D转换元素的父元素上\n        兼容性chrome和safari需要加前缀\n            -wedkit-perspective:500px;\n    旋转：以X轴中心轴旋转\n            rotatex(xdeg)\n          以Y轴中心轴旋转\n            rotatey(ydeg)\n          以Z轴中心轴旋转\n            rotatez(zdeg)\n        取值：正  顺时针\n            负   逆时针\n        以多个轴同时进行旋转\n            rotate3d(x ,y, z ,ndeg)\n                x y z 取值为1，该轴参与旋转\n                x y z  取值为0 ，该轴不参与旋转\n    位移：改变元素在Z轴上的位置\n        语法：transform\n            translatez(z)\n\n            transform-style\n                取值：flat  默认值，子元素不保留3D位置\n                     preserve-3D  子元素保留3D位置\n</code></pre><h1 id=\"6、过渡\"><a href=\"#6、过渡\" class=\"headerlink\" title=\"6、过渡\"></a>6、过渡</h1><pre><code>作用效果：使得css属性值在一段时间内平缓变化的效果\n要素与属性：\n    指定过渡属性：指定哪个属性值在变化时使用过渡效果展示\n        transition-property: 属性名称（width）\n                      all   全部属性\n                      none\n        允许设置过渡效果的属性：\n            颜色属性\n            渐变属性\n            取值为数字属性\n            转换属性 transition-property:transform;\n            visibility属性\n            阴影属性\n    指定过渡时长\n        transition-duration: 以S、MS为单位数值\n    指定过渡时速曲线函数  可选\n        transition-timing-function\n            取值：ease  默认值，慢速开始，快速变快，慢速结束\n                 linear  匀速进行\n                 ease-in   慢速开始，快速结束\n                 ease-out  快速开始，慢速结束\n                 ease-in-out  慢速开始和结束，先加速后减速\n    指定过渡的延迟时间   可选\n        transition-delay\n            取值：以S或MS做为单位\n    简写属性：transition:prop duration  timing-fun delay;\n        多个过渡效果\n            transition:prop1 duration1 timing-fun1 delay1,prop2 duration2 timing-fun2 delay2........;\n触发过渡条件\n    将过渡编写在元素声明的样式中，由:hover,:active等，进行触发,\n    将过渡编写在:hover,:active伪类中\n</code></pre><h1 id=\"7、动画\"><a href=\"#7、动画\" class=\"headerlink\" title=\"7、动画\"></a>7、动画</h1><pre><code>使元素从一种样式逐渐变化为另一种样式的过程，与动画相关的属性，增加浏览器前缀\n动画使用步骤\n    声明动画\n        指定动画名称\n        指定动画中的关键帧（keyframes）\n            时间点（以百分比描述时间）\n            元素状态（CSS样式）\n    为元素调用动画\n        指定调用动画的名称以及执行时长\n语法：\n    声明动画     注意前缀，兼容性问题\n        &lt;style&gt;\n            @keyframes 名称{\n                0%{   动画开始时，元素的状态   }\n                。。。。\n                100%{  动画结束时，元素的状态  }\n            }\n        &lt;/style&gt;\n    调用动画(animation)\n        animation-name  指定调用动画名称\n        animation-duration   指定动画周期时长，以S或MS为单位\n        animation-timing-function  指定动画的速度时间出线函数\n            取值：ease  默认值，慢速开始，快速变快，慢速结束\n                 linear  匀速进行\n                 ease-in   慢速开始，快速结束\n                 ease-out  快速开始，慢速结束\n                 ease-in-out  慢速开始和结束，先加速后减速\n        animation-delay  指定动画延迟时间\n        animation-iteration-count  指定动画播放次数\n            取值：默认1次，具体数值\n                infinite:无限次播放\n        animation-direction  指定动画的播放方向\n            取值：normal  从0%~100%\n                reverse  从100%~0%\n                alternate  轮流来回播放 奇数 0%~100%\n                                 偶数 100%~0%\n        animation  简写方式\n            取值：name  duration  timing-fun delay  iteration-count direction;\n        animation-fill-mode  指定动画播放之前、之后的填充模式\n            取值：none  默认值\n                 forwards  动画播放完成后，保持在最后一帧的位置\n                 backwards 动画播放前，延迟时间内，动画保持在开始第一帧上的位置\n                 both 同时应用在开始和最后的位置帧上\n        animation-play-state  动画播放状态\n            取值：paused 暂停\n                 running 播放\n</code></pre>"},{"title":"10个JavaScript难点","date":"2017-03-02T11:56:30.000Z","_content":"# 10个JavaScript难点概括\n\n# 1. 立即执行函数\n\n立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：\n\n    (function() {\n         // 代码\n         // ...\n    })();\nfunction(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。\n\n# 2. 闭包\n\n对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。\n\n    function f1()\n    {\n        var N = 0; // N是f1函数的局部变量\n    \n    function f2() // f2是f1函数的内部函数，是闭包\n    {\n        N += 1; // 内部函数f2中使用了外部函数f1中的变量N\n        console.log(N);\n    }\n    return f2;\n    }\n    var result = f1();\n    result(); // 输出1\n    result(); // 输出2\n    result(); // 输出3\n代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！\n\n# 3. 使用闭包定义私有变量\n\n通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：\n\n    function Product() {\n        var name;\n        this.setName = function(value) {\n            name = value;\n        };\n        this.getName = function() {\n            return name;\n        };\n    }\n    var p = new Product();\n    p.setName(\"Fundebug\");\n    console.log(p.name); // 输出undefined\n    console.log(p.getName()); // 输出Fundebug\n    代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。\n\n# 4. prototype\n\n每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。\n\n    function Rectangle(x, y)\n    {\n        this._length = x;\n        this._breadth = y;\n    }\n    Rectangle.prototype.getDimensions = function()\n    {\n        return {\n            length: this._length,\n            breadth: this._breadth\n        };\n    };\n    var x = new Rectangle(3, 4);\n    var y = new Rectangle(4, 3);\n    console.log(x.getDimensions()); // { length: 3, breadth: 4 }\n    console.log(y.getDimensions()); // { length: 4, breadth: 3 }\n代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。\n\n# 5. 模块化\n\nJavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery\n\n    var module = (function() {\n        var N = 5;\n        function print(x) {\n            console.log(\"The result is: \" + x);\n        }\n        function add(a) {\n            var x = a + N;\n            print(x);\n        }\n        return {\n            description: \"This is description\",\n            add: add\n        };\n    })();\n    console.log(module.description); // 输出\"this is description\" \n    module.add(5); // 输出“The result is: 10”\n所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。\n\n# 6. 变量提升\n\nJavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。\n\n但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：\n\n    console.log(y);  // 输出undefined\n    y = 2; // 初始化y\n    上面的代码等价于下面的代码：\n    \n    var y;  // 声明y\n    console.log(y);  // 输出undefined\n    y = 2; // 初始化y\n    为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。\n\n# 7. 柯里化\n\n柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n    var add = function(x) {\n        return function(y) {\n            return x + y;\n        };\n    };\n    console.log(add(1)(1)); // 输出2\n    var add1 = add(1);\n    console.log(add1(1)); // 输出2\n    var add10 = add(10);\n    console.log(add10(1)); // 输出11\n    代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。\n\n# 8. apply, call与bind方法\n\nJavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。\n\n三者之中，call方法是最简单的，它等价于指定this值调用函数：\n\n    var user = {\n        name: \"Rahul Mhatre\",\n        whatIsYourName: function() {\n            console.log(this.name);\n        }\n    };\n    user.whatIsYourName(); // 输出\"Rahul Mhatre\",\n    var user2 = {\n        name: \"Neha Sampat\"\n    };\n    user.whatIsYourName.call(user2); // 输出\"Neha Sampat\"\napply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定：\n\n    apply(thisArg, [argsArray])\n    call(thisArg, arg1, arg2, …)\n    var user = {\n        greet: \"Hello!\",\n        greetUser: function(userName) {\n            console.log(this.greet + \" \" + userName);\n        }\n    };\n    var greet1 = {\n        greet: \"Hola\"\n    };\n    user.greetUser.call(greet1, \"Rahul\"); // 输出\"Hola Rahul\"\n    user.greetUser.apply(greet1, [\"Rahul\"]); // 输出\"Hola Rahul\"\n使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：\n\n    var user = {\n         greet: \"Hello!\",\n         greetUser: function(userName) {\n         console.log(this.greet + \" \" + userName);\n         }\n    };\n    var greetHola = user.greetUser.bind({greet: \"Hola\"});\n    var greetBonjour = user.greetUser.bind({greet: \"Bonjour\"});\n    greetHola(\"Rahul\") // 输出\"Hola Rahul\"\n    greetBonjour(\"Rahul\") // 输出\"Bonjour Rahul\"\n# 9. Memoization\n\nMemoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。\n\n    function memoizeFunction(func)\n    {\n        var cache = {};\n        return function()\n        {\n            var key = arguments[0];\n            if (cache[key])\n            {\n                return cache[key];\n            }\n            else\n            {\n                var val = func.apply(this, arguments);\n                cache[key] = val;\n                return val;\n            }\n        };\n    }\n    var fibonacci = memoizeFunction(function(n)\n    {\n        return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);\n    });\n    console.log(fibonacci(100)); // 输出354224848179262000000\n    console.log(fibonacci(100)); // 输出354224848179262000000\n    代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。\n\n# 10. 函数重载\n\n所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。\n\n从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。\n\n难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。\n\n由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。\n\n根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。\n\n    function addMethod(object, name, f)\n    {　　\n        var old = object[name];　　\n        object[name] = function()\n        {\n            // f.length为函数定义时的参数个数\n            // arguments.length为函数调用时的参数个数　　　　\n            if (f.length === arguments.length)\n            {　　\n                return f.apply(this, arguments);　　　　\n            }\n            else if (typeof old === \"function\")\n            {\n                return old.apply(this, arguments);　　　　\n            }　　\n        };\n    }\n    // 不传参数时，返回所有name\n    function find0()\n    {　　\n        return this.names;\n    }\n    // 传一个参数时，返回firstName匹配的name\n    function find1(firstName)\n    {　　\n        var result = [];　　\n        for (var i = 0; i < this.names.length; i++)\n        {　　　　\n            if (this.names[i].indexOf(firstName) === 0)\n            {　　　　　　\n                result.push(this.names[i]);　　　　\n            }　　\n        }　　\n        return result;\n    }\n    // 传两个参数时，返回firstName和lastName都匹配的name\n    function find2(firstName, lastName)\n    {　\n        var result = [];　　\n        for (var i = 0; i < this.names.length; i++)\n        {　　　　\n            if (this.names[i] === (firstName + \" \" + lastName))\n            {　　　　　　\n                result.push(this.names[i]);　　　　\n            }　　\n        }　　\n        return result;\n    }\n    var people = {　　\n        names: [\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]\n    };\n    addMethod(people, \"find\", find0);\n    addMethod(people, \"find\", find1);\n    addMethod(people, \"find\", find2);\n    console.log(people.find()); // 输出[\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]\n    console.log(people.find(\"Dean\")); // 输出[\"Dean Edwards\", \"Dean Tom\"]\n    console.log(people.find(\"Dean\", \"Edwards\")); // 输出[\"Dean Edwards\"]\n","source":"_posts/js.md","raw":"---\ntitle: 10个JavaScript难点\ndate: 2017-03-02 19:56:30\ntags:\n---\n# 10个JavaScript难点概括\n\n# 1. 立即执行函数\n\n立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：\n\n    (function() {\n         // 代码\n         // ...\n    })();\nfunction(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。\n\n# 2. 闭包\n\n对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。\n\n    function f1()\n    {\n        var N = 0; // N是f1函数的局部变量\n    \n    function f2() // f2是f1函数的内部函数，是闭包\n    {\n        N += 1; // 内部函数f2中使用了外部函数f1中的变量N\n        console.log(N);\n    }\n    return f2;\n    }\n    var result = f1();\n    result(); // 输出1\n    result(); // 输出2\n    result(); // 输出3\n代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！\n\n# 3. 使用闭包定义私有变量\n\n通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：\n\n    function Product() {\n        var name;\n        this.setName = function(value) {\n            name = value;\n        };\n        this.getName = function() {\n            return name;\n        };\n    }\n    var p = new Product();\n    p.setName(\"Fundebug\");\n    console.log(p.name); // 输出undefined\n    console.log(p.getName()); // 输出Fundebug\n    代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。\n\n# 4. prototype\n\n每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。\n\n    function Rectangle(x, y)\n    {\n        this._length = x;\n        this._breadth = y;\n    }\n    Rectangle.prototype.getDimensions = function()\n    {\n        return {\n            length: this._length,\n            breadth: this._breadth\n        };\n    };\n    var x = new Rectangle(3, 4);\n    var y = new Rectangle(4, 3);\n    console.log(x.getDimensions()); // { length: 3, breadth: 4 }\n    console.log(y.getDimensions()); // { length: 4, breadth: 3 }\n代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。\n\n# 5. 模块化\n\nJavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery\n\n    var module = (function() {\n        var N = 5;\n        function print(x) {\n            console.log(\"The result is: \" + x);\n        }\n        function add(a) {\n            var x = a + N;\n            print(x);\n        }\n        return {\n            description: \"This is description\",\n            add: add\n        };\n    })();\n    console.log(module.description); // 输出\"this is description\" \n    module.add(5); // 输出“The result is: 10”\n所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。\n\n# 6. 变量提升\n\nJavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。\n\n但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：\n\n    console.log(y);  // 输出undefined\n    y = 2; // 初始化y\n    上面的代码等价于下面的代码：\n    \n    var y;  // 声明y\n    console.log(y);  // 输出undefined\n    y = 2; // 初始化y\n    为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。\n\n# 7. 柯里化\n\n柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。\n\n    var add = function(x) {\n        return function(y) {\n            return x + y;\n        };\n    };\n    console.log(add(1)(1)); // 输出2\n    var add1 = add(1);\n    console.log(add1(1)); // 输出2\n    var add10 = add(10);\n    console.log(add10(1)); // 输出11\n    代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。\n\n# 8. apply, call与bind方法\n\nJavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。\n\n三者之中，call方法是最简单的，它等价于指定this值调用函数：\n\n    var user = {\n        name: \"Rahul Mhatre\",\n        whatIsYourName: function() {\n            console.log(this.name);\n        }\n    };\n    user.whatIsYourName(); // 输出\"Rahul Mhatre\",\n    var user2 = {\n        name: \"Neha Sampat\"\n    };\n    user.whatIsYourName.call(user2); // 输出\"Neha Sampat\"\napply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定：\n\n    apply(thisArg, [argsArray])\n    call(thisArg, arg1, arg2, …)\n    var user = {\n        greet: \"Hello!\",\n        greetUser: function(userName) {\n            console.log(this.greet + \" \" + userName);\n        }\n    };\n    var greet1 = {\n        greet: \"Hola\"\n    };\n    user.greetUser.call(greet1, \"Rahul\"); // 输出\"Hola Rahul\"\n    user.greetUser.apply(greet1, [\"Rahul\"]); // 输出\"Hola Rahul\"\n使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：\n\n    var user = {\n         greet: \"Hello!\",\n         greetUser: function(userName) {\n         console.log(this.greet + \" \" + userName);\n         }\n    };\n    var greetHola = user.greetUser.bind({greet: \"Hola\"});\n    var greetBonjour = user.greetUser.bind({greet: \"Bonjour\"});\n    greetHola(\"Rahul\") // 输出\"Hola Rahul\"\n    greetBonjour(\"Rahul\") // 输出\"Bonjour Rahul\"\n# 9. Memoization\n\nMemoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。\n\n    function memoizeFunction(func)\n    {\n        var cache = {};\n        return function()\n        {\n            var key = arguments[0];\n            if (cache[key])\n            {\n                return cache[key];\n            }\n            else\n            {\n                var val = func.apply(this, arguments);\n                cache[key] = val;\n                return val;\n            }\n        };\n    }\n    var fibonacci = memoizeFunction(function(n)\n    {\n        return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);\n    });\n    console.log(fibonacci(100)); // 输出354224848179262000000\n    console.log(fibonacci(100)); // 输出354224848179262000000\n    代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。\n\n# 10. 函数重载\n\n所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。\n\n从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。\n\n难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。\n\n由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。\n\n根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。\n\n    function addMethod(object, name, f)\n    {　　\n        var old = object[name];　　\n        object[name] = function()\n        {\n            // f.length为函数定义时的参数个数\n            // arguments.length为函数调用时的参数个数　　　　\n            if (f.length === arguments.length)\n            {　　\n                return f.apply(this, arguments);　　　　\n            }\n            else if (typeof old === \"function\")\n            {\n                return old.apply(this, arguments);　　　　\n            }　　\n        };\n    }\n    // 不传参数时，返回所有name\n    function find0()\n    {　　\n        return this.names;\n    }\n    // 传一个参数时，返回firstName匹配的name\n    function find1(firstName)\n    {　　\n        var result = [];　　\n        for (var i = 0; i < this.names.length; i++)\n        {　　　　\n            if (this.names[i].indexOf(firstName) === 0)\n            {　　　　　　\n                result.push(this.names[i]);　　　　\n            }　　\n        }　　\n        return result;\n    }\n    // 传两个参数时，返回firstName和lastName都匹配的name\n    function find2(firstName, lastName)\n    {　\n        var result = [];　　\n        for (var i = 0; i < this.names.length; i++)\n        {　　　　\n            if (this.names[i] === (firstName + \" \" + lastName))\n            {　　　　　　\n                result.push(this.names[i]);　　　　\n            }　　\n        }　　\n        return result;\n    }\n    var people = {　　\n        names: [\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]\n    };\n    addMethod(people, \"find\", find0);\n    addMethod(people, \"find\", find1);\n    addMethod(people, \"find\", find2);\n    console.log(people.find()); // 输出[\"Dean Edwards\", \"Alex Russell\", \"Dean Tom\"]\n    console.log(people.find(\"Dean\")); // 输出[\"Dean Edwards\", \"Dean Tom\"]\n    console.log(people.find(\"Dean\", \"Edwards\")); // 输出[\"Dean Edwards\"]\n","slug":"js","published":1,"updated":"2017-08-02T12:42:38.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5v07ehk0004cwuvm6lzqjia","content":"<h1 id=\"10个JavaScript难点概括\"><a href=\"#10个JavaScript难点概括\" class=\"headerlink\" title=\"10个JavaScript难点概括\"></a>10个JavaScript难点概括</h1><h1 id=\"1-立即执行函数\"><a href=\"#1-立即执行函数\" class=\"headerlink\" title=\"1. 立即执行函数\"></a>1. 立即执行函数</h1><p>立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：</p>\n<pre><code>(function() {\n     // 代码\n     // ...\n})();\n</code></pre><p>function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。</p>\n<h1 id=\"2-闭包\"><a href=\"#2-闭包\" class=\"headerlink\" title=\"2. 闭包\"></a>2. 闭包</h1><p>对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。</p>\n<pre><code>function f1()\n{\n    var N = 0; // N是f1函数的局部变量\n\nfunction f2() // f2是f1函数的内部函数，是闭包\n{\n    N += 1; // 内部函数f2中使用了外部函数f1中的变量N\n    console.log(N);\n}\nreturn f2;\n}\nvar result = f1();\nresult(); // 输出1\nresult(); // 输出2\nresult(); // 输出3\n</code></pre><p>代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！</p>\n<h1 id=\"3-使用闭包定义私有变量\"><a href=\"#3-使用闭包定义私有变量\" class=\"headerlink\" title=\"3. 使用闭包定义私有变量\"></a>3. 使用闭包定义私有变量</h1><p>通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：</p>\n<pre><code>function Product() {\n    var name;\n    this.setName = function(value) {\n        name = value;\n    };\n    this.getName = function() {\n        return name;\n    };\n}\nvar p = new Product();\np.setName(&quot;Fundebug&quot;);\nconsole.log(p.name); // 输出undefined\nconsole.log(p.getName()); // 输出Fundebug\n代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。\n</code></pre><h1 id=\"4-prototype\"><a href=\"#4-prototype\" class=\"headerlink\" title=\"4. prototype\"></a>4. prototype</h1><p>每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。</p>\n<pre><code>function Rectangle(x, y)\n{\n    this._length = x;\n    this._breadth = y;\n}\nRectangle.prototype.getDimensions = function()\n{\n    return {\n        length: this._length,\n        breadth: this._breadth\n    };\n};\nvar x = new Rectangle(3, 4);\nvar y = new Rectangle(4, 3);\nconsole.log(x.getDimensions()); // { length: 3, breadth: 4 }\nconsole.log(y.getDimensions()); // { length: 4, breadth: 3 }\n</code></pre><p>代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。</p>\n<h1 id=\"5-模块化\"><a href=\"#5-模块化\" class=\"headerlink\" title=\"5. 模块化\"></a>5. 模块化</h1><p>JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery</p>\n<pre><code>var module = (function() {\n    var N = 5;\n    function print(x) {\n        console.log(&quot;The result is: &quot; + x);\n    }\n    function add(a) {\n        var x = a + N;\n        print(x);\n    }\n    return {\n        description: &quot;This is description&quot;,\n        add: add\n    };\n})();\nconsole.log(module.description); // 输出&quot;this is description&quot; \nmodule.add(5); // 输出“The result is: 10”\n</code></pre><p>所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。</p>\n<h1 id=\"6-变量提升\"><a href=\"#6-变量提升\" class=\"headerlink\" title=\"6. 变量提升\"></a>6. 变量提升</h1><p>JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。</p>\n<p>但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：</p>\n<pre><code>console.log(y);  // 输出undefined\ny = 2; // 初始化y\n上面的代码等价于下面的代码：\n\nvar y;  // 声明y\nconsole.log(y);  // 输出undefined\ny = 2; // 初始化y\n为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。\n</code></pre><h1 id=\"7-柯里化\"><a href=\"#7-柯里化\" class=\"headerlink\" title=\"7. 柯里化\"></a>7. 柯里化</h1><p>柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n<pre><code>var add = function(x) {\n    return function(y) {\n        return x + y;\n    };\n};\nconsole.log(add(1)(1)); // 输出2\nvar add1 = add(1);\nconsole.log(add1(1)); // 输出2\nvar add10 = add(10);\nconsole.log(add10(1)); // 输出11\n代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。\n</code></pre><h1 id=\"8-apply-call与bind方法\"><a href=\"#8-apply-call与bind方法\" class=\"headerlink\" title=\"8. apply, call与bind方法\"></a>8. apply, call与bind方法</h1><p>JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。</p>\n<p>三者之中，call方法是最简单的，它等价于指定this值调用函数：</p>\n<pre><code>var user = {\n    name: &quot;Rahul Mhatre&quot;,\n    whatIsYourName: function() {\n        console.log(this.name);\n    }\n};\nuser.whatIsYourName(); // 输出&quot;Rahul Mhatre&quot;,\nvar user2 = {\n    name: &quot;Neha Sampat&quot;\n};\nuser.whatIsYourName.call(user2); // 输出&quot;Neha Sampat&quot;\n</code></pre><p>apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定：</p>\n<pre><code>apply(thisArg, [argsArray])\ncall(thisArg, arg1, arg2, …)\nvar user = {\n    greet: &quot;Hello!&quot;,\n    greetUser: function(userName) {\n        console.log(this.greet + &quot; &quot; + userName);\n    }\n};\nvar greet1 = {\n    greet: &quot;Hola&quot;\n};\nuser.greetUser.call(greet1, &quot;Rahul&quot;); // 输出&quot;Hola Rahul&quot;\nuser.greetUser.apply(greet1, [&quot;Rahul&quot;]); // 输出&quot;Hola Rahul&quot;\n</code></pre><p>使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：</p>\n<pre><code>var user = {\n     greet: &quot;Hello!&quot;,\n     greetUser: function(userName) {\n     console.log(this.greet + &quot; &quot; + userName);\n     }\n};\nvar greetHola = user.greetUser.bind({greet: &quot;Hola&quot;});\nvar greetBonjour = user.greetUser.bind({greet: &quot;Bonjour&quot;});\ngreetHola(&quot;Rahul&quot;) // 输出&quot;Hola Rahul&quot;\ngreetBonjour(&quot;Rahul&quot;) // 输出&quot;Bonjour Rahul&quot;\n</code></pre><h1 id=\"9-Memoization\"><a href=\"#9-Memoization\" class=\"headerlink\" title=\"9. Memoization\"></a>9. Memoization</h1><p>Memoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。</p>\n<pre><code>function memoizeFunction(func)\n{\n    var cache = {};\n    return function()\n    {\n        var key = arguments[0];\n        if (cache[key])\n        {\n            return cache[key];\n        }\n        else\n        {\n            var val = func.apply(this, arguments);\n            cache[key] = val;\n            return val;\n        }\n    };\n}\nvar fibonacci = memoizeFunction(function(n)\n{\n    return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);\n});\nconsole.log(fibonacci(100)); // 输出354224848179262000000\nconsole.log(fibonacci(100)); // 输出354224848179262000000\n代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。\n</code></pre><h1 id=\"10-函数重载\"><a href=\"#10-函数重载\" class=\"headerlink\" title=\"10. 函数重载\"></a>10. 函数重载</h1><p>所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。</p>\n<p>从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。</p>\n<p>难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。</p>\n<p>由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。</p>\n<p>根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。</p>\n<pre><code>function addMethod(object, name, f)\n{　　\n    var old = object[name];　　\n    object[name] = function()\n    {\n        // f.length为函数定义时的参数个数\n        // arguments.length为函数调用时的参数个数　　　　\n        if (f.length === arguments.length)\n        {　　\n            return f.apply(this, arguments);　　　　\n        }\n        else if (typeof old === &quot;function&quot;)\n        {\n            return old.apply(this, arguments);　　　　\n        }　　\n    };\n}\n// 不传参数时，返回所有name\nfunction find0()\n{　　\n    return this.names;\n}\n// 传一个参数时，返回firstName匹配的name\nfunction find1(firstName)\n{　　\n    var result = [];　　\n    for (var i = 0; i &lt; this.names.length; i++)\n    {　　　　\n        if (this.names[i].indexOf(firstName) === 0)\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}\n// 传两个参数时，返回firstName和lastName都匹配的name\nfunction find2(firstName, lastName)\n{　\n    var result = [];　　\n    for (var i = 0; i &lt; this.names.length; i++)\n    {　　　　\n        if (this.names[i] === (firstName + &quot; &quot; + lastName))\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}\nvar people = {　　\n    names: [&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]\n};\naddMethod(people, &quot;find&quot;, find0);\naddMethod(people, &quot;find&quot;, find1);\naddMethod(people, &quot;find&quot;, find2);\nconsole.log(people.find()); // 输出[&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]\nconsole.log(people.find(&quot;Dean&quot;)); // 输出[&quot;Dean Edwards&quot;, &quot;Dean Tom&quot;]\nconsole.log(people.find(&quot;Dean&quot;, &quot;Edwards&quot;)); // 输出[&quot;Dean Edwards&quot;]\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"10个JavaScript难点概括\"><a href=\"#10个JavaScript难点概括\" class=\"headerlink\" title=\"10个JavaScript难点概括\"></a>10个JavaScript难点概括</h1><h1 id=\"1-立即执行函数\"><a href=\"#1-立即执行函数\" class=\"headerlink\" title=\"1. 立即执行函数\"></a>1. 立即执行函数</h1><p>立即执行函数，即Immediately Invoked Function Expression (IIFE)，正如它的名字，就是创建函数的同时立即执行。它没有绑定任何事件，也无需等待任何异步操作：</p>\n<pre><code>(function() {\n     // 代码\n     // ...\n})();\n</code></pre><p>function(){…}是一个匿名函数，包围它的一对括号将其转换为一个表达式，紧跟其后的一对括号调用了这个函数。立即执行函数也可以理解为立即调用一个匿名函数。立即执行函数最常见的应用场景就是：将var变量的作用域限制于你们函数内，这样可以避免命名冲突。</p>\n<h1 id=\"2-闭包\"><a href=\"#2-闭包\" class=\"headerlink\" title=\"2. 闭包\"></a>2. 闭包</h1><p>对于闭包(closure)，当外部函数返回之后，内部函数依然可以访问外部函数的变量。</p>\n<pre><code>function f1()\n{\n    var N = 0; // N是f1函数的局部变量\n\nfunction f2() // f2是f1函数的内部函数，是闭包\n{\n    N += 1; // 内部函数f2中使用了外部函数f1中的变量N\n    console.log(N);\n}\nreturn f2;\n}\nvar result = f1();\nresult(); // 输出1\nresult(); // 输出2\nresult(); // 输出3\n</code></pre><p>代码中，外部函数f1只执行了一次，变量N设为0，并将内部函数f2赋值给了变量result。由于外部函数f1已经执行完毕，其内部变量N应该在内存中被清除，然而事实并不是这样：我们每次调用result的时候，发现变量N一直在内存中，并且在累加。为什么呢？这就是闭包的神奇之处了！</p>\n<h1 id=\"3-使用闭包定义私有变量\"><a href=\"#3-使用闭包定义私有变量\" class=\"headerlink\" title=\"3. 使用闭包定义私有变量\"></a>3. 使用闭包定义私有变量</h1><p>通常，JavaScript开发者使用下划线作为私有变量的前缀。但是实际上，这些变量依然可以被访问和修改，并非真正的私有变量。这时，使用闭包可以定义真正的私有变量：</p>\n<pre><code>function Product() {\n    var name;\n    this.setName = function(value) {\n        name = value;\n    };\n    this.getName = function() {\n        return name;\n    };\n}\nvar p = new Product();\np.setName(&quot;Fundebug&quot;);\nconsole.log(p.name); // 输出undefined\nconsole.log(p.getName()); // 输出Fundebug\n代码中，对象p的的name属性为私有属性，使用p.name不能直接访问。\n</code></pre><h1 id=\"4-prototype\"><a href=\"#4-prototype\" class=\"headerlink\" title=\"4. prototype\"></a>4. prototype</h1><p>每个JavaScript构造函数都有一个prototype属性，用于设置所有实例对象需要共享的属性和方法。prototype属性不能列举。JavaScript仅支持通过prototype属性进行继承属性和方法。</p>\n<pre><code>function Rectangle(x, y)\n{\n    this._length = x;\n    this._breadth = y;\n}\nRectangle.prototype.getDimensions = function()\n{\n    return {\n        length: this._length,\n        breadth: this._breadth\n    };\n};\nvar x = new Rectangle(3, 4);\nvar y = new Rectangle(4, 3);\nconsole.log(x.getDimensions()); // { length: 3, breadth: 4 }\nconsole.log(y.getDimensions()); // { length: 4, breadth: 3 }\n</code></pre><p>代码中，x和y都是构造函数Rectangle创建的对象实例，它们通过prototype继承了getDimensions方法。</p>\n<h1 id=\"5-模块化\"><a href=\"#5-模块化\" class=\"headerlink\" title=\"5. 模块化\"></a>5. 模块化</h1><p>JavaScript并非模块化编程语言，至少ES6落地之前都不是。然而对于一个复杂的Web应用，模块化编程是一个最基本的要求。这时，可以使用立即执行函数来实现模块化，正如很多JS库比如jQuery</p>\n<pre><code>var module = (function() {\n    var N = 5;\n    function print(x) {\n        console.log(&quot;The result is: &quot; + x);\n    }\n    function add(a) {\n        var x = a + N;\n        print(x);\n    }\n    return {\n        description: &quot;This is description&quot;,\n        add: add\n    };\n})();\nconsole.log(module.description); // 输出&quot;this is description&quot; \nmodule.add(5); // 输出“The result is: 10”\n</code></pre><p>所谓模块化，就是根据需要控制模块内属性与方法的可访问性，即私有或者公开。在代码中，module为一个独立的模块，N为其私有属性，print为其私有方法，decription为其公有属性，add为其共有方法。</p>\n<h1 id=\"6-变量提升\"><a href=\"#6-变量提升\" class=\"headerlink\" title=\"6. 变量提升\"></a>6. 变量提升</h1><p>JavaScript会将所有变量和函数声明移动到它的作用域的最前面，这就是所谓的变量提升(Hoisting)。也就是说，无论你在什么地方声明变量和函数，解释器都会将它们移动到作用域的最前面。因此我们可以先使用变量和函数，而后声明它们。</p>\n<p>但是，仅仅是变量声明被提升了，而变量赋值不会被提升。如果你不明白这一点，有时则会出错：</p>\n<pre><code>console.log(y);  // 输出undefined\ny = 2; // 初始化y\n上面的代码等价于下面的代码：\n\nvar y;  // 声明y\nconsole.log(y);  // 输出undefined\ny = 2; // 初始化y\n为了避免BUG，开发者应该在每个作用域开始时声明变量和函数。\n</code></pre><h1 id=\"7-柯里化\"><a href=\"#7-柯里化\" class=\"headerlink\" title=\"7. 柯里化\"></a>7. 柯里化</h1><p>柯里化，即Currying，可以使函数变得更加灵活。我们可以一次性传入多个参数调用它；也可以只传入一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>\n<pre><code>var add = function(x) {\n    return function(y) {\n        return x + y;\n    };\n};\nconsole.log(add(1)(1)); // 输出2\nvar add1 = add(1);\nconsole.log(add1(1)); // 输出2\nvar add10 = add(10);\nconsole.log(add10(1)); // 输出11\n代码中，我们可以一次性传入2个1作为参数add(1)(1)，也可以传入1个参数之后获取add1与add10函数，这样使用起来非常灵活。\n</code></pre><h1 id=\"8-apply-call与bind方法\"><a href=\"#8-apply-call与bind方法\" class=\"headerlink\" title=\"8. apply, call与bind方法\"></a>8. apply, call与bind方法</h1><p>JavaScript开发者有必要理解apply、call与bind方法的不同点。它们的共同点是第一个参数都是this，即函数运行时依赖的上下文。</p>\n<p>三者之中，call方法是最简单的，它等价于指定this值调用函数：</p>\n<pre><code>var user = {\n    name: &quot;Rahul Mhatre&quot;,\n    whatIsYourName: function() {\n        console.log(this.name);\n    }\n};\nuser.whatIsYourName(); // 输出&quot;Rahul Mhatre&quot;,\nvar user2 = {\n    name: &quot;Neha Sampat&quot;\n};\nuser.whatIsYourName.call(user2); // 输出&quot;Neha Sampat&quot;\n</code></pre><p>apply方法与call方法类似。两者唯一的不同点在于，apply方法使用数组指定参数，而call方法每个参数单独需要指定：</p>\n<pre><code>apply(thisArg, [argsArray])\ncall(thisArg, arg1, arg2, …)\nvar user = {\n    greet: &quot;Hello!&quot;,\n    greetUser: function(userName) {\n        console.log(this.greet + &quot; &quot; + userName);\n    }\n};\nvar greet1 = {\n    greet: &quot;Hola&quot;\n};\nuser.greetUser.call(greet1, &quot;Rahul&quot;); // 输出&quot;Hola Rahul&quot;\nuser.greetUser.apply(greet1, [&quot;Rahul&quot;]); // 输出&quot;Hola Rahul&quot;\n</code></pre><p>使用bind方法，可以为函数绑定this值，然后作为一个新的函数返回：</p>\n<pre><code>var user = {\n     greet: &quot;Hello!&quot;,\n     greetUser: function(userName) {\n     console.log(this.greet + &quot; &quot; + userName);\n     }\n};\nvar greetHola = user.greetUser.bind({greet: &quot;Hola&quot;});\nvar greetBonjour = user.greetUser.bind({greet: &quot;Bonjour&quot;});\ngreetHola(&quot;Rahul&quot;) // 输出&quot;Hola Rahul&quot;\ngreetBonjour(&quot;Rahul&quot;) // 输出&quot;Bonjour Rahul&quot;\n</code></pre><h1 id=\"9-Memoization\"><a href=\"#9-Memoization\" class=\"headerlink\" title=\"9. Memoization\"></a>9. Memoization</h1><p>Memoization用于优化比较耗时的计算，通过将计算结果缓存到内存中，这样对于同样的输入值，下次只需要中内存中读取结果。</p>\n<pre><code>function memoizeFunction(func)\n{\n    var cache = {};\n    return function()\n    {\n        var key = arguments[0];\n        if (cache[key])\n        {\n            return cache[key];\n        }\n        else\n        {\n            var val = func.apply(this, arguments);\n            cache[key] = val;\n            return val;\n        }\n    };\n}\nvar fibonacci = memoizeFunction(function(n)\n{\n    return (n === 0 || n === 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);\n});\nconsole.log(fibonacci(100)); // 输出354224848179262000000\nconsole.log(fibonacci(100)); // 输出354224848179262000000\n代码中，第2次计算fibonacci(100)则只需要在内存中直接读取结果。\n</code></pre><h1 id=\"10-函数重载\"><a href=\"#10-函数重载\" class=\"headerlink\" title=\"10. 函数重载\"></a>10. 函数重载</h1><p>所谓函数重载(method overloading)，就是函数名称一样，但是输入输出不一样。或者说，允许某个函数有各种不同输入，根据不同的输入，返回不同的结果。凭直觉，函数重载可以通过if…else或者switch实现，这就不去管它了。jQuery之父John Resig提出了一个非常巧(bian)妙(tai)的方法，利用了闭包。</p>\n<p>从效果上来说，people对象的find方法允许3种不同的输入: 0个参数时，返回所有人名；1个参数时，根据firstName查找人名并返回；2个参数时，根据完整的名称查找人名并返回。</p>\n<p>难点在于，people.find只能绑定一个函数，那它为何可以处理3种不同的输入呢？它不可能同时绑定3个函数find0,find1与find2啊！这里的关键在于old属性。</p>\n<p>由addMethod函数的调用顺序可知，people.find最终绑定的是find2函数。然而，在绑定find2时，old为find1；同理，绑定find1时，old为find0。3个函数find0,find1与find2就这样通过闭包链接起来了。</p>\n<p>根据addMethod的逻辑，当f.length与arguments.length不匹配时，就会去调用old，直到匹配为止。</p>\n<pre><code>function addMethod(object, name, f)\n{　　\n    var old = object[name];　　\n    object[name] = function()\n    {\n        // f.length为函数定义时的参数个数\n        // arguments.length为函数调用时的参数个数　　　　\n        if (f.length === arguments.length)\n        {　　\n            return f.apply(this, arguments);　　　　\n        }\n        else if (typeof old === &quot;function&quot;)\n        {\n            return old.apply(this, arguments);　　　　\n        }　　\n    };\n}\n// 不传参数时，返回所有name\nfunction find0()\n{　　\n    return this.names;\n}\n// 传一个参数时，返回firstName匹配的name\nfunction find1(firstName)\n{　　\n    var result = [];　　\n    for (var i = 0; i &lt; this.names.length; i++)\n    {　　　　\n        if (this.names[i].indexOf(firstName) === 0)\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}\n// 传两个参数时，返回firstName和lastName都匹配的name\nfunction find2(firstName, lastName)\n{　\n    var result = [];　　\n    for (var i = 0; i &lt; this.names.length; i++)\n    {　　　　\n        if (this.names[i] === (firstName + &quot; &quot; + lastName))\n        {　　　　　　\n            result.push(this.names[i]);　　　　\n        }　　\n    }　　\n    return result;\n}\nvar people = {　　\n    names: [&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]\n};\naddMethod(people, &quot;find&quot;, find0);\naddMethod(people, &quot;find&quot;, find1);\naddMethod(people, &quot;find&quot;, find2);\nconsole.log(people.find()); // 输出[&quot;Dean Edwards&quot;, &quot;Alex Russell&quot;, &quot;Dean Tom&quot;]\nconsole.log(people.find(&quot;Dean&quot;)); // 输出[&quot;Dean Edwards&quot;, &quot;Dean Tom&quot;]\nconsole.log(people.find(&quot;Dean&quot;, &quot;Edwards&quot;)); // 输出[&quot;Dean Edwards&quot;]\n</code></pre>"},{"title":"JavaScript的一些知识点","date":"2016-10-01T12:16:17.000Z","_content":"# 1.执行上下文：\n\n单线程\n\n同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待\n\n全局上下文只有唯一的一个，它在浏览器关闭时出栈\n\n函数的执行上下文的个数没有限制\n\n每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此\n\n- 创建阶段\n  在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向\n- 代码执行阶段\n  创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。\n  变量对象的创建，依次经历了以下几个过程。\n  1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n  2. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n  3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改.\n\n# 2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\n\n    demo1:\n    function test() {\n        console.log(a);\n        console.log(foo());\n\n        var a = 1;\n        function foo() {\n            return 2;\n        }\n    }\n\n    test();\n\nfunction声明会比var声明优先级更高一点，所以在执行过程中顺序就变成了：\n\n    function test() {\n        function foo() {\n            return 2;\n        }\n        var a;\n        console.log(a);\n        console.log(foo());\n        a = 1;\n    }\n\n    test();\n\n    demo2:\n    function test() {\n        console.log(foo);\n        console.log(bar);\n\n        var foo = 'Hello';\n        console.log(foo);\n        var bar = function () {\n            return 'world';\n        }\n\n        function foo() {\n            return 'hello';\n        }\n    }\n\n    test();//console.log(foo)会打印函数体，console.log(foo())才打印函数执行结果。\n\n\n# 3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\n\n# 4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。\n---\n\n\n\n# 3.闭包：\n\n闭包与作用域链息息相关；\n\n闭包是在函数执行过程中被确认。\n\n闭包的应用场景\n\n接下来，我们来总结下，闭包的常用场景。\n\n延迟函数setTimeout\n\n我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，\n\n      function fn() {\n      console.log('this is test.')\n      }\n      var timer =  setTimeout(fn, 1000);\n      console.log(timer);\n\n\n\n按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。\n\n---\n\n\n\n# 4.this的指向\n\nthis的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。\n\n    var a = 10;\n    var obj = {\n        a: 20\n    }\n\n    function fn () {\n        console.log(this.a);\n    }\n\n    fn(); // 10\n    fn.call(obj); // 20\n\n    var a = 20;\n    var foo = {\n        a: 10,\n        getA: function () {\n            return this.a;\n        }\n    }\n    console.log(foo.getA()); // 10\n\n    var test = foo.getA;\n    console.log(test());  // 20\n\nfoo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。\n\n\n      // demo03\n     var a = 20; \n     var obj = {\n     a: 10,\n     c: this.a + 20,\n\n    fn: function () {\n\n        return this.a;\n\n    }\n    } \n    console.log(obj.c);\n\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。\n\n当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。\n\n# 5.使用call，apply显示指定this\n\nJavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。\n\n如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。\n\n    function fn() {\n        console.log(this.a);\n    }\n    var obj = {\n        a: 20\n    }\n\n    fn.call(obj);\n\n而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。\n\n    function fn(num1, num2) {\n        console.log(this.a + num1 + num2);\n    }\n    var obj = {\n        a: 20\n    }\n\n    fn.call(obj, 100, 10); // 130\n    fn.apply(obj, [20, 10]); // 50\n\n# 6.http协议：\n超文本传输协议(HTTP，HyperText Transfer Protocol)\n\n是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n\n通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如\"HTTP/1.1 200 OK\"，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。\n\nHTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。\n\n通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。\n\n\n请求行和标题必须以<CR><LF> 作为结尾（也就是，回车然后换行）。空行内必须只有<CR><LF>而无其他空格。在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的。\n\n我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。\n\n　　HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以http://开头的原因。\n\n\n\n# 7.ajax:\n\n1.同步：客户端浏览器先发起请求，等待响应，服务器返回响应，客户端才会渲染内容，也就是说客户端每一次发起请求的时候都会把之前的内容删掉，等待服务器给下一次响应\n\n2.异步：客户端有部分可见，发起请求，服务器返回响应，客户端把更新后的内容追加到dom树上，此时客户端和服务器是同时运行的，浏览器在浏览网页的同时服务器会返回新的内容\n\n\t\n原生ajax:\n\t\n\n\tvar xhr = new XMLHttpRequest();\n\txhr.onreadystatechange = function(){\n\tif(xhr.readyState==4&&xhr.status==200){  //响应完成且成功\n\txhr.open（“请求方法”，url，true)\n\txhr.send（null/请求主体）//请求主体（键值对，文件上传，json格式）,get没有请求主体，post要设置头部信息\n\t）\n\t}\n\n\n\n\n\n\n\n\njquery的ajax:\n    $.ajax({\n\n  type:'请求方法'，\n\n  url:'请求地址'，\n\n  data:'请求数据'（可以是对象，或者是键值对的形式），\n\n  success:fn  (成功的回调函数)，\n\n  error:fn,\n\n  beforeSend:fn,  (请求发送之前的回调)，\n\n  complete:fn   (不管成功还是失败都要执行的回调)\n\n})\n\n# 8.跨域问题：\n\n指从一个url上的资源访问另一个url上的资源，这两个资源不在同一个域上，如协议名，域名，端口号不同，这就叫跨域\n\n浏览器哪些情况下允许跨域：\n\n带src和href属性的标签，如srcript,img,link,iframe\n\n所有浏览器都默认禁止xhr对象的跨域请求----处于“同源安全策略”，不允许放在当前的dom树上。\n\n面试题：\n\n我们公司项目项目很大，为了功能上的清晰划分，在static.tedu.cn上放置了所有的静态资源，在data.tedu.cn上放置了所有的动态数据（json格式），请问如何在static.tedu.cn上获取data.tedu.cn/newlist.json上的动态数据？如何绕过浏览器的xhr跨域限制？\n\n答案：1.CORS方案： （跨源的资源共享）cross origin  Resource  Share（适用于自己可以控制动态页面的编写）\n\n在被访问的资源响应中添加如下的头部：\n\n设置一个响应头部（访问控制允许来源）header('Access-Control-Allow-Origin:http://127.0.0.1');\n\n允许从指定的域名发起跨域请求。\n\n2.jsonp方案：JSON with padding,填充式json，是一种使用json数据的手段、方式。\n\n思路：使用动态创建的script标签代替xhr发起异步的请求，获取跨域的数据，在本地的Js中加以处理.\n\n<script async=\"true\" src=\"跨域地址/x.php\"> </script>  //async=true代表异步为真，异步请求\n\n---\n\n    <script>\n    function doResponse(data){\n    处理服务器端返回的data中的数据...\n    }\n\n    </script>\n\n服务器端返回的数据形如：\n\nContent-Type:application/javascript\n\ndoResponse({x:y, a:b});\n\n# 9.jQuery中如何发起jsonp请求？\n\n1.XHR非跨域请求  $.getJSON('xx.php')\n\n2.跨域请求: $.getJSON('跨域地址/x.php?callback=?',function(data){..处理服务器返回的数据})\n\n\n\n\t3.$.ajax({\n\turl:'',\n\n\tdatatype:'jsonp',\n\n\tsuccess:function(data){\n\n         error:function(){}\n         }\n        }) \n\n\n\n\n\n\n\n# 10.html5新特性：\n\n1.新的语义标签，2.增强型表单，3.视频和音频，4.Canvas绘图，svg绘图，5.地理定位，6拖放api,7.webWorker  8.webStorage,webSocket\n\n# 11.函数自执行与块级作用域\n\n在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。\n\n    (function() {\n       // ...\n    })();\n\n一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。\n\n    (function() {\n        // 私有变量\n        var age = 20;\n        var name = 'Tom';\n\n\n        // 私有方法\n        function getName() {\n            return `your name is ` + name;\n        }\n\n\n        // 共有方法\n        function getAge() {\n            return age;\n        }\n\n        // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收\n        window.getAge = getAge;\n    })();\n\n\n\n\n# 12.拖拽的原理\n\n当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系：\n\n    移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置\n\n如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：\n\n    移动后目标元素的位置 = dis + 目标元素的初始位置\n\n通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。\n\n","source":"_posts/post.md","raw":"---\ntitle: JavaScript的一些知识点\ndate: 2016-10-01 20:16:17\ntags:\n---\n# 1.执行上下文：\n\n单线程\n\n同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待\n\n全局上下文只有唯一的一个，它在浏览器关闭时出栈\n\n函数的执行上下文的个数没有限制\n\n每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此\n\n- 创建阶段\n  在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向\n- 代码执行阶段\n  创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。\n  变量对象的创建，依次经历了以下几个过程。\n  1. 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。\n  2. 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。\n  3. 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改.\n\n# 2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\n\n    demo1:\n    function test() {\n        console.log(a);\n        console.log(foo());\n\n        var a = 1;\n        function foo() {\n            return 2;\n        }\n    }\n\n    test();\n\nfunction声明会比var声明优先级更高一点，所以在执行过程中顺序就变成了：\n\n    function test() {\n        function foo() {\n            return 2;\n        }\n        var a;\n        console.log(a);\n        console.log(foo());\n        a = 1;\n    }\n\n    test();\n\n    demo2:\n    function test() {\n        console.log(foo);\n        console.log(bar);\n\n        var foo = 'Hello';\n        console.log(foo);\n        var bar = function () {\n            return 'world';\n        }\n\n        function foo() {\n            return 'hello';\n        }\n    }\n\n    test();//console.log(foo)会打印函数体，console.log(foo())才打印函数执行结果。\n\n\n# 3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\n\n# 4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。\n---\n\n\n\n# 3.闭包：\n\n闭包与作用域链息息相关；\n\n闭包是在函数执行过程中被确认。\n\n闭包的应用场景\n\n接下来，我们来总结下，闭包的常用场景。\n\n延迟函数setTimeout\n\n我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，\n\n      function fn() {\n      console.log('this is test.')\n      }\n      var timer =  setTimeout(fn, 1000);\n      console.log(timer);\n\n\n\n按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。\n\n---\n\n\n\n# 4.this的指向\n\nthis的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。\n\n    var a = 10;\n    var obj = {\n        a: 20\n    }\n\n    function fn () {\n        console.log(this.a);\n    }\n\n    fn(); // 10\n    fn.call(obj); // 20\n\n    var a = 20;\n    var foo = {\n        a: 10,\n        getA: function () {\n            return this.a;\n        }\n    }\n    console.log(foo.getA()); // 10\n\n    var test = foo.getA;\n    console.log(test());  // 20\n\nfoo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。\n\n\n      // demo03\n     var a = 20; \n     var obj = {\n     a: 10,\n     c: this.a + 20,\n\n    fn: function () {\n\n        return this.a;\n\n    }\n    } \n    console.log(obj.c);\n\n在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。\n\n当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。\n\n# 5.使用call，apply显示指定this\n\nJavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。\n\n如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。\n\n    function fn() {\n        console.log(this.a);\n    }\n    var obj = {\n        a: 20\n    }\n\n    fn.call(obj);\n\n而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。\n\n    function fn(num1, num2) {\n        console.log(this.a + num1 + num2);\n    }\n    var obj = {\n        a: 20\n    }\n\n    fn.call(obj, 100, 10); // 130\n    fn.apply(obj, [20, 10]); // 50\n\n# 6.http协议：\n超文本传输协议(HTTP，HyperText Transfer Protocol)\n\n是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n\n通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如\"HTTP/1.1 200 OK\"，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。\n\nHTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。\n\n通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。\n\n\n请求行和标题必须以<CR><LF> 作为结尾（也就是，回车然后换行）。空行内必须只有<CR><LF>而无其他空格。在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的。\n\n我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。\n\n　　HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以http://开头的原因。\n\n\n\n# 7.ajax:\n\n1.同步：客户端浏览器先发起请求，等待响应，服务器返回响应，客户端才会渲染内容，也就是说客户端每一次发起请求的时候都会把之前的内容删掉，等待服务器给下一次响应\n\n2.异步：客户端有部分可见，发起请求，服务器返回响应，客户端把更新后的内容追加到dom树上，此时客户端和服务器是同时运行的，浏览器在浏览网页的同时服务器会返回新的内容\n\n\t\n原生ajax:\n\t\n\n\tvar xhr = new XMLHttpRequest();\n\txhr.onreadystatechange = function(){\n\tif(xhr.readyState==4&&xhr.status==200){  //响应完成且成功\n\txhr.open（“请求方法”，url，true)\n\txhr.send（null/请求主体）//请求主体（键值对，文件上传，json格式）,get没有请求主体，post要设置头部信息\n\t）\n\t}\n\n\n\n\n\n\n\n\njquery的ajax:\n    $.ajax({\n\n  type:'请求方法'，\n\n  url:'请求地址'，\n\n  data:'请求数据'（可以是对象，或者是键值对的形式），\n\n  success:fn  (成功的回调函数)，\n\n  error:fn,\n\n  beforeSend:fn,  (请求发送之前的回调)，\n\n  complete:fn   (不管成功还是失败都要执行的回调)\n\n})\n\n# 8.跨域问题：\n\n指从一个url上的资源访问另一个url上的资源，这两个资源不在同一个域上，如协议名，域名，端口号不同，这就叫跨域\n\n浏览器哪些情况下允许跨域：\n\n带src和href属性的标签，如srcript,img,link,iframe\n\n所有浏览器都默认禁止xhr对象的跨域请求----处于“同源安全策略”，不允许放在当前的dom树上。\n\n面试题：\n\n我们公司项目项目很大，为了功能上的清晰划分，在static.tedu.cn上放置了所有的静态资源，在data.tedu.cn上放置了所有的动态数据（json格式），请问如何在static.tedu.cn上获取data.tedu.cn/newlist.json上的动态数据？如何绕过浏览器的xhr跨域限制？\n\n答案：1.CORS方案： （跨源的资源共享）cross origin  Resource  Share（适用于自己可以控制动态页面的编写）\n\n在被访问的资源响应中添加如下的头部：\n\n设置一个响应头部（访问控制允许来源）header('Access-Control-Allow-Origin:http://127.0.0.1');\n\n允许从指定的域名发起跨域请求。\n\n2.jsonp方案：JSON with padding,填充式json，是一种使用json数据的手段、方式。\n\n思路：使用动态创建的script标签代替xhr发起异步的请求，获取跨域的数据，在本地的Js中加以处理.\n\n<script async=\"true\" src=\"跨域地址/x.php\"> </script>  //async=true代表异步为真，异步请求\n\n---\n\n    <script>\n    function doResponse(data){\n    处理服务器端返回的data中的数据...\n    }\n\n    </script>\n\n服务器端返回的数据形如：\n\nContent-Type:application/javascript\n\ndoResponse({x:y, a:b});\n\n# 9.jQuery中如何发起jsonp请求？\n\n1.XHR非跨域请求  $.getJSON('xx.php')\n\n2.跨域请求: $.getJSON('跨域地址/x.php?callback=?',function(data){..处理服务器返回的数据})\n\n\n\n\t3.$.ajax({\n\turl:'',\n\n\tdatatype:'jsonp',\n\n\tsuccess:function(data){\n\n         error:function(){}\n         }\n        }) \n\n\n\n\n\n\n\n# 10.html5新特性：\n\n1.新的语义标签，2.增强型表单，3.视频和音频，4.Canvas绘图，svg绘图，5.地理定位，6拖放api,7.webWorker  8.webStorage,webSocket\n\n# 11.函数自执行与块级作用域\n\n在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。\n\n    (function() {\n       // ...\n    })();\n\n一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。\n\n    (function() {\n        // 私有变量\n        var age = 20;\n        var name = 'Tom';\n\n\n        // 私有方法\n        function getName() {\n            return `your name is ` + name;\n        }\n\n\n        // 共有方法\n        function getAge() {\n            return age;\n        }\n\n        // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收\n        window.getAge = getAge;\n    })();\n\n\n\n\n# 12.拖拽的原理\n\n当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系：\n\n    移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置\n\n如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：\n\n    移动后目标元素的位置 = dis + 目标元素的初始位置\n\n通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。\n\n","slug":"post","published":1,"updated":"2017-08-02T12:40:39.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5v07eho0005cwuvdwrcwmo0","content":"<h1 id=\"1-执行上下文：\"><a href=\"#1-执行上下文：\" class=\"headerlink\" title=\"1.执行上下文：\"></a>1.执行上下文：</h1><p>单线程</p>\n<p>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</p>\n<p>全局上下文只有唯一的一个，它在浏览器关闭时出栈</p>\n<p>函数的执行上下文的个数没有限制</p>\n<p>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此</p>\n<ul>\n<li>创建阶段<br>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向</li>\n<li>代码执行阶段<br>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。<br>变量对象的创建，依次经历了以下几个过程。<ol>\n<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>\n<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改.</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"2-变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\"><a href=\"#2-变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\" class=\"headerlink\" title=\"2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\"></a>2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期</h1><pre><code>demo1:\nfunction test() {\n    console.log(a);\n    console.log(foo());\n\n    var a = 1;\n    function foo() {\n        return 2;\n    }\n}\n\ntest();\n</code></pre><p>function声明会比var声明优先级更高一点，所以在执行过程中顺序就变成了：</p>\n<pre><code>function test() {\n    function foo() {\n        return 2;\n    }\n    var a;\n    console.log(a);\n    console.log(foo());\n    a = 1;\n}\n\ntest();\n\ndemo2:\nfunction test() {\n    console.log(foo);\n    console.log(bar);\n\n    var foo = &apos;Hello&apos;;\n    console.log(foo);\n    var bar = function () {\n        return &apos;world&apos;;\n    }\n\n    function foo() {\n        return &apos;hello&apos;;\n    }\n}\n\ntest();//console.log(foo)会打印函数体，console.log(foo())才打印函数执行结果。\n</code></pre><h1 id=\"3-JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\"><a href=\"#3-JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\" class=\"headerlink\" title=\"3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\"></a>3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建</h1><h1 id=\"4-作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符-变量名或函数名-，这样就可以访问到上一层作用域中的变量了。\"><a href=\"#4-作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符-变量名或函数名-，这样就可以访问到上一层作用域中的变量了。\" class=\"headerlink\" title=\"4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。\"></a>4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。</h1><hr>\n<h1 id=\"3-闭包：\"><a href=\"#3-闭包：\" class=\"headerlink\" title=\"3.闭包：\"></a>3.闭包：</h1><p>闭包与作用域链息息相关；</p>\n<p>闭包是在函数执行过程中被确认。</p>\n<p>闭包的应用场景</p>\n<p>接下来，我们来总结下，闭包的常用场景。</p>\n<p>延迟函数setTimeout</p>\n<p>我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，</p>\n<pre><code>function fn() {\nconsole.log(&apos;this is test.&apos;)\n}\nvar timer =  setTimeout(fn, 1000);\nconsole.log(timer);\n</code></pre><p>按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。</p>\n<hr>\n<h1 id=\"4-this的指向\"><a href=\"#4-this的指向\" class=\"headerlink\" title=\"4.this的指向\"></a>4.this的指向</h1><p>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。</p>\n<pre><code>var a = 10;\nvar obj = {\n    a: 20\n}\n\nfunction fn () {\n    console.log(this.a);\n}\n\nfn(); // 10\nfn.call(obj); // 20\n\nvar a = 20;\nvar foo = {\n    a: 10,\n    getA: function () {\n        return this.a;\n    }\n}\nconsole.log(foo.getA()); // 10\n\nvar test = foo.getA;\nconsole.log(test());  // 20\n</code></pre><p>foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。</p>\n<pre><code>  // demo03\n var a = 20; \n var obj = {\n a: 10,\n c: this.a + 20,\n\nfn: function () {\n\n    return this.a;\n\n}\n} \nconsole.log(obj.c);\n</code></pre><p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>\n<p>当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。</p>\n<h1 id=\"5-使用call，apply显示指定this\"><a href=\"#5-使用call，apply显示指定this\" class=\"headerlink\" title=\"5.使用call，apply显示指定this\"></a>5.使用call，apply显示指定this</h1><p>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。</p>\n<p>如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。</p>\n<pre><code>function fn() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj);\n</code></pre><p>而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。</p>\n<pre><code>function fn(num1, num2) {\n    console.log(this.a + num1 + num2);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj, 100, 10); // 130\nfn.apply(obj, [20, 10]); // 50\n</code></pre><h1 id=\"6-http协议：\"><a href=\"#6-http协议：\" class=\"headerlink\" title=\"6.http协议：\"></a>6.http协议：</h1><p>超文本传输协议(HTTP，HyperText Transfer Protocol)</p>\n<p>是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>\n<p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。</p>\n<p>HTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。</p>\n<p>通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p>\n<p>请求行和标题必须以<cr><lf> 作为结尾（也就是，回车然后换行）。空行内必须只有<cr><lf>而无其他空格。在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的。</lf></cr></lf></cr></p>\n<p>我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。</p>\n<p>　　HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以<a href=\"http://开头的原因。\" target=\"_blank\" rel=\"external\">http://开头的原因。</a></p>\n<h1 id=\"7-ajax\"><a href=\"#7-ajax\" class=\"headerlink\" title=\"7.ajax:\"></a>7.ajax:</h1><p>1.同步：客户端浏览器先发起请求，等待响应，服务器返回响应，客户端才会渲染内容，也就是说客户端每一次发起请求的时候都会把之前的内容删掉，等待服务器给下一次响应</p>\n<p>2.异步：客户端有部分可见，发起请求，服务器返回响应，客户端把更新后的内容追加到dom树上，此时客户端和服务器是同时运行的，浏览器在浏览网页的同时服务器会返回新的内容</p>\n<p>原生ajax:</p>\n<pre><code>var xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function(){\nif(xhr.readyState==4&amp;&amp;xhr.status==200){  //响应完成且成功\nxhr.open（“请求方法”，url，true)\nxhr.send（null/请求主体）//请求主体（键值对，文件上传，json格式）,get没有请求主体，post要设置头部信息\n）\n}\n</code></pre><p>jquery的ajax:<br>    $.ajax({</p>\n<p>  type:’请求方法’，</p>\n<p>  url:’请求地址’，</p>\n<p>  data:’请求数据’（可以是对象，或者是键值对的形式），</p>\n<p>  success:fn  (成功的回调函数)，</p>\n<p>  error:fn,</p>\n<p>  beforeSend:fn,  (请求发送之前的回调)，</p>\n<p>  complete:fn   (不管成功还是失败都要执行的回调)</p>\n<p>})</p>\n<h1 id=\"8-跨域问题：\"><a href=\"#8-跨域问题：\" class=\"headerlink\" title=\"8.跨域问题：\"></a>8.跨域问题：</h1><p>指从一个url上的资源访问另一个url上的资源，这两个资源不在同一个域上，如协议名，域名，端口号不同，这就叫跨域</p>\n<p>浏览器哪些情况下允许跨域：</p>\n<p>带src和href属性的标签，如srcript,img,link,iframe</p>\n<p>所有浏览器都默认禁止xhr对象的跨域请求—-处于“同源安全策略”，不允许放在当前的dom树上。</p>\n<p>面试题：</p>\n<p>我们公司项目项目很大，为了功能上的清晰划分，在static.tedu.cn上放置了所有的静态资源，在data.tedu.cn上放置了所有的动态数据（json格式），请问如何在static.tedu.cn上获取data.tedu.cn/newlist.json上的动态数据？如何绕过浏览器的xhr跨域限制？</p>\n<p>答案：1.CORS方案： （跨源的资源共享）cross origin  Resource  Share（适用于自己可以控制动态页面的编写）</p>\n<p>在被访问的资源响应中添加如下的头部：</p>\n<p>设置一个响应头部（访问控制允许来源）header(‘Access-Control-Allow-Origin:<a href=\"http://127.0.0.1\" target=\"_blank\" rel=\"external\">http://127.0.0.1</a>‘);</p>\n<p>允许从指定的域名发起跨域请求。</p>\n<p>2.jsonp方案：JSON with padding,填充式json，是一种使用json数据的手段、方式。</p>\n<p>思路：使用动态创建的script标签代替xhr发起异步的请求，获取跨域的数据，在本地的Js中加以处理.</p>\n<script async=\"true\" src=\"跨域地址/x.php\"> </script>  //async=true代表异步为真，异步请求\n\n---\n\n    <script>\n    function doResponse(data){\n    处理服务器端返回的data中的数据...\n    }\n\n    </script>\n\n<p>服务器端返回的数据形如：</p>\n<p>Content-Type:application/javascript</p>\n<p>doResponse({x:y, a:b});</p>\n<h1 id=\"9-jQuery中如何发起jsonp请求？\"><a href=\"#9-jQuery中如何发起jsonp请求？\" class=\"headerlink\" title=\"9.jQuery中如何发起jsonp请求？\"></a>9.jQuery中如何发起jsonp请求？</h1><p>1.XHR非跨域请求  $.getJSON(‘xx.php’)</p>\n<p>2.跨域请求: $.getJSON(‘跨域地址/x.php?callback=?’,function(data){..处理服务器返回的数据})</p>\n<pre><code>3.$.ajax({\nurl:&apos;&apos;,\n\ndatatype:&apos;jsonp&apos;,\n\nsuccess:function(data){\n\n     error:function(){}\n     }\n    }) \n</code></pre><h1 id=\"10-html5新特性：\"><a href=\"#10-html5新特性：\" class=\"headerlink\" title=\"10.html5新特性：\"></a>10.html5新特性：</h1><p>1.新的语义标签，2.增强型表单，3.视频和音频，4.Canvas绘图，svg绘图，5.地理定位，6拖放api,7.webWorker  8.webStorage,webSocket</p>\n<h1 id=\"11-函数自执行与块级作用域\"><a href=\"#11-函数自执行与块级作用域\" class=\"headerlink\" title=\"11.函数自执行与块级作用域\"></a>11.函数自执行与块级作用域</h1><p>在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。</p>\n<pre><code>(function() {\n   // ...\n})();\n</code></pre><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p>\n<pre><code>(function() {\n    // 私有变量\n    var age = 20;\n    var name = &apos;Tom&apos;;\n\n\n    // 私有方法\n    function getName() {\n        return `your name is ` + name;\n    }\n\n\n    // 共有方法\n    function getAge() {\n        return age;\n    }\n\n    // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收\n    window.getAge = getAge;\n})();\n</code></pre><h1 id=\"12-拖拽的原理\"><a href=\"#12-拖拽的原理\" class=\"headerlink\" title=\"12.拖拽的原理\"></a>12.拖拽的原理</h1><p>当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系：</p>\n<pre><code>移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置\n</code></pre><p>如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：</p>\n<pre><code>移动后目标元素的位置 = dis + 目标元素的初始位置\n</code></pre><p>通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-执行上下文：\"><a href=\"#1-执行上下文：\" class=\"headerlink\" title=\"1.执行上下文：\"></a>1.执行上下文：</h1><p>单线程</p>\n<p>同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待</p>\n<p>全局上下文只有唯一的一个，它在浏览器关闭时出栈</p>\n<p>函数的执行上下文的个数没有限制</p>\n<p>每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此</p>\n<ul>\n<li>创建阶段<br>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向</li>\n<li>代码执行阶段<br>创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。<br>变量对象的创建，依次经历了以下几个过程。<ol>\n<li>建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。</li>\n<li>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</li>\n<li>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改.</li>\n</ol>\n</li>\n</ul>\n<h1 id=\"2-变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\"><a href=\"#2-变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\" class=\"headerlink\" title=\"2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期\"></a>2.变量对象和活动对象有什么区别，他们其实都是同一个对象，只是处于执行上下文的不同生命周期</h1><pre><code>demo1:\nfunction test() {\n    console.log(a);\n    console.log(foo());\n\n    var a = 1;\n    function foo() {\n        return 2;\n    }\n}\n\ntest();\n</code></pre><p>function声明会比var声明优先级更高一点，所以在执行过程中顺序就变成了：</p>\n<pre><code>function test() {\n    function foo() {\n        return 2;\n    }\n    var a;\n    console.log(a);\n    console.log(foo());\n    a = 1;\n}\n\ntest();\n\ndemo2:\nfunction test() {\n    console.log(foo);\n    console.log(bar);\n\n    var foo = &apos;Hello&apos;;\n    console.log(foo);\n    var bar = function () {\n        return &apos;world&apos;;\n    }\n\n    function foo() {\n        return &apos;hello&apos;;\n    }\n}\n\ntest();//console.log(foo)会打印函数体，console.log(foo())才打印函数执行结果。\n</code></pre><h1 id=\"3-JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\"><a href=\"#3-JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\" class=\"headerlink\" title=\"3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建\"></a>3.JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，垃圾回收，执行上下文在这个阶段创建</h1><h1 id=\"4-作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符-变量名或函数名-，这样就可以访问到上一层作用域中的变量了。\"><a href=\"#4-作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符-变量名或函数名-，这样就可以访问到上一层作用域中的变量了。\" class=\"headerlink\" title=\"4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。\"></a>4.作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符(变量名或函数名)，这样就可以访问到上一层作用域中的变量了。</h1><hr>\n<h1 id=\"3-闭包：\"><a href=\"#3-闭包：\" class=\"headerlink\" title=\"3.闭包：\"></a>3.闭包：</h1><p>闭包与作用域链息息相关；</p>\n<p>闭包是在函数执行过程中被确认。</p>\n<p>闭包的应用场景</p>\n<p>接下来，我们来总结下，闭包的常用场景。</p>\n<p>延迟函数setTimeout</p>\n<p>我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，</p>\n<pre><code>function fn() {\nconsole.log(&apos;this is test.&apos;)\n}\nvar timer =  setTimeout(fn, 1000);\nconsole.log(timer);\n</code></pre><p>按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。</p>\n<hr>\n<h1 id=\"4-this的指向\"><a href=\"#4-this的指向\" class=\"headerlink\" title=\"4.this的指向\"></a>4.this的指向</h1><p>this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。</p>\n<pre><code>var a = 10;\nvar obj = {\n    a: 20\n}\n\nfunction fn () {\n    console.log(this.a);\n}\n\nfn(); // 10\nfn.call(obj); // 20\n\nvar a = 20;\nvar foo = {\n    a: 10,\n    getA: function () {\n        return this.a;\n    }\n}\nconsole.log(foo.getA()); // 10\n\nvar test = foo.getA;\nconsole.log(test());  // 20\n</code></pre><p>foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。</p>\n<pre><code>  // demo03\n var a = 20; \n var obj = {\n a: 10,\n c: this.a + 20,\n\nfn: function () {\n\n    return this.a;\n\n}\n} \nconsole.log(obj.c);\n</code></pre><p>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</p>\n<p>当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。</p>\n<h1 id=\"5-使用call，apply显示指定this\"><a href=\"#5-使用call，apply显示指定this\" class=\"headerlink\" title=\"5.使用call，apply显示指定this\"></a>5.使用call，apply显示指定this</h1><p>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。</p>\n<p>如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。</p>\n<pre><code>function fn() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj);\n</code></pre><p>而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。</p>\n<pre><code>function fn(num1, num2) {\n    console.log(this.a + num1 + num2);\n}\nvar obj = {\n    a: 20\n}\n\nfn.call(obj, 100, 10); // 130\nfn.apply(obj, [20, 10]); // 50\n</code></pre><h1 id=\"6-http协议：\"><a href=\"#6-http协议：\" class=\"headerlink\" title=\"6.http协议：\"></a>6.http协议：</h1><p>超文本传输协议(HTTP，HyperText Transfer Protocol)</p>\n<p>是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>\n<p>通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。</p>\n<p>HTTP使用TCP而不是UDP的原因在于（打开一个）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。具体细节请参考‘TCP和UDP的不同’。</p>\n<p>通过HTTP或者HTTPS协议请求的资源由统一资源定位器（Uniform Resource Identifiers）（或者，更准确一些，URLs）来标识。</p>\n<p>请求行和标题必须以<cr><lf> 作为结尾（也就是，回车然后换行）。空行内必须只有<cr><lf>而无其他空格。在HTTP/1.1 协议中，所有的请求头，除Host外，都是可选的。</lf></cr></lf></cr></p>\n<p>我们知道，Internet的基本协议是TCP/IP协议，然而在TCP/IP模型最上层的是应用层（Application layer），它包含所有高层的协议。高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等。</p>\n<p>　　HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。这就是你为什么在浏览器中看到的网页地址都是以<a href=\"http://开头的原因。\" target=\"_blank\" rel=\"external\">http://开头的原因。</a></p>\n<h1 id=\"7-ajax\"><a href=\"#7-ajax\" class=\"headerlink\" title=\"7.ajax:\"></a>7.ajax:</h1><p>1.同步：客户端浏览器先发起请求，等待响应，服务器返回响应，客户端才会渲染内容，也就是说客户端每一次发起请求的时候都会把之前的内容删掉，等待服务器给下一次响应</p>\n<p>2.异步：客户端有部分可见，发起请求，服务器返回响应，客户端把更新后的内容追加到dom树上，此时客户端和服务器是同时运行的，浏览器在浏览网页的同时服务器会返回新的内容</p>\n<p>原生ajax:</p>\n<pre><code>var xhr = new XMLHttpRequest();\nxhr.onreadystatechange = function(){\nif(xhr.readyState==4&amp;&amp;xhr.status==200){  //响应完成且成功\nxhr.open（“请求方法”，url，true)\nxhr.send（null/请求主体）//请求主体（键值对，文件上传，json格式）,get没有请求主体，post要设置头部信息\n）\n}\n</code></pre><p>jquery的ajax:<br>    $.ajax({</p>\n<p>  type:’请求方法’，</p>\n<p>  url:’请求地址’，</p>\n<p>  data:’请求数据’（可以是对象，或者是键值对的形式），</p>\n<p>  success:fn  (成功的回调函数)，</p>\n<p>  error:fn,</p>\n<p>  beforeSend:fn,  (请求发送之前的回调)，</p>\n<p>  complete:fn   (不管成功还是失败都要执行的回调)</p>\n<p>})</p>\n<h1 id=\"8-跨域问题：\"><a href=\"#8-跨域问题：\" class=\"headerlink\" title=\"8.跨域问题：\"></a>8.跨域问题：</h1><p>指从一个url上的资源访问另一个url上的资源，这两个资源不在同一个域上，如协议名，域名，端口号不同，这就叫跨域</p>\n<p>浏览器哪些情况下允许跨域：</p>\n<p>带src和href属性的标签，如srcript,img,link,iframe</p>\n<p>所有浏览器都默认禁止xhr对象的跨域请求—-处于“同源安全策略”，不允许放在当前的dom树上。</p>\n<p>面试题：</p>\n<p>我们公司项目项目很大，为了功能上的清晰划分，在static.tedu.cn上放置了所有的静态资源，在data.tedu.cn上放置了所有的动态数据（json格式），请问如何在static.tedu.cn上获取data.tedu.cn/newlist.json上的动态数据？如何绕过浏览器的xhr跨域限制？</p>\n<p>答案：1.CORS方案： （跨源的资源共享）cross origin  Resource  Share（适用于自己可以控制动态页面的编写）</p>\n<p>在被访问的资源响应中添加如下的头部：</p>\n<p>设置一个响应头部（访问控制允许来源）header(‘Access-Control-Allow-Origin:<a href=\"http://127.0.0.1\" target=\"_blank\" rel=\"external\">http://127.0.0.1</a>‘);</p>\n<p>允许从指定的域名发起跨域请求。</p>\n<p>2.jsonp方案：JSON with padding,填充式json，是一种使用json数据的手段、方式。</p>\n<p>思路：使用动态创建的script标签代替xhr发起异步的请求，获取跨域的数据，在本地的Js中加以处理.</p>\n<script async=\"true\" src=\"跨域地址/x.php\"> </script>  //async=true代表异步为真，异步请求\n\n---\n\n    <script>\n    function doResponse(data){\n    处理服务器端返回的data中的数据...\n    }\n\n    </script>\n\n<p>服务器端返回的数据形如：</p>\n<p>Content-Type:application/javascript</p>\n<p>doResponse({x:y, a:b});</p>\n<h1 id=\"9-jQuery中如何发起jsonp请求？\"><a href=\"#9-jQuery中如何发起jsonp请求？\" class=\"headerlink\" title=\"9.jQuery中如何发起jsonp请求？\"></a>9.jQuery中如何发起jsonp请求？</h1><p>1.XHR非跨域请求  $.getJSON(‘xx.php’)</p>\n<p>2.跨域请求: $.getJSON(‘跨域地址/x.php?callback=?’,function(data){..处理服务器返回的数据})</p>\n<pre><code>3.$.ajax({\nurl:&apos;&apos;,\n\ndatatype:&apos;jsonp&apos;,\n\nsuccess:function(data){\n\n     error:function(){}\n     }\n    }) \n</code></pre><h1 id=\"10-html5新特性：\"><a href=\"#10-html5新特性：\" class=\"headerlink\" title=\"10.html5新特性：\"></a>10.html5新特性：</h1><p>1.新的语义标签，2.增强型表单，3.视频和音频，4.Canvas绘图，svg绘图，5.地理定位，6拖放api,7.webWorker  8.webStorage,webSocket</p>\n<h1 id=\"11-函数自执行与块级作用域\"><a href=\"#11-函数自执行与块级作用域\" class=\"headerlink\" title=\"11.函数自执行与块级作用域\"></a>11.函数自执行与块级作用域</h1><p>在ES5中，没有块级作用域，因此我们常常使用函数自执行的方式来模仿块级作用域，这样就提供了一个独立的执行上下文，结合闭包，就为模块化提供了基础。</p>\n<pre><code>(function() {\n   // ...\n})();\n</code></pre><p>一个模块往往可以包括：私有变量、私有方法、公有变量、公有方法。</p>\n<pre><code>(function() {\n    // 私有变量\n    var age = 20;\n    var name = &apos;Tom&apos;;\n\n\n    // 私有方法\n    function getName() {\n        return `your name is ` + name;\n    }\n\n\n    // 共有方法\n    function getAge() {\n        return age;\n    }\n\n    // 将引用保存在外部执行环境的变量中，形成闭包，防止该执行环境被垃圾回收\n    window.getAge = getAge;\n})();\n</code></pre><h1 id=\"12-拖拽的原理\"><a href=\"#12-拖拽的原理\" class=\"headerlink\" title=\"12.拖拽的原理\"></a>12.拖拽的原理</h1><p>当事件触发时，我们可以通过事件对象获取到鼠标的精切位置。这是实现拖拽的关键。当鼠标按下(mousedown触发)时，我们需要记住鼠标的初始位置与目标元素的初始位置，我们的目标就是实现当鼠标移动时，目标元素也跟着移动，根据常理我们可以得出如下关系：</p>\n<pre><code>移动后的鼠标位置 - 鼠标初始位置 = 移动后的目标元素位置 - 目标元素的初始位置\n</code></pre><p>如果鼠标位置的差值我们用dis来表示，那么目标元素的位置就等于：</p>\n<pre><code>移动后目标元素的位置 = dis + 目标元素的初始位置\n</code></pre><p>通过事件对象，我们可以精确的知道鼠标的当前位置，因此当鼠标拖动(mousemove)时，我们可以不停的计算出鼠标移动的差值，以此来求出目标元素的当前位置。这个过程，就实现了拖拽。</p>\n"},{"title":"问题汇总","date":"2016-09-01T10:22:06.000Z","_content":"1、描述一下你只做一个网页的工作流程。\n1）根据需求，确定主题。透彻深入所做网站的核心功能和关键。\n2）收集资料。从对比相同类型的网站（惯用而熟悉的样式，用户更乐意接受），参照别人可行的实现方法。\n3）规划网站。抽离出类似的模块和可重用的部件。如果是响应式网站就需要设定断点，根据不同宽度屏幕设定样式。\n4）设计数据库。\n5）搭建基本的框架。引入重置样式表reset.css和字体样式表font.css，风格统一的图标还有后台需要用到的包。\n6）编码和调试。注意统一命名和编码规范。当多人开发时，还需要制定规范文档。\n7）上传测试。利用FTP工具，把网站发布到自己申请的主页存放服务器上。网站上传以后，你要在浏览器中打开自己的网站，逐页逐个链接的进行测试，发现问题，及时修改，然后再上传测试。\n8）推广宣传 。不断宣传，提高网站的访问率和知名度。推广的方法有很多，例如到搜索引擎上注册、与别的网站交换链接、加入广告链等。\n9）维护更新 。网站要注意经常维护更新内容，保持内容的新鲜，不要一做好就放在那儿不变了，只有不断地给它补充新的内容，才能够吸引住浏览者\n\n\n\n2、你如何对网站的文件和资源进行优化？\n\nhttps://segmentfault.com/a/1190000002956639\n\n一共18条，很详细。几乎涵盖所有网站资源优化的内容。\n\n\n\n\n\n3、如何规避JavaScript多人开发函数重名问题？\n\n    闭包，沙箱模式\n    js模块化mvc（数据层、表现层、控制层）\n    seajs（如果了解的呢，可以说）\n    变量转换成对象的属性\n    对象化\n\n\n\n4、请尽可能详尽的解释AJAX的工作原理。\n\nAjax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。\n\nAjax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。\n\n(1).XMLHTTPRequest对象\n\nAjax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。\n\n(2).JavaScript\n\nJavaScript是一在浏览器中大量使用的编程语言。\n\n(3).DOM Document Object Model\n\nDOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，document就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document Object Model）中，DOM提供了网页中各个对象的读写的支持。\n\n(4).XML\n\n可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。\n\n(5).综合\n\nAjax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。\n\nAjax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。\n\n\n\n5、你使用过哪些JavaScript库？\n\njQuery\n\nanimate\n\nBootstrap\n\nzepto\n\nartTemplate\n\nnormalize：它在默认的HTML元素样式上提供了跨浏览器的高度一致性。\n\nSwiper\n\nfullpage：jQuery全屏滚动插件。\n\n了解更多：\n\nhttps://www.evget.com/article/2013/9/22/19657.html\n","source":"_posts/question.md","raw":"---\ntitle: 问题汇总\ndate: 2016-09-01 18:22:06\ntags:\n---\n1、描述一下你只做一个网页的工作流程。\n1）根据需求，确定主题。透彻深入所做网站的核心功能和关键。\n2）收集资料。从对比相同类型的网站（惯用而熟悉的样式，用户更乐意接受），参照别人可行的实现方法。\n3）规划网站。抽离出类似的模块和可重用的部件。如果是响应式网站就需要设定断点，根据不同宽度屏幕设定样式。\n4）设计数据库。\n5）搭建基本的框架。引入重置样式表reset.css和字体样式表font.css，风格统一的图标还有后台需要用到的包。\n6）编码和调试。注意统一命名和编码规范。当多人开发时，还需要制定规范文档。\n7）上传测试。利用FTP工具，把网站发布到自己申请的主页存放服务器上。网站上传以后，你要在浏览器中打开自己的网站，逐页逐个链接的进行测试，发现问题，及时修改，然后再上传测试。\n8）推广宣传 。不断宣传，提高网站的访问率和知名度。推广的方法有很多，例如到搜索引擎上注册、与别的网站交换链接、加入广告链等。\n9）维护更新 。网站要注意经常维护更新内容，保持内容的新鲜，不要一做好就放在那儿不变了，只有不断地给它补充新的内容，才能够吸引住浏览者\n\n\n\n2、你如何对网站的文件和资源进行优化？\n\nhttps://segmentfault.com/a/1190000002956639\n\n一共18条，很详细。几乎涵盖所有网站资源优化的内容。\n\n\n\n\n\n3、如何规避JavaScript多人开发函数重名问题？\n\n    闭包，沙箱模式\n    js模块化mvc（数据层、表现层、控制层）\n    seajs（如果了解的呢，可以说）\n    变量转换成对象的属性\n    对象化\n\n\n\n4、请尽可能详尽的解释AJAX的工作原理。\n\nAjax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。\n\nAjax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。\n\n(1).XMLHTTPRequest对象\n\nAjax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。\n\n(2).JavaScript\n\nJavaScript是一在浏览器中大量使用的编程语言。\n\n(3).DOM Document Object Model\n\nDOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，document就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document Object Model）中，DOM提供了网页中各个对象的读写的支持。\n\n(4).XML\n\n可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。\n\n(5).综合\n\nAjax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。\n\nAjax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。\n\n\n\n5、你使用过哪些JavaScript库？\n\njQuery\n\nanimate\n\nBootstrap\n\nzepto\n\nartTemplate\n\nnormalize：它在默认的HTML元素样式上提供了跨浏览器的高度一致性。\n\nSwiper\n\nfullpage：jQuery全屏滚动插件。\n\n了解更多：\n\nhttps://www.evget.com/article/2013/9/22/19657.html\n","slug":"question","published":1,"updated":"2017-08-02T11:09:16.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5v07ehr0006cwuvjij8ilq7","content":"<p>1、描述一下你只做一个网页的工作流程。<br>1）根据需求，确定主题。透彻深入所做网站的核心功能和关键。<br>2）收集资料。从对比相同类型的网站（惯用而熟悉的样式，用户更乐意接受），参照别人可行的实现方法。<br>3）规划网站。抽离出类似的模块和可重用的部件。如果是响应式网站就需要设定断点，根据不同宽度屏幕设定样式。<br>4）设计数据库。<br>5）搭建基本的框架。引入重置样式表reset.css和字体样式表font.css，风格统一的图标还有后台需要用到的包。<br>6）编码和调试。注意统一命名和编码规范。当多人开发时，还需要制定规范文档。<br>7）上传测试。利用FTP工具，把网站发布到自己申请的主页存放服务器上。网站上传以后，你要在浏览器中打开自己的网站，逐页逐个链接的进行测试，发现问题，及时修改，然后再上传测试。<br>8）推广宣传 。不断宣传，提高网站的访问率和知名度。推广的方法有很多，例如到搜索引擎上注册、与别的网站交换链接、加入广告链等。<br>9）维护更新 。网站要注意经常维护更新内容，保持内容的新鲜，不要一做好就放在那儿不变了，只有不断地给它补充新的内容，才能够吸引住浏览者</p>\n<p>2、你如何对网站的文件和资源进行优化？</p>\n<p><a href=\"https://segmentfault.com/a/1190000002956639\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000002956639</a></p>\n<p>一共18条，很详细。几乎涵盖所有网站资源优化的内容。</p>\n<p>3、如何规避JavaScript多人开发函数重名问题？</p>\n<pre><code>闭包，沙箱模式\njs模块化mvc（数据层、表现层、控制层）\nseajs（如果了解的呢，可以说）\n变量转换成对象的属性\n对象化\n</code></pre><p>4、请尽可能详尽的解释AJAX的工作原理。</p>\n<p>Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p>\n<p>Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。</p>\n<p>(1).XMLHTTPRequest对象</p>\n<p>Ajax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。</p>\n<p>(2).JavaScript</p>\n<p>JavaScript是一在浏览器中大量使用的编程语言。</p>\n<p>(3).DOM Document Object Model</p>\n<p>DOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，document就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document Object Model）中，DOM提供了网页中各个对象的读写的支持。</p>\n<p>(4).XML</p>\n<p>可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。</p>\n<p>(5).综合</p>\n<p>Ajax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。</p>\n<p>Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。</p>\n<p>5、你使用过哪些JavaScript库？</p>\n<p>jQuery</p>\n<p>animate</p>\n<p>Bootstrap</p>\n<p>zepto</p>\n<p>artTemplate</p>\n<p>normalize：它在默认的HTML元素样式上提供了跨浏览器的高度一致性。</p>\n<p>Swiper</p>\n<p>fullpage：jQuery全屏滚动插件。</p>\n<p>了解更多：</p>\n<p><a href=\"https://www.evget.com/article/2013/9/22/19657.html\" target=\"_blank\" rel=\"external\">https://www.evget.com/article/2013/9/22/19657.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1、描述一下你只做一个网页的工作流程。<br>1）根据需求，确定主题。透彻深入所做网站的核心功能和关键。<br>2）收集资料。从对比相同类型的网站（惯用而熟悉的样式，用户更乐意接受），参照别人可行的实现方法。<br>3）规划网站。抽离出类似的模块和可重用的部件。如果是响应式网站就需要设定断点，根据不同宽度屏幕设定样式。<br>4）设计数据库。<br>5）搭建基本的框架。引入重置样式表reset.css和字体样式表font.css，风格统一的图标还有后台需要用到的包。<br>6）编码和调试。注意统一命名和编码规范。当多人开发时，还需要制定规范文档。<br>7）上传测试。利用FTP工具，把网站发布到自己申请的主页存放服务器上。网站上传以后，你要在浏览器中打开自己的网站，逐页逐个链接的进行测试，发现问题，及时修改，然后再上传测试。<br>8）推广宣传 。不断宣传，提高网站的访问率和知名度。推广的方法有很多，例如到搜索引擎上注册、与别的网站交换链接、加入广告链等。<br>9）维护更新 。网站要注意经常维护更新内容，保持内容的新鲜，不要一做好就放在那儿不变了，只有不断地给它补充新的内容，才能够吸引住浏览者</p>\n<p>2、你如何对网站的文件和资源进行优化？</p>\n<p><a href=\"https://segmentfault.com/a/1190000002956639\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000002956639</a></p>\n<p>一共18条，很详细。几乎涵盖所有网站资源优化的内容。</p>\n<p>3、如何规避JavaScript多人开发函数重名问题？</p>\n<pre><code>闭包，沙箱模式\njs模块化mvc（数据层、表现层、控制层）\nseajs（如果了解的呢，可以说）\n变量转换成对象的属性\n对象化\n</code></pre><p>4、请尽可能详尽的解释AJAX的工作原理。</p>\n<p>Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做, 只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p>\n<p>Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。</p>\n<p>(1).XMLHTTPRequest对象</p>\n<p>Ajax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。</p>\n<p>(2).JavaScript</p>\n<p>JavaScript是一在浏览器中大量使用的编程语言。</p>\n<p>(3).DOM Document Object Model</p>\n<p>DOM是给HTML和XML文件使用的一组API。它提供了文件的结构表述，让你可以改变其中的內容及可见物。其本质是建立网页与Script或程序语言沟通的桥梁。所有WEB开发人员可操作及建立文件的属性、方法及事件都以对象来展现（例如，document就代表“文件本身“这个对像，table对象则代表HTML的表格对象等等）。这些对象可以由当今大多数的浏览器以Script来取用。一个用HTML或XHTML构建的网页也可以看作是一组结构化的数据，这些数据被封在DOM（Document Object Model）中，DOM提供了网页中各个对象的读写的支持。</p>\n<p>(4).XML</p>\n<p>可扩展的标记语言（Extensible Markup Language）具有一种开放的、可扩展的、可自描述的语言结构，它已经成为网上数据和文档传输的标准,用于其他应用程序交换数据 。</p>\n<p>(5).综合</p>\n<p>Ajax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。</p>\n<p>Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。</p>\n<p>5、你使用过哪些JavaScript库？</p>\n<p>jQuery</p>\n<p>animate</p>\n<p>Bootstrap</p>\n<p>zepto</p>\n<p>artTemplate</p>\n<p>normalize：它在默认的HTML元素样式上提供了跨浏览器的高度一致性。</p>\n<p>Swiper</p>\n<p>fullpage：jQuery全屏滚动插件。</p>\n<p>了解更多：</p>\n<p><a href=\"https://www.evget.com/article/2013/9/22/19657.html\" target=\"_blank\" rel=\"external\">https://www.evget.com/article/2013/9/22/19657.html</a></p>\n"},{"title":"立志：有志者，事竟成","date":"2016-08-02T11:03:11.000Z","_content":"立志：有志者，事竟成\n\n阳明说，“志不立，天下无可成之事。”朱熹也说，“为学须先立志。志既立，则学问可次第着力。立志不定，终不济事。”\n\n立志就是《大学》上讲的“知止”。所谓“知止而后有定”，立志就是知道你人生的终极目的是什么，用以终为始的思维开始你的奋斗历程。王阳明自己，从少年之时便立下志向，要像朱子那样成为圣人。 来贵州龙场前，王阳明已经年近不惑，刻苦求学了将近三十年。对于立志这件事，近三十年来王阳明自己深有体会，一个人如果没有确立自己的志向，就好像船没有了舵、马没有了缰绳，于是只能随波飘荡、四处奔逸，人生不知所终。\n\n立志者，为学之心也；为学者，立志之事也。\n\n在阳明这里，立志是学习的动力，学习是实现志向的过程。然而，人的志向有高有低，有善也有恶。阳明这里讲的立志，其实是在导人向善，要大家立一个真切为善之志，为君子之志。\n\n也就是说，在确立自己的志向之时，你要清楚自己所立的志向是君子之志还是小人之志。王阳明说，“立志成为圣人，就会成为圣人；立志成为贤人，就会成为贤人。”因此，无论你做什么，立志是首要的事情。\n\n另外，阳明讲“立志贵专一”。今日立一志，明日立一志，不会有任何成就。正所谓，有志者立长志，无志者常立志。王阳明打了一个比喻，立志就像种树，立下志向后，犹如在心中种下了一颗根苗，只管去浇灌它，总有一天这颗根苗会长成参天大树，而不要去想什么时候才能开花结果，多想无益。只要你坚定不移地朝着自己的志向奋斗，就一定会见到自己浇灌出来的丰富果实。\n\n\n\n\n\n作者：未晓研心\n\n链接：http://www.jianshu.com/p/d10a1821c479\n\n來源：简书\n\n\n\n\n","source":"_posts/zhixiang.md","raw":"---\ntitle: 立志：有志者，事竟成\ndate: 2016-08-02 19:03:11\ntags:\n---\n立志：有志者，事竟成\n\n阳明说，“志不立，天下无可成之事。”朱熹也说，“为学须先立志。志既立，则学问可次第着力。立志不定，终不济事。”\n\n立志就是《大学》上讲的“知止”。所谓“知止而后有定”，立志就是知道你人生的终极目的是什么，用以终为始的思维开始你的奋斗历程。王阳明自己，从少年之时便立下志向，要像朱子那样成为圣人。 来贵州龙场前，王阳明已经年近不惑，刻苦求学了将近三十年。对于立志这件事，近三十年来王阳明自己深有体会，一个人如果没有确立自己的志向，就好像船没有了舵、马没有了缰绳，于是只能随波飘荡、四处奔逸，人生不知所终。\n\n立志者，为学之心也；为学者，立志之事也。\n\n在阳明这里，立志是学习的动力，学习是实现志向的过程。然而，人的志向有高有低，有善也有恶。阳明这里讲的立志，其实是在导人向善，要大家立一个真切为善之志，为君子之志。\n\n也就是说，在确立自己的志向之时，你要清楚自己所立的志向是君子之志还是小人之志。王阳明说，“立志成为圣人，就会成为圣人；立志成为贤人，就会成为贤人。”因此，无论你做什么，立志是首要的事情。\n\n另外，阳明讲“立志贵专一”。今日立一志，明日立一志，不会有任何成就。正所谓，有志者立长志，无志者常立志。王阳明打了一个比喻，立志就像种树，立下志向后，犹如在心中种下了一颗根苗，只管去浇灌它，总有一天这颗根苗会长成参天大树，而不要去想什么时候才能开花结果，多想无益。只要你坚定不移地朝着自己的志向奋斗，就一定会见到自己浇灌出来的丰富果实。\n\n\n\n\n\n作者：未晓研心\n\n链接：http://www.jianshu.com/p/d10a1821c479\n\n來源：简书\n\n\n\n\n","slug":"zhixiang","published":1,"updated":"2017-08-02T11:09:16.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5v07ehs0007cwuvi16l2lqm","content":"<p>立志：有志者，事竟成</p>\n<p>阳明说，“志不立，天下无可成之事。”朱熹也说，“为学须先立志。志既立，则学问可次第着力。立志不定，终不济事。”</p>\n<p>立志就是《大学》上讲的“知止”。所谓“知止而后有定”，立志就是知道你人生的终极目的是什么，用以终为始的思维开始你的奋斗历程。王阳明自己，从少年之时便立下志向，要像朱子那样成为圣人。 来贵州龙场前，王阳明已经年近不惑，刻苦求学了将近三十年。对于立志这件事，近三十年来王阳明自己深有体会，一个人如果没有确立自己的志向，就好像船没有了舵、马没有了缰绳，于是只能随波飘荡、四处奔逸，人生不知所终。</p>\n<p>立志者，为学之心也；为学者，立志之事也。</p>\n<p>在阳明这里，立志是学习的动力，学习是实现志向的过程。然而，人的志向有高有低，有善也有恶。阳明这里讲的立志，其实是在导人向善，要大家立一个真切为善之志，为君子之志。</p>\n<p>也就是说，在确立自己的志向之时，你要清楚自己所立的志向是君子之志还是小人之志。王阳明说，“立志成为圣人，就会成为圣人；立志成为贤人，就会成为贤人。”因此，无论你做什么，立志是首要的事情。</p>\n<p>另外，阳明讲“立志贵专一”。今日立一志，明日立一志，不会有任何成就。正所谓，有志者立长志，无志者常立志。王阳明打了一个比喻，立志就像种树，立下志向后，犹如在心中种下了一颗根苗，只管去浇灌它，总有一天这颗根苗会长成参天大树，而不要去想什么时候才能开花结果，多想无益。只要你坚定不移地朝着自己的志向奋斗，就一定会见到自己浇灌出来的丰富果实。</p>\n<p>作者：未晓研心</p>\n<p>链接：<a href=\"http://www.jianshu.com/p/d10a1821c479\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/d10a1821c479</a></p>\n<p>來源：简书</p>\n","site":{"data":{}},"excerpt":"","more":"<p>立志：有志者，事竟成</p>\n<p>阳明说，“志不立，天下无可成之事。”朱熹也说，“为学须先立志。志既立，则学问可次第着力。立志不定，终不济事。”</p>\n<p>立志就是《大学》上讲的“知止”。所谓“知止而后有定”，立志就是知道你人生的终极目的是什么，用以终为始的思维开始你的奋斗历程。王阳明自己，从少年之时便立下志向，要像朱子那样成为圣人。 来贵州龙场前，王阳明已经年近不惑，刻苦求学了将近三十年。对于立志这件事，近三十年来王阳明自己深有体会，一个人如果没有确立自己的志向，就好像船没有了舵、马没有了缰绳，于是只能随波飘荡、四处奔逸，人生不知所终。</p>\n<p>立志者，为学之心也；为学者，立志之事也。</p>\n<p>在阳明这里，立志是学习的动力，学习是实现志向的过程。然而，人的志向有高有低，有善也有恶。阳明这里讲的立志，其实是在导人向善，要大家立一个真切为善之志，为君子之志。</p>\n<p>也就是说，在确立自己的志向之时，你要清楚自己所立的志向是君子之志还是小人之志。王阳明说，“立志成为圣人，就会成为圣人；立志成为贤人，就会成为贤人。”因此，无论你做什么，立志是首要的事情。</p>\n<p>另外，阳明讲“立志贵专一”。今日立一志，明日立一志，不会有任何成就。正所谓，有志者立长志，无志者常立志。王阳明打了一个比喻，立志就像种树，立下志向后，犹如在心中种下了一颗根苗，只管去浇灌它，总有一天这颗根苗会长成参天大树，而不要去想什么时候才能开花结果，多想无益。只要你坚定不移地朝着自己的志向奋斗，就一定会见到自己浇灌出来的丰富果实。</p>\n<p>作者：未晓研心</p>\n<p>链接：<a href=\"http://www.jianshu.com/p/d10a1821c479\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/d10a1821c479</a></p>\n<p>來源：简书</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}